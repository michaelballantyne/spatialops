/* This file was generated by fulmar version 0.8.0. */

/*
 * Copyright (c) 2013 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_STENCILS_H
#  define NEBO_STENCILS_H

   namespace SpatialOps {
      template<int Length>
       struct NeboStencilCoefCollection {
         public:
          NeboStencilCoefCollection(NeboStencilCoefCollection<Length - 1> const
                                    & o,
                                    double const c)
          : others_(o), coef_(c)
          {}

          inline NeboStencilCoefCollection<Length + 1> const operator ()(double
                                                                         const c) const {
             return NeboStencilCoefCollection<Length + 1>(*this, c);
          }

          inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             if(index >= Length) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             return (index == Length - 1 ? coef() : others().get_coef(index));
          }

          inline NeboStencilCoefCollection<Length - 1> const others(void) const {
             return others_;
          }

         private:
          NeboStencilCoefCollection<Length - 1> const others_;

          double const coef_;
      };

      template<>
       struct NeboStencilCoefCollection<1> {
         public:
          NeboStencilCoefCollection(double const c)
          : coef_(c)
          {}

          inline NeboStencilCoefCollection<2> const operator ()(double const c) const {
             return NeboStencilCoefCollection<2>(*this, c);
          }

          inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             if(index > 1) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             return coef();
          }

         private:
          double const coef_;
      };

      inline NeboStencilCoefCollection<1> const build_coef_collection(double
                                                                      const c) {
         return NeboStencilCoefCollection<1>(c);
      };

      inline NeboStencilCoefCollection<2> const build_two_point_coef_collection(double
                                                                                const
                                                                                c1,
                                                                                double
                                                                                const
                                                                                c2) {
         return NeboStencilCoefCollection<1>(c1)(c2);
      };

      inline NeboStencilCoefCollection<4> const build_four_point_coef_collection(double
                                                                                 const
                                                                                 c1,
                                                                                 double
                                                                                 const
                                                                                 c2,
                                                                                 double
                                                                                 const
                                                                                 c3,
                                                                                 double
                                                                                 const
                                                                                 c4) {
         return NeboStencilCoefCollection<1>(c1)(c2)(c3)(c4);
      };

      template<typename PointType, typename CollectionType>
       struct NeboStencilPointCollection {
         public:
          PointType typedef Point;

          CollectionType typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          enum {length = 1 + Collection::length};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          template<typename GivenPossibleValidGhost>
           struct PossibleGhost {
             typename structured::Invalidate<GivenPossibleValidGhost, Point>::
             result typedef CurrentPossibleValidGhost;

             typename Collection::template PossibleGhost<GivenPossibleValidGhost>
             typedef EarlierPointsPossibleGhost;

             typename EarlierPointsPossibleGhost::Result typedef
             EarlierPointsPossibleValidGhost;

             typename structured::Minimum<CurrentPossibleValidGhost,
                                          EarlierPointsPossibleValidGhost>::
             result typedef Result;
          };

          template<typename ArgPreSeqWalk, typename DestType>
           struct ConstructExpr {
             NeboScalar<SeqWalk, DestType> typedef Coef;

             typename ArgPreSeqWalk::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef, DestType> typedef MultiplyType;

             typename Collection::template ConstructExpr<ArgPreSeqWalk, DestType>
             typedef EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<SeqWalk, EarlierPointsResult, MultiplyType, DestType> typedef
             Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_sq_construct(ArgPreSeqWalk const &
                                                         arg,
                                                         NeboStencilCoefCollection<length>
                                                         const & coefs) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template in_sq_construct<ValidGhost,
                                                                           Shift>(arg,
                                                                                  coefs.others()),
                               MultiplyType(arg.template init<ValidGhost,
                                                              NewShift>(),
                                            Coef(coefs.coef())));
              }

             template<typename Shift>
              static inline Result const rs_sq_construct(ArgPreSeqWalk const &
                                                         arg,
                                                         NeboStencilCoefCollection<length>
                                                         const & coefs,
                                                         structured::IntVec
                                                         const & split,
                                                         structured::IntVec
                                                         const & location) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template rs_sq_construct<Shift>(arg,
                                                                                  coefs.others(),
                                                                                  split,
                                                                                  location),
                               MultiplyType(arg.template init<NewShift>(split,
                                                                        location),
                                            Coef(coefs.coef())));
              }
          };

#         ifdef __CUDACC__
             template<typename ArgPreGPUWalk, typename DestType>
              struct ConstructGPUExpr {
                NeboScalar<GPUWalk, DestType> typedef Coef;

                typename ArgPreGPUWalk::GPUWalkType typedef Arg;

                ProdOp<GPUWalk, Arg, Coef, DestType> typedef MultiplyType;

                typename Collection::template ConstructGPUExpr<ArgPreGPUWalk,
                                                               DestType> typedef
                EarlierPointsType;

                typename EarlierPointsType::Result typedef EarlierPointsResult;

                SumOp<GPUWalk, EarlierPointsResult, MultiplyType, DestType>
                typedef Result;

                template<typename ValidGhost, typename Shift>
                 static inline Result const in_gpu_construct(int const
                                                             deviceIndex,
                                                             ArgPreGPUWalk const
                                                             & arg,
                                                             NeboStencilCoefCollection<length>
                                                             const & coefs) {
                    typename structured::Add<Shift, Point>::result typedef
                    NewShift;

                    return Result(EarlierPointsType::template in_gpu_construct<ValidGhost,
                                                                               Shift>(deviceIndex,
                                                                                      arg,
                                                                                      coefs.others()),
                                  MultiplyType(arg.template gpu_init<ValidGhost,
                                                                     NewShift>(deviceIndex),
                                               Coef(coefs.coef())));
                 }
             };
#         endif
          /* __CUDACC__ */

          template<typename ArgPreReduction, typename DestType>
           struct ConstructReductionExpr {
             NeboScalar<Reduction, DestType> typedef Coef;

             typename ArgPreReduction::ReductionType typedef Arg;

             ProdOp<Reduction, Arg, Coef, DestType> typedef MultiplyType;

             typename Collection::template ConstructReductionExpr<ArgPreReduction,
                                                                  DestType>
             typedef EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<Reduction, EarlierPointsResult, MultiplyType, DestType>
             typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_rd_construct(ArgPreReduction const &
                                                         arg,
                                                         NeboStencilCoefCollection<length>
                                                         const & coefs) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template in_rd_construct<ValidGhost,
                                                                           Shift>(arg,
                                                                                  coefs.others()),
                               MultiplyType(arg.template reduce_init<ValidGhost,
                                                                     NewShift>(),
                                            Coef(coefs.coef())));
              }

             template<typename Shift>
              static inline Result const rs_rd_construct(ArgPreReduction const &
                                                         arg,
                                                         NeboStencilCoefCollection<length>
                                                         const & coefs) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template rs_rd_construct<Shift>(arg,
                                                                                  coefs.others()),
                               MultiplyType(arg.template reduce_init<NewShift>(),
                                            Coef(coefs.coef())));
              }
          };
      };

      template<typename PointType>
       struct NeboStencilPointCollection<PointType, NeboNil> {
         public:
          PointType typedef Point;

          NeboNil typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          enum {length = 1};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          template<typename GivenPossibleValidGhost>
           struct PossibleGhost {
             typename structured::Invalidate<GivenPossibleValidGhost, Point>::
             result typedef Result;
          };

          template<typename ArgPreSeqWalk, typename DestType>
           struct ConstructExpr {
             NeboScalar<SeqWalk, DestType> typedef Coef;

             typename ArgPreSeqWalk::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_sq_construct(ArgPreSeqWalk const &
                                                         arg,
                                                         NeboStencilCoefCollection<1>
                                                         const & coefs) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template init<ValidGhost, NewShift>(), Coef(coefs.coef()));
              }

             template<typename Shift>
              static inline Result const rs_sq_construct(ArgPreSeqWalk const &
                                                         arg,
                                                         NeboStencilCoefCollection<1>
                                                         const & coefs,
                                                         structured::IntVec
                                                         const & split,
                                                         structured::IntVec
                                                         const & location) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template init<NewShift>(split, location),
                               Coef(coefs.coef()));
              }
          };

#         ifdef __CUDACC__
             template<typename ArgPreGPUWalk, typename DestType>
              struct ConstructGPUExpr {
                NeboScalar<GPUWalk, DestType> typedef Coef;

                typename ArgPreGPUWalk::GPUWalkType typedef Arg;

                ProdOp<GPUWalk, Arg, Coef, DestType> typedef Result;

                template<typename ValidGhost, typename Shift>
                 static inline Result const in_gpu_construct(int const
                                                             deviceIndex,
                                                             ArgPreGPUWalk const
                                                             & arg,
                                                             NeboStencilCoefCollection<1>
                                                             const & coefs) {
                    typename structured::Add<Shift, Point>::result typedef
                    NewShift;

                    return Result(arg.template gpu_init<ValidGhost, NewShift>(deviceIndex),
                                  Coef(coefs.coef()));
                 }
             };
#         endif
          /* __CUDACC__ */

          template<typename ArgPreReduction, typename DestType>
           struct ConstructReductionExpr {
             NeboScalar<Reduction, DestType> typedef Coef;

             typename ArgPreReduction::ReductionType typedef Arg;

             ProdOp<Reduction, Arg, Coef, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_rd_construct(ArgPreReduction const &
                                                         arg,
                                                         NeboStencilCoefCollection<1>
                                                         const & coefs) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template reduce_init<ValidGhost, NewShift>(),
                               Coef(coefs.coef()));
              }

             template<typename Shift>
              static inline Result const rs_rd_construct(ArgPreReduction const &
                                                         arg,
                                                         NeboStencilCoefCollection<1>
                                                         const & coefs) {
                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template reduce_init<NewShift>(), Coef(coefs.coef()));
              }
          };
      };

      template<typename First>
       struct BuildStencilPointCollection {
         NeboStencilPointCollection<First, NeboNil> typedef Result;
      };

      template<typename First, typename Second>
       struct BuildTwoPointCollection {
         typename BuildStencilPointCollection<First>::Result typedef FirstPoint;

         typename FirstPoint::template AddPoint<Second>::Result typedef Result;
      };

      template<typename First, typename Second, typename Third, typename Fourth>
       struct BuildFourPointCollection {
         typename BuildStencilPointCollection<First>::Result typedef FirstPoint;

         typename FirstPoint::template AddPoint<Second>::Result typedef
         SecondFirstCollection;

         typename SecondFirstCollection::template AddPoint<Third>::Result
         typedef ThirdSecondFirstCollection;

         typename ThirdSecondFirstCollection::template AddPoint<Fourth>::Result
         typedef Result;
      };

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          typename Pts::template ConstructExpr<Arg, FieldType> typedef
          ConstructExpr;

          typename ConstructExpr::Result typedef ArgSeqWalkType;

#         ifdef __CUDACC__
             typename Pts::template ConstructGPUExpr<Arg, FieldType> typedef
             ConstructGPUExpr;
             typename ConstructGPUExpr::Result typedef ArgGPUWalkType;
#         endif
          /* __CUDACC__ */

          typename Pts::template ConstructReductionExpr<Arg, FieldType> typedef
          ConstructReductionExpr;

          typename ConstructReductionExpr::Result typedef ArgReductionType;

          NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NeboStencil<Resize, Pts, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NeboStencil<GPUWalk, Pts, ArgGPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          NeboStencil<Reduction, Pts, ArgReductionType, FieldType> typedef
          ReductionType;

          typename Pts::template PossibleGhost<typename Arg::PossibleValidGhost>::
          Result typedef PossibleValidGhost;

          NeboStencil(Arg const & a, Coefs const & coefs)
          : arg_(a), coefs_(coefs)
          {}

          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(ConstructExpr::template in_sq_construct<ValidGhost,
                                                                         Shift>(arg_,
                                                                                coefs_));
           }

#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(arg_.template resize<ValidGhost>(), coefs_);
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(int const deviceIndex) const {
                 return GPUWalkType(ConstructGPUExpr::template in_gpu_construct<ValidGhost,
                                                                                Shift>(deviceIndex,
                                                                                       arg_,
                                                                                       coefs_));
              }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(ConstructExpr::template in_reduce_construct<ValidGhost,
                                                                               Shift>(arg_,
                                                                                      coefs_));
           }

         private:
          Arg const arg_;

          Coefs const coefs_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             typename Pts::template ConstructExpr<Arg, FieldType> typedef
             ConstructExpr;

             typename ConstructExpr::Result typedef ArgSeqWalkType;

             NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef
             SeqWalkType;

             NeboStencil(Arg const & arg, Coefs const & coefs)
             : arg_(arg), coefs_(coefs)
             {}

             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(ConstructExpr::template rs_sq_construct<Shift>(arg_,
                                                                                   coefs_,
                                                                                   split,
                                                                                   location));
              }

            private:
             Arg const arg_;

             Coefs const coefs_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef AtomicType;

          NeboStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline AtomicType eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };
#     ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             NeboStencil(Arg const & a)
             : arg_(a)
             {}

             __device__ inline void start(int x, int y) { arg_.start(x, y); }

             __device__ inline void next(void) { arg_.next(); }

             __device__ inline AtomicType eval(void) const {
                return arg_.eval();
             }

            private:
             Arg arg_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Reduction, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef AtomicType;

          NeboStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline bool at_end(void) const { return arg_.at_end(); }

          inline bool has_length(void) const { return arg_.has_length(); }

          inline AtomicType eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };
   } /* SpatialOps */

#endif
/* NEBO_STENCILS_H */
