 ; Copyright (c) 2013 The University of Utah
 ;
 ; Permission is hereby granted, free of charge, to any person obtaining a copy
 ; of this software and associated documentation files (the "Software"), to
 ; deal in the Software without restriction, including without limitation the
 ; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 ; sell copies of the Software, and to permit persons to whom the Software is
 ; furnished to do so, subject to the following conditions:
 ;
 ; The above copyright notice and this permission notice shall be included in
 ; all copies or substantial portions of the Software.
 ;
 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 ; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 ; IN THE SOFTWARE.

(define l literal-chunk)
(define c concat-chunk)
(define b between-chunk)
(define b/a between/attach-chunk)
(define n namespace-define-chunk)
(define d described-smts-chunk)
(define p paren-list-chunk)
(define m macro-define-chunk)
(define s space-chunk)
(define (cs . chunks)
  (c chunks s))
(define (scs . chunks)
  (c s chunks s))
(define (cc . chunks)
  (c chunks semi-colon-chunk))
(define (ccs first second)
  (c first semi-colon-chunk s second))
(define (bs . chunks)
  (apply b s chunks))
(define (sbs . chunks)
  (cc (bs chunks)))
(define (bl-smts . chunks)
  (internal-smt-list-chunk blank-line-chunk chunks))
(define (nl-smts . chunks)
  (smt-list-chunk new-line-chunk chunks))
(define typedef typedef-smt-chunk)
(define (s-typedef first second)
  (cc (typedef-smt-chunk first second)))
(define fc function-call-chunk)
(define mfc member-function-call-chunk)
(define fcn-def function-define-chunk)
(define v-fcn-def void-function-define-chunk)
(define v-fcn-dcl void-function-declare-chunk)
(define r-fcn-def returning-function-define-chunk)
(define fcn-dcl function-declare-chunk)
(define gen-fcn-dcl general-function-declare-chunk)
(define constize constize-chunk)
(define s-fcn-dcl static-function-declare-chunk)
(define tpl-def template-define-chunk)
(define srt-dcl struct-declare-chunk)
(define (s-srt-dcl . chunks)
  (cc (apply srt-dcl chunks)))
(define srt-def struct-define-chunk)
(define (s-srt-def . chunks)
  (cc (apply srt-def chunks)))
(define tpl-srt-dcl template-struct-declare-chunk)
(define (s-tpl-srt-dcl . chunks)
  (cc (apply tpl-srt-dcl chunks)))
(define tpl-srt-def template-struct-define-chunk)
(define (s-tpl-srt-def . chunks)
  (cc (apply tpl-srt-def chunks)))
(define tpl-use template-use-chunk)
(define (tpl-pmtr pmtr)
  (c typename-chunk s pmtr))
(define (sub-tpl-use pmtr)
  (c template-chunk s pmtr))
(define (tpl-fcn-use . pmtrs)
  (sub-tpl-use (apply tpl-use pmtrs)))
(define pub-sec public-section-chunk)
(define priv-sec private-section-chunk)
(define cons-asgn constructor-assignment-chunk)
(define scope scope-resolution-operator-chunk)
(define (enum . enums)
  (sbs 'enum (body-list-chunk comma-chunk enums)))
(define (kernel-use name . args)
  (tpl-use name (tpl-use null (tpl-use null args))))
(define (device-use . chunks)
  (c '__device__ s chunks))
(define (pp-cond-or name then else)
  (pp-conditional-ifdef-chunk name
                              (c then)
                              (if (not else)
                                  #false
                                  (c else))))
(define (threads-or then else)
  (pp-cond-or 'FIELD_EXPRESSION_THREADS then else))
(define (threads-only . chunks)
  (threads-or chunks #false))
(define (gpu-or then else)
  (pp-cond-or '__CUDACC__ then else))
(define (gpu-only . chunks)
  (gpu-or chunks #false))
(define (gpu-test-or then else)
  (pp-cond-or 'NEBO_GPU_TEST then else))
(define (gpu-test-only . chunks)
  (gpu-test-or chunks #false))
(define (report-backend-or then else)
  (pp-cond-or 'NEBO_REPORT_BACKEND then else))
(define (report-backend-only . chunks)
  (report-backend-or chunks #false))
(define (report-backend-cout type backend-name)
  (report-backend-only (bs (scope 'std 'cout)
                           '<<
                           (c "\"" type s 'Nebo s backend-name "\"")
                           '<<
                           (scope 'std 'endl))))
(define (report-backend-start backend-name)
  (report-backend-cout 'Starting backend-name))
(define (report-backend-finish backend-name)
  (report-backend-cout 'Finished backend-name))
(define (full-gpu-test-or then else)
  (gpu-only (gpu-test-or then else)))
(define (full-gpu-test-only . chunks)
  (full-gpu-test-or chunks #false))
(define (par . chunks)
  (p (bs chunks)))
(define (ter-cond if then else)
  (par if '? then colon-chunk else))
(define (op-asgn op lhs . rhs)
  (bs lhs op rhs))
(define (n= lhs . rhs)
  (op-asgn '= lhs rhs))
(define (nt= type lhs . rhs)
  (n= (bs type lhs) rhs))
(define (nt=c type lhs . rhs)
  (nt= (bs const-chunk type) lhs rhs))
(define (n+= lhs . rhs)
  (op-asgn '+= lhs rhs))
(define (n== lhs . rhs)
  (op-asgn '== lhs rhs))
(define (n!= lhs . rhs)
  (op-asgn '!= lhs rhs))
(define (n< lhs . rhs)
  (op-asgn '< lhs rhs))
(define (n> lhs . rhs)
  (op-asgn '> lhs rhs))
(define (n<= lhs . rhs)
  (op-asgn '<= lhs rhs))
(define (n>= lhs . rhs)
  (op-asgn '>= lhs rhs))
(define (n+ lhs . rhs)
  (op-asgn '+ lhs rhs))
(define (n- lhs . rhs)
  (op-asgn '- lhs rhs))
(define (n* lhs . rhs)
  (op-asgn '* lhs rhs))
(define (n/ lhs . rhs)
  (op-asgn '/ lhs rhs))
(define (n% lhs . rhs)
  (op-asgn '% lhs rhs))
(define (n++ chunk)
  (l chunk '++))
(define (n-and lhs . rhs)
  (b (scs '&&) lhs rhs))
(define (n-or lhs . rhs)
  (b (scs "||") lhs rhs))
(define (n-not chunk)
  (c '! (par chunk)))
(define (tc . chunks)
  (bs chunks const-chunk))
(define (stc . chunks)
  (cc (tc chunks)))
(define (ref . chunks)
  (bs chunks '&))
(define (cref . chunks)
  (ref (tc chunks)))
(define (ptr . chunks)
  (bs chunks '*))
(define (cptr . chunks)
  (ptr (tc chunks)))
(define (ad type arg)
  (bs type arg))
(define (sad type arg)
  (cc (ad type arg)))
(define (adc type arg)
  (bs (tc type) arg))
(define (sadc type arg)
  (cc (adc type arg)))
(define (adr type arg)
  (bs (ref type) arg))
(define (sadr type arg)
  (cc (adr type arg)))
(define (adcr type arg)
  (bs (cref type) arg))
(define (sadcr type arg)
  (cc (adcr type arg)))
(define (adp type arg)
  (bs (ptr type) arg))
(define (sadp type arg)
  (cc (adp type arg)))
(define (adcp type arg)
  (bs (cptr type) arg))
(define (sadcp type arg)
  (cc (adcp type arg)))
(define (take-ptr . chunks)
  (c '& chunks))
(define (nif check . then)
  (bs (fc 'if check)
      (body-chunk then)))
(define (nelse else)
  (bs 'else (body-chunk else)))
(define (nifelse check then else)
  (b new-line-chunk
     (nif check then)
     (nelse else)))
(define (nelseif check . then)
  (bs 'else (nif check then)))
(define (nifelseif check1 then1 check2 then2)
  (b new-line-chunk
     (nif check1 then1)
     (nelseif check2 then2)))
(define (nwhile while . body)
  (bs (fc 'while while)
      (body-chunk body)))
(define (nfor init check next . body)
  (bs (fc 'for (bs (cc init)
                   (cc check)
                   next))
      (body-chunk body)))
