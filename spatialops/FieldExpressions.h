/* This file was generated by fulmar version 0.7.6. */
/*
 * Copyright (c) 2011 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef SpatialOps_FieldExpressions_h
#  define SpatialOps_FieldExpressions_h

#  include <spatialops/SpatialOpsConfigure.h>
#  include <spatialops/structured/SpatialField.h>
#  include <cmath>

   /*#include <iostream> */

#  ifdef FIELD_EXPRESSION_THREADS
#     include <vector>
#     include <boost/bind.hpp>
#     include <spatialops/ThreadPool.h>
#     include <spatialops/structured/IntVec.h>
#     include <boost/interprocess/sync/interprocess_semaphore.hpp>
      namespace BI = boost::interprocess;
#  endif
   /* FIELD_EXPRESSION_THREADS */

   namespace SpatialOps {

#     ifdef FIELD_EXPRESSION_THREADS
         /* used within nebo to determine if thread parallelism should be used */
         bool is_nebo_thread_parallel(void);
         /* used within nebo to get current soft (active) thread count */
         int get_nebo_soft_thread_count(void);
         /* used by tests to change current soft (active) thread count at runtime */
         int set_nebo_soft_thread_count(int thread_count);
         /* used within nebo to get current hard (max/total) thread count */
         int get_nebo_hard_thread_count(void);
         /* used by tests to change current hard (max/total) thread count at runtime */
         int set_nebo_hard_thread_count(int thread_count);
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      /* Meta-programming compiler flags */
      struct UseWholeIterator;
      struct UseInteriorIterator;

      template<typename Use, typename FieldType>
       struct IteratorStyle;

      /* UseWholeIterator */
      template<typename FieldType>
       struct IteratorStyle<UseWholeIterator, FieldType> {

         typename FieldType::memory_window typedef MemoryWindow;

         typename FieldType::iterator typedef Iterator;

         typename FieldType::const_iterator typedef ConstIterator;

         static inline MemoryWindow const & memory_window(FieldType const & field) {
            return field.window_with_ghost();
         };

         static inline Iterator begin(FieldType & field) { return field.begin(); };

         static inline ConstIterator begin(FieldType const & field) { return field.begin(); };

         static inline Iterator end(FieldType & field) { return field.end(); };

         static inline ConstIterator end(FieldType const & field) { return field.end(); };
      };

      /* UseInteriorIterator */
      template<typename FieldType>
       struct IteratorStyle<UseInteriorIterator, FieldType> {

         typename FieldType::memory_window typedef MemoryWindow;

         typename FieldType::interior_iterator typedef Iterator;

         typename FieldType::const_interior_iterator typedef ConstIterator;

         static inline MemoryWindow const & memory_window(FieldType const & field) {
            return field.window_without_ghost();
         };

         static inline Iterator begin(FieldType & field) { return field.interior_begin(); };

         static inline ConstIterator begin(FieldType const & field) {
            return field.interior_begin();
         };

         static inline Iterator end(FieldType & field) { return field.interior_end(); };

         static inline ConstIterator end(FieldType const & field) { return field.interior_end(); };
      };

      template<typename Operand, typename FieldType>
       struct NeboExpression {

         public:
          FieldType typedef field_type;
          Operand typedef Expression;
          NeboExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      template<typename Operand, typename FieldType>
       struct NeboBooleanExpression {

         public:
          FieldType typedef field_type;
          Operand typedef Expression;
          NeboBooleanExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      /* Modes: */
      struct Initial;
      template<typename IteratorType, typename SourceType>
       struct ResizePrep;
      template<typename IteratorType, typename SourceType>
       struct Resize;
      template<typename IteratorType, typename SourceType>
       struct SeqWalk;

      template<typename CurrentMode, typename FieldType>
       struct NeboScalar;

      template<typename FieldType>
       struct NeboScalar<Initial, FieldType> {

         public:
          NeboScalar<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboScalar<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboScalar<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(AtomicType const v)
          : value_(v)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboScalar<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboScalar<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboScalar<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(SourceType const source)
          : value_(source.value())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboScalar<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboScalar<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboScalar<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(MemoryWindow const & size, SourceType const source)
          : value_(source.value())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboScalar<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboScalar<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(SourceType const source)
          : value_(source.value())
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline AtomicType const eval(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboBoolean;

      template<typename FieldType>
       struct NeboBoolean<Initial, FieldType> {

         public:
          NeboBoolean<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboBoolean<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboBoolean<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          NeboBoolean(bool const v)
          : value_(v)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboBoolean<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboBoolean<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          NeboBoolean(SourceType const source)
          : value_(source.value())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboBoolean<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboBoolean<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          NeboBoolean(MemoryWindow const & size, SourceType const source)
          : value_(source.value())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboBoolean<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboBoolean<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean(SourceType const source)
          : value_(source.value())
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline bool const eval(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboConstField;

      template<typename FieldType>
       struct NeboConstField<Initial, FieldType> {

         public:
          NeboConstField<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboConstField<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboConstField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          NeboConstField(FieldType const & f)
          : field_(f)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboConstField<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboConstField<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboConstField<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          NeboConstField(SourceType const & source)
          : field_(source.field())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboConstField<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboConstField<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboConstField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          NeboConstField(MemoryWindow const & size, SourceType const & source)
          : field_(size, source.field().field_values(), structured::ExternalStorage)
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboConstField<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboConstField<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboConstField(SourceType const & source)
          : iter_(IteratorStyle<IteratorType, FieldType>::begin(source.field())),
            end_(IteratorStyle<IteratorType, FieldType>::end(source.field()))
          {};
          inline void next(void) { ++iter_; };
          inline bool at_end(void) const { return (iter_ == end_); };
          inline bool has_length(void) const { return true; };
          inline AtomicType const & eval(void) const { return *iter_; };

         private:
          typename FieldType::const_iterator iter_;
          typename FieldType::const_iterator const end_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboField;

      template<typename FieldType>
       struct NeboField<Initial, FieldType> {

         public:
          NeboField<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboField<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          NeboField(FieldType & f)
          : field_(f)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboField<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboField<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboField<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          NeboField(SourceType & source)
          : field_(source.field())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) {
             return ResizeType(newSize, *this);
          };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboField<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboField<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          NeboField(MemoryWindow const & size, SourceType & source)
          : field_(size, source.field().field_values(), structured::ExternalStorage)
          {};
          inline SeqWalkType init(void) { return SeqWalkType(*this); };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboField<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboField<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboField(SourceType & source)
          : iter_(IteratorStyle<IteratorType, FieldType>::begin(source.field())),
            end_(IteratorStyle<IteratorType, FieldType>::end(source.field()))
          {};
          inline void next(void) { ++iter_; };
          inline bool at_end(void) const { return (iter_ == end_); };
          inline bool has_length(void) const { return true; };
          inline AtomicType & ref(void) { return *iter_; };
          inline AtomicType * ptr(void) { return &(*iter_); };

         private:
          typename FieldType::iterator iter_;
          typename FieldType::iterator const end_;
      };

      template<typename Input, typename FieldType>
       struct Standardize;

      template<typename FieldType>
       struct Standardize<FieldType, FieldType> {

         NeboConstField<Initial, FieldType> typedef StandardType;

         NeboExpression<StandardType, FieldType> typedef StandardTerm;

         static inline StandardType standardType(FieldType const & given) {
            return StandardType(given);
         };

         static inline StandardTerm standardTerm(FieldType const & given) {
            return StandardTerm(StandardType(given));
         };
      };

      template<typename ExprType, typename FieldType>
       struct Standardize<NeboExpression<ExprType, FieldType>, FieldType> {

         ExprType typedef StandardType;

         NeboExpression<StandardType, FieldType> typedef StandardTerm;

         static inline StandardType standardType(NeboExpression<ExprType, FieldType> const & given) {
            return given.expr();
         };

         static inline StandardTerm standardTerm(NeboExpression<ExprType, FieldType> const & given) {
            return given;
         };
      };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct SumOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Initial, Operand1, Operand2, FieldType> {

         public:
          SumOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             SumOp<ResizePrep<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                   typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                   FieldType> typedef ResizePrepType;

             SumOp<SeqWalk<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                   typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          };
          SumOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct SumOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          SumOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SumOp<Resize<IteratorType, This>,
                typename Operand1::ResizeType,
                typename Operand2::ResizeType,
                FieldType> typedef ResizeType;
          SumOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct SumOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          SumOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SumOp<SeqWalk<IteratorType, This>,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;
          SumOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct SumOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          SumOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SumOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() + operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<SumOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator +(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<SumOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator +(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                   typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                   StandardType,
                                   typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator +(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Initial, Operand1, Operand2, FieldType> {

         public:
          DiffOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             DiffOp<ResizePrep<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                    typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             DiffOp<SeqWalk<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                    typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          DiffOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DiffOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DiffOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DiffOp<Resize<IteratorType, This>,
                 typename Operand1::ResizeType,
                 typename Operand2::ResizeType,
                 FieldType> typedef ResizeType;
          DiffOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DiffOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DiffOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DiffOp<SeqWalk<IteratorType, This>,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;
          DiffOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DiffOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DiffOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DiffOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() - operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<DiffOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator -(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<DiffOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator -(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator -(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Initial, Operand1, Operand2, FieldType> {

         public:
          ProdOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             ProdOp<ResizePrep<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                    typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             ProdOp<SeqWalk<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                    typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          ProdOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct ProdOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          ProdOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ProdOp<Resize<IteratorType, This>,
                 typename Operand1::ResizeType,
                 typename Operand2::ResizeType,
                 FieldType> typedef ResizeType;
          ProdOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct ProdOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          ProdOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ProdOp<SeqWalk<IteratorType, This>,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;
          ProdOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct ProdOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          ProdOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ProdOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() * operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<ProdOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator *(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<ProdOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator *(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator *(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DivOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Initial, Operand1, Operand2, FieldType> {

         public:
          DivOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             DivOp<ResizePrep<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                   typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                   FieldType> typedef ResizePrepType;

             DivOp<SeqWalk<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                   typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          };
          DivOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DivOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DivOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DivOp<Resize<IteratorType, This>,
                typename Operand1::ResizeType,
                typename Operand2::ResizeType,
                FieldType> typedef ResizeType;
          DivOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DivOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DivOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DivOp<SeqWalk<IteratorType, This>,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;
          DivOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DivOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DivOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DivOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() / operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<DivOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator /(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<DivOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator /(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                   typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                   StandardType,
                                   typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator /(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SinFcn;

      template<typename Operand, typename FieldType>
       struct SinFcn<Initial, Operand, FieldType> {

         public:
          SinFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             SinFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             SinFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          SinFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SinFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SinFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SinFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          SinFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SinFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SinFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SinFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          SinFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SinFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SinFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SinFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sin(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<SinFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> sin(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          SinFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct CosFcn;

      template<typename Operand, typename FieldType>
       struct CosFcn<Initial, Operand, FieldType> {

         public:
          CosFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             CosFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             CosFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          CosFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct CosFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          CosFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          CosFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          CosFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct CosFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          CosFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          CosFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          CosFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct CosFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          CosFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          CosFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::cos(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<CosFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> cos(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          CosFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanFcn;

      template<typename Operand, typename FieldType>
       struct TanFcn<Initial, Operand, FieldType> {

         public:
          TanFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             TanFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             TanFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          TanFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          TanFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          TanFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tan(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<TanFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> tan(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          TanFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct ExpFcn;

      template<typename Operand, typename FieldType>
       struct ExpFcn<Initial, Operand, FieldType> {

         public:
          ExpFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             ExpFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             ExpFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          ExpFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct ExpFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          ExpFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ExpFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          ExpFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct ExpFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          ExpFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ExpFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          ExpFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct ExpFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          ExpFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ExpFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::exp(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<ExpFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> exp(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          ExpFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanhFcn;

      template<typename Operand, typename FieldType>
       struct TanhFcn<Initial, Operand, FieldType> {

         public:
          TanhFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             TanhFcn<ResizePrep<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::ResizePrepType,
                     FieldType> typedef ResizePrepType;

             TanhFcn<SeqWalk<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          };
          TanhFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanhFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanhFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanhFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          TanhFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanhFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanhFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanhFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          TanhFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanhFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanhFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanhFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tanh(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<TanhFcn<Initial,
                                     typename Standardize<SubExpr, typename SubExpr::field_type>::
                                     StandardType,
                                     typename SubExpr::field_type>,
                             typename SubExpr::field_type> tanh(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          TanhFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct AbsFcn;

      template<typename Operand, typename FieldType>
       struct AbsFcn<Initial, Operand, FieldType> {

         public:
          AbsFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             AbsFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             AbsFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          AbsFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct AbsFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          AbsFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AbsFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          AbsFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct AbsFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          AbsFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AbsFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          AbsFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct AbsFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          AbsFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          AbsFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::abs(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<AbsFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> abs(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          AbsFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NegFcn;

      template<typename Operand, typename FieldType>
       struct NegFcn<Initial, Operand, FieldType> {

         public:
          NegFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NegFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             NegFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          NegFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NegFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NegFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NegFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          NegFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NegFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NegFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NegFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          NegFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NegFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NegFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          NegFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return -(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<NegFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> operator -(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          NegFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Initial, Operand1, Operand2, FieldType> {

         public:
          PowFcn<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             PowFcn<ResizePrep<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                    typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             PowFcn<SeqWalk<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                    typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          PowFcn(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct PowFcn<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          PowFcn<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          PowFcn<Resize<IteratorType, This>,
                 typename Operand1::ResizeType,
                 typename Operand2::ResizeType,
                 FieldType> typedef ResizeType;
          PowFcn(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct PowFcn<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          PowFcn<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          PowFcn<SeqWalk<IteratorType, This>,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;
          PowFcn(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct PowFcn<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          PowFcn<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          PowFcn(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const {
             return std::pow(operand1_.eval(), operand2_.eval());
          };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<PowFcn<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> pow(SubExpr1 const & arg1,
                                                                SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<PowFcn<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> pow(SubExpr1 const & arg1,
                                                                typename SubExpr1::field_type::
                                                                value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> pow(typename SubExpr2::field_type::
                                                                value_type const & arg1,
                                                                SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SqrtFcn;

      template<typename Operand, typename FieldType>
       struct SqrtFcn<Initial, Operand, FieldType> {

         public:
          SqrtFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             SqrtFcn<ResizePrep<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::ResizePrepType,
                     FieldType> typedef ResizePrepType;

             SqrtFcn<SeqWalk<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          };
          SqrtFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SqrtFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SqrtFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SqrtFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          SqrtFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SqrtFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SqrtFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SqrtFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          SqrtFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SqrtFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SqrtFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SqrtFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sqrt(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<SqrtFcn<Initial,
                                     typename Standardize<SubExpr, typename SubExpr::field_type>::
                                     StandardType,
                                     typename SubExpr::field_type>,
                             typename SubExpr::field_type> sqrt(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          SqrtFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct LogFcn;

      template<typename Operand, typename FieldType>
       struct LogFcn<Initial, Operand, FieldType> {

         public:
          LogFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             LogFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             LogFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          LogFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct LogFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          LogFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LogFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          LogFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct LogFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          LogFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LogFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          LogFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct LogFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          LogFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          LogFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::log(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<LogFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> log(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          LogFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          EqualCmp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             EqualCmp<ResizePrep<IteratorType, This>,
                      typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                      typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                      FieldType> typedef ResizePrepType;

             EqualCmp<SeqWalk<IteratorType, This>,
                      typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                      typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                      FieldType> typedef SeqWalkType;
          };
          EqualCmp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct EqualCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          EqualCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          EqualCmp<Resize<IteratorType, This>,
                   typename Operand1::ResizeType,
                   typename Operand2::ResizeType,
                   FieldType> typedef ResizeType;
          EqualCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct EqualCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          EqualCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          EqualCmp<SeqWalk<IteratorType, This>,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          EqualCmp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct EqualCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          EqualCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          EqualCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() == operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             typename Standardize<SubExpr1,
                                                                  typename SubExpr1::field_type>::
                                             StandardType,
                                             typename Standardize<SubExpr2,
                                                                  typename SubExpr1::field_type>::
                                             StandardType,
                                             typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator ==(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          EqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             typename Standardize<SubExpr1,
                                                                  typename SubExpr1::field_type>::
                                             StandardType,
                                             NeboScalar<Initial, typename SubExpr1::field_type>,
                                             typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator ==(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          EqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial, typename SubExpr2::field_type>,
                                             typename Standardize<SubExpr2,
                                                                  typename SubExpr2::field_type>::
                                             StandardType,
                                             typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator ==(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          EqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          InequalCmp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             InequalCmp<ResizePrep<IteratorType, This>,
                        typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                        typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                        FieldType> typedef ResizePrepType;

             InequalCmp<SeqWalk<IteratorType, This>,
                        typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                        typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                        FieldType> typedef SeqWalkType;
          };
          InequalCmp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct InequalCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          InequalCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef
          This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          InequalCmp<Resize<IteratorType, This>,
                     typename Operand1::ResizeType,
                     typename Operand2::ResizeType,
                     FieldType> typedef ResizeType;
          InequalCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct InequalCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          InequalCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          InequalCmp<SeqWalk<IteratorType, This>,
                     typename Operand1::SeqWalkType,
                     typename Operand2::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          InequalCmp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct InequalCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          InequalCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          InequalCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() != operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               typename Standardize<SubExpr1,
                                                                    typename SubExpr1::field_type>::
                                               StandardType,
                                               typename Standardize<SubExpr2,
                                                                    typename SubExpr1::field_type>::
                                               StandardType,
                                               typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator !=(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          InequalCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               typename Standardize<SubExpr1,
                                                                    typename SubExpr1::field_type>::
                                               StandardType,
                                               NeboScalar<Initial, typename SubExpr1::field_type>,
                                               typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator !=(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          InequalCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial, typename SubExpr2::field_type>,
                                               typename Standardize<SubExpr2,
                                                                    typename SubExpr2::field_type>::
                                               StandardType,
                                               typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator !=(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          InequalCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          LessThanCmp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             LessThanCmp<ResizePrep<IteratorType, This>,
                         typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                         typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                         FieldType> typedef ResizePrepType;

             LessThanCmp<SeqWalk<IteratorType, This>,
                         typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                         typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                         FieldType> typedef SeqWalkType;
          };
          LessThanCmp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          LessThanCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef
          This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanCmp<Resize<IteratorType, This>,
                      typename Operand1::ResizeType,
                      typename Operand2::ResizeType,
                      FieldType> typedef ResizeType;
          LessThanCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          LessThanCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanCmp<SeqWalk<IteratorType, This>,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType,
                      FieldType> typedef SeqWalkType;
          LessThanCmp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          LessThanCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() < operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                typename Standardize<SubExpr1,
                                                                     typename SubExpr1::field_type>::
                                                StandardType,
                                                typename Standardize<SubExpr2,
                                                                     typename SubExpr1::field_type>::
                                                StandardType,
                                                typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <(SubExpr1 const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          LessThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                typename Standardize<SubExpr1,
                                                                     typename SubExpr1::field_type>::
                                                StandardType,
                                                NeboScalar<Initial, typename SubExpr1::field_type>,
                                                typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <(SubExpr1 const & arg1,
                                                                              typename SubExpr1::
                                                                              field_type::value_type
                                                                              const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          LessThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial, typename SubExpr2::field_type>,
                                                typename Standardize<SubExpr2,
                                                                     typename SubExpr2::field_type>::
                                                StandardType,
                                                typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator <(typename SubExpr2::
                                                                              field_type::value_type
                                                                              const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          LessThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          LessThanEqualCmp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             LessThanEqualCmp<ResizePrep<IteratorType, This>,
                              typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                              typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                              FieldType> typedef ResizePrepType;

             LessThanEqualCmp<SeqWalk<IteratorType, This>,
                              typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                              typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                              FieldType> typedef SeqWalkType;
          };
          LessThanEqualCmp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanEqualCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          LessThanEqualCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType>
          typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanEqualCmp<Resize<IteratorType, This>,
                           typename Operand1::ResizeType,
                           typename Operand2::ResizeType,
                           FieldType> typedef ResizeType;
          LessThanEqualCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanEqualCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          LessThanEqualCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef
          This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanEqualCmp<SeqWalk<IteratorType, This>,
                           typename Operand1::SeqWalkType,
                           typename Operand2::SeqWalkType,
                           FieldType> typedef SeqWalkType;
          LessThanEqualCmp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanEqualCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          LessThanEqualCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef
          This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanEqualCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() <= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     typename Standardize<SubExpr1,
                                                                          typename SubExpr1::
                                                                          field_type>::StandardType,
                                                     typename Standardize<SubExpr2,
                                                                          typename SubExpr1::
                                                                          field_type>::StandardType,
                                                     typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <=(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          LessThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     typename Standardize<SubExpr1,
                                                                          typename SubExpr1::
                                                                          field_type>::StandardType,
                                                     NeboScalar<Initial,
                                                                typename SubExpr1::field_type>,
                                                     typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <=(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          LessThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial,
                                                                typename SubExpr2::field_type>,
                                                     typename Standardize<SubExpr2,
                                                                          typename SubExpr2::
                                                                          field_type>::StandardType,
                                                     typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator <=(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          LessThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          GreaterThanCmp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             GreaterThanCmp<ResizePrep<IteratorType, This>,
                            typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                            typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                            FieldType> typedef ResizePrepType;

             GreaterThanCmp<SeqWalk<IteratorType, This>,
                            typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                            typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                            FieldType> typedef SeqWalkType;
          };
          GreaterThanCmp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          GreaterThanCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType>
          typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanCmp<Resize<IteratorType, This>,
                         typename Operand1::ResizeType,
                         typename Operand2::ResizeType,
                         FieldType> typedef ResizeType;
          GreaterThanCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          GreaterThanCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef
          This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanCmp<SeqWalk<IteratorType, This>,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType,
                         FieldType> typedef SeqWalkType;
          GreaterThanCmp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          GreaterThanCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef
          This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() > operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   typename Standardize<SubExpr1,
                                                                        typename SubExpr1::
                                                                        field_type>::StandardType,
                                                   typename Standardize<SubExpr2,
                                                                        typename SubExpr1::
                                                                        field_type>::StandardType,
                                                   typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >(SubExpr1 const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          GreaterThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   typename Standardize<SubExpr1,
                                                                        typename SubExpr1::
                                                                        field_type>::StandardType,
                                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                                   typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >(SubExpr1 const & arg1,
                                                                              typename SubExpr1::
                                                                              field_type::value_type
                                                                              const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          GreaterThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                                   typename Standardize<SubExpr2,
                                                                        typename SubExpr2::
                                                                        field_type>::StandardType,
                                                   typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator >(typename SubExpr2::
                                                                              field_type::value_type
                                                                              const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          GreaterThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          GreaterThanEqualCmp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             GreaterThanEqualCmp<ResizePrep<IteratorType, This>,
                                 typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                                 typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                                 FieldType> typedef ResizePrepType;

             GreaterThanEqualCmp<SeqWalk<IteratorType, This>,
                                 typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                                 typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                                 FieldType> typedef SeqWalkType;
          };
          GreaterThanEqualCmp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanEqualCmp<ResizePrep<IteratorType, SourceType>,
                                  Operand1,
                                  Operand2,
                                  FieldType> {

         public:
          GreaterThanEqualCmp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType>
          typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanEqualCmp<Resize<IteratorType, This>,
                              typename Operand1::ResizeType,
                              typename Operand2::ResizeType,
                              FieldType> typedef ResizeType;
          GreaterThanEqualCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanEqualCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          GreaterThanEqualCmp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType>
          typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanEqualCmp<SeqWalk<IteratorType, This>,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType,
                              FieldType> typedef SeqWalkType;
          GreaterThanEqualCmp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanEqualCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          GreaterThanEqualCmp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType>
          typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanEqualCmp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() >= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        typename Standardize<SubExpr1,
                                                                             typename SubExpr1::
                                                                             field_type>::
                                                        StandardType,
                                                        typename Standardize<SubExpr2,
                                                                             typename SubExpr1::
                                                                             field_type>::
                                                        StandardType,
                                                        typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >=(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          GreaterThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        typename Standardize<SubExpr1,
                                                                             typename SubExpr1::
                                                                             field_type>::
                                                        StandardType,
                                                        NeboScalar<Initial,
                                                                   typename SubExpr1::field_type>,
                                                        typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >=(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          GreaterThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial,
                                                                   typename SubExpr2::field_type>,
                                                        typename Standardize<SubExpr2,
                                                                             typename SubExpr2::
                                                                             field_type>::
                                                        StandardType,
                                                        typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator >=(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          GreaterThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct AndOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<Initial, Operand1, Operand2, FieldType> {

         public:
          AndOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             AndOp<ResizePrep<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                   typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                   FieldType> typedef ResizePrepType;

             AndOp<SeqWalk<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                   typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          };
          AndOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct AndOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          AndOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AndOp<Resize<IteratorType, This>,
                typename Operand1::ResizeType,
                typename Operand2::ResizeType,
                FieldType> typedef ResizeType;
          AndOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct AndOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          AndOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AndOp<SeqWalk<IteratorType, This>,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;
          AndOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct AndOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          AndOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          AndOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() && operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2>
       inline NeboBooleanExpression<AndOp<Initial,
                                          typename SubBoolExpr1::Expression,
                                          typename SubBoolExpr2::Expression,
                                          typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator &&(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          AndOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(arg2.expr())));
       };

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1>
       inline NeboBooleanExpression<AndOp<Initial,
                                          typename SubBoolExpr1::Expression,
                                          NeboBoolean<Initial, typename SubBoolExpr1::field_type>,
                                          typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator &&(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   bool const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          NeboBoolean<Initial, typename SubBoolExpr1::field_type> typedef Type2;

          AndOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(Type2(arg2))));
       };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboBoolean<Initial, typename SubBoolExpr2::field_type>,
                                          typename SubBoolExpr2::Expression,
                                          typename SubBoolExpr2::field_type>,
                                    typename SubBoolExpr2::field_type> operator &&(bool const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr2::field_type typedef FieldType;

          NeboBoolean<Initial, typename SubBoolExpr2::field_type> typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          AndOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)), Type2(arg2.expr())));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct OrOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<Initial, Operand1, Operand2, FieldType> {

         public:
          OrOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             OrOp<ResizePrep<IteratorType, This>,
                  typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                  typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                  FieldType> typedef ResizePrepType;

             OrOp<SeqWalk<IteratorType, This>,
                  typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                  typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                  FieldType> typedef SeqWalkType;
          };
          OrOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct OrOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          OrOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          OrOp<Resize<IteratorType, This>,
               typename Operand1::ResizeType,
               typename Operand2::ResizeType,
               FieldType> typedef ResizeType;
          OrOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct OrOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          OrOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          OrOp<SeqWalk<IteratorType, This>,
               typename Operand1::SeqWalkType,
               typename Operand2::SeqWalkType,
               FieldType> typedef SeqWalkType;
          OrOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct OrOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          OrOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          OrOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() || operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2>
       inline NeboBooleanExpression<OrOp<Initial,
                                         typename SubBoolExpr1::Expression,
                                         typename SubBoolExpr2::Expression,
                                         typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator ||(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          OrOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(arg2.expr())));
       };

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1>
       inline NeboBooleanExpression<OrOp<Initial,
                                         typename SubBoolExpr1::Expression,
                                         NeboBoolean<Initial, typename SubBoolExpr1::field_type>,
                                         typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator ||(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   bool const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          NeboBoolean<Initial, typename SubBoolExpr1::field_type> typedef Type2;

          OrOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(Type2(arg2))));
       };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboBoolean<Initial, typename SubBoolExpr2::field_type>,
                                         typename SubBoolExpr2::Expression,
                                         typename SubBoolExpr2::field_type>,
                                    typename SubBoolExpr2::field_type> operator ||(bool const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr2::field_type typedef FieldType;

          NeboBoolean<Initial, typename SubBoolExpr2::field_type> typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          OrOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)), Type2(arg2.expr())));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NotOp;

      template<typename Operand, typename FieldType>
       struct NotOp<Initial, Operand, FieldType> {

         public:
          NotOp<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NotOp<ResizePrep<IteratorType, This>,
                   typename Operand::template Iterator<IteratorType>::ResizePrepType,
                   FieldType> typedef ResizePrepType;

             NotOp<SeqWalk<IteratorType, This>,
                   typename Operand::template Iterator<IteratorType>::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          };
          NotOp(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NotOp<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NotOp<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NotOp<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          NotOp(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NotOp<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NotOp<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NotOp<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          NotOp(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NotOp<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NotOp<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          NotOp(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return !(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubBoolExpr */
      template<typename SubBoolExpr>
       inline NeboBooleanExpression<NotOp<Initial,
                                          typename SubBoolExpr::Expression,
                                          typename SubBoolExpr::field_type>,
                                    typename SubBoolExpr::field_type> operator !(SubBoolExpr const &
                                                                                 arg) {

          typename SubBoolExpr::field_type typedef FieldType;

          typename SubBoolExpr::Expression typedef Type;

          NotOp<Initial, Type, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(arg.expr())));
       };

#     define BUILD_BINARY_FUNCTION(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                      \
         template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>  \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Initial, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Initial, Operand1, Operand2, FieldType> typedef This;                     \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             template<typename IteratorType>                                                       \
              struct Iterator {                                                                    \
                                                                                                   \
                OBJECT_NAME<ResizePrep<IteratorType, This>,                                        \
                            typename Operand1::template Iterator<IteratorType>::ResizePrepType,    \
                            typename Operand2::template Iterator<IteratorType>::ResizePrepType,    \
                            FieldType> typedef ResizePrepType;                                     \
                                                                                                   \
                OBJECT_NAME<SeqWalk<IteratorType, This>,                                           \
                            typename Operand1::template Iterator<IteratorType>::SeqWalkType,       \
                            typename Operand2::template Iterator<IteratorType>::SeqWalkType,       \
                            FieldType> typedef SeqWalkType;                                        \
             };                                                                                    \
             OBJECT_NAME(Operand1 const & op1, Operand2 const & op2)                               \
             : operand1_(op1), operand2_(op2)                                                      \
             {};                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::SeqWalkType init(void) const {               \
                 return typename Iterator<IteratorType>::SeqWalkType(*this);                       \
              };                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {     \
                 return typename Iterator<IteratorType>::ResizePrepType(*this);                    \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> { \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType>      \
             typedef This;                                                                         \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize<IteratorType, This>,                                               \
                         typename Operand1::ResizeType,                                            \
                         typename Operand2::ResizeType,                                            \
                         FieldType> typedef ResizeType;                                            \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline ResizeType resize(MemoryWindow const & newSize) const {                        \
                return ResizeType(newSize, *this);                                                 \
             };                                                                                    \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {    \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef  \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk<IteratorType, This>,                                              \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             OBJECT_NAME(MemoryWindow const & size, SourceType const & source)                     \
             : operand1_(size, source.operand1()), operand2_(size, source.operand2())              \
             {};                                                                                   \
             inline SeqWalkType init(void) const { return SeqWalkType(*this); };                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {   \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline void next(void) { operand1_.next(); operand2_.next(); };                       \
             inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); }; \
             inline bool has_length(void) const {                                                  \
                return (operand1_.has_length() || operand2_.has_length());                         \
             };                                                                                    \
             inline EvalReturnType eval(void) const {                                              \
                return INTERNAL_NAME(operand1_.eval(), operand2_.eval());                          \
             };                                                                                    \
                                                                                                   \
            private:                                                                               \
             Operand1 operand1_;                                                                   \
             Operand2 operand2_;                                                                   \
         };                                                                                        \
                                                                                                   \
         /* SubExpr X SubExpr */                                                                   \
         template<typename SubExpr1, typename SubExpr2>                                            \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };                                                                                       \
                                                                                                   \
         /* SubExpr X Scalar */                                                                    \
         template<typename SubExpr1>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            NeboScalar<Initial, typename SubExpr1::field_type>,    \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             typename SubExpr1::   \
                                                                             field_type::value_type \
                                                                             const & arg2) {       \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;                     \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Type2(arg2))));                                    \
          };                                                                                       \
                                                                                                   \
         /* Scalar X SubExpr */                                                                    \
         template<typename SubExpr2>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            NeboScalar<Initial, typename SubExpr2::field_type>,    \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr2::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr2::field_type>,                        \
                                typename SubExpr2::field_type> EXTERNAL_NAME(typename SubExpr2::   \
                                                                             field_type::value_type \
                                                                             const & arg1,         \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr2::field_type typedef FieldType;                                      \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;                     \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Type1(arg1)),                                      \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };

#     define BUILD_BINARY_OPERATOR(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                      \
         template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>  \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Initial, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Initial, Operand1, Operand2, FieldType> typedef This;                     \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             template<typename IteratorType>                                                       \
              struct Iterator {                                                                    \
                                                                                                   \
                OBJECT_NAME<ResizePrep<IteratorType, This>,                                        \
                            typename Operand1::template Iterator<IteratorType>::ResizePrepType,    \
                            typename Operand2::template Iterator<IteratorType>::ResizePrepType,    \
                            FieldType> typedef ResizePrepType;                                     \
                                                                                                   \
                OBJECT_NAME<SeqWalk<IteratorType, This>,                                           \
                            typename Operand1::template Iterator<IteratorType>::SeqWalkType,       \
                            typename Operand2::template Iterator<IteratorType>::SeqWalkType,       \
                            FieldType> typedef SeqWalkType;                                        \
             };                                                                                    \
             OBJECT_NAME(Operand1 const & op1, Operand2 const & op2)                               \
             : operand1_(op1), operand2_(op2)                                                      \
             {};                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::SeqWalkType init(void) const {               \
                 return typename Iterator<IteratorType>::SeqWalkType(*this);                       \
              };                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {     \
                 return typename Iterator<IteratorType>::ResizePrepType(*this);                    \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> { \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType>      \
             typedef This;                                                                         \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize<IteratorType, This>,                                               \
                         typename Operand1::ResizeType,                                            \
                         typename Operand2::ResizeType,                                            \
                         FieldType> typedef ResizeType;                                            \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline ResizeType resize(MemoryWindow const & newSize) const {                        \
                return ResizeType(newSize, *this);                                                 \
             };                                                                                    \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {    \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef  \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk<IteratorType, This>,                                              \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             OBJECT_NAME(MemoryWindow const & size, SourceType const & source)                     \
             : operand1_(size, source.operand1()), operand2_(size, source.operand2())              \
             {};                                                                                   \
             inline SeqWalkType init(void) const { return SeqWalkType(*this); };                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {   \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline void next(void) { operand1_.next(); operand2_.next(); };                       \
             inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); }; \
             inline bool has_length(void) const {                                                  \
                return (operand1_.has_length() || operand2_.has_length());                         \
             };                                                                                    \
             inline EvalReturnType eval(void) const {                                              \
                return (operand1_.eval() INTERNAL_NAME operand2_.eval());                          \
             };                                                                                    \
                                                                                                   \
            private:                                                                               \
             Operand1 operand1_;                                                                   \
             Operand2 operand2_;                                                                   \
         };                                                                                        \
                                                                                                   \
         /* SubExpr X SubExpr */                                                                   \
         template<typename SubExpr1, typename SubExpr2>                                            \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };                                                                                       \
                                                                                                   \
         /* SubExpr X Scalar */                                                                    \
         template<typename SubExpr1>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            NeboScalar<Initial, typename SubExpr1::field_type>,    \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             typename SubExpr1::   \
                                                                             field_type::value_type \
                                                                             const & arg2) {       \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;                     \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Type2(arg2))));                                    \
          };                                                                                       \
                                                                                                   \
         /* Scalar X SubExpr */                                                                    \
         template<typename SubExpr2>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            NeboScalar<Initial, typename SubExpr2::field_type>,    \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr2::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr2::field_type>,                        \
                                typename SubExpr2::field_type> EXTERNAL_NAME(typename SubExpr2::   \
                                                                             field_type::value_type \
                                                                             const & arg1,         \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr2::field_type typedef FieldType;                                      \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;                     \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Type1(arg1)),                                      \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };

#     define BUILD_UNARY_FUNCTION(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                       \
         template<typename CurrentMode, typename Operand, typename FieldType>                      \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand, typename FieldType>                                            \
          struct OBJECT_NAME<Initial, Operand, FieldType> {                                        \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Initial, Operand, FieldType> typedef This;                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             template<typename IteratorType>                                                       \
              struct Iterator {                                                                    \
                                                                                                   \
                OBJECT_NAME<ResizePrep<IteratorType, This>,                                        \
                            typename Operand::template Iterator<IteratorType>::ResizePrepType,     \
                            FieldType> typedef ResizePrepType;                                     \
                                                                                                   \
                OBJECT_NAME<SeqWalk<IteratorType, This>,                                           \
                            typename Operand::template Iterator<IteratorType>::SeqWalkType,        \
                            FieldType> typedef SeqWalkType;                                        \
             };                                                                                    \
             OBJECT_NAME(Operand const & op)                                                       \
             : operand_(op)                                                                        \
             {};                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::SeqWalkType init(void) const {               \
                 return typename Iterator<IteratorType>::SeqWalkType(*this);                       \
              };                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {     \
                 return typename Iterator<IteratorType>::ResizePrepType(*this);                    \
              };                                                                                   \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType, typename SourceType, typename Operand, typename FieldType> \
          struct OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {           \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;   \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType>      \
             typedef ResizeType;                                                                   \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand_(source.operand())                                                          \
             {};                                                                                   \
             inline ResizeType resize(MemoryWindow const & newSize) const {                        \
                return ResizeType(newSize, *this);                                                 \
             };                                                                                    \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType, typename SourceType, typename Operand, typename FieldType> \
          struct OBJECT_NAME<Resize<IteratorType, SourceType>, Operand, FieldType> {               \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;       \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType>    \
             typedef SeqWalkType;                                                                  \
             OBJECT_NAME(MemoryWindow const & size, SourceType const & source)                     \
             : operand_(size, source.operand())                                                    \
             {};                                                                                   \
             inline SeqWalkType init(void) const { return SeqWalkType(*this); };                   \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType, typename SourceType, typename Operand, typename FieldType> \
          struct OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {              \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;      \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand_(source.operand())                                                          \
             {};                                                                                   \
             inline void next(void) { operand_.next(); };                                          \
             inline bool at_end(void) const { return (operand_.at_end()); };                       \
             inline bool has_length(void) const { return (operand_.has_length()); };               \
             inline EvalReturnType eval(void) const { return INTERNAL_NAME(operand_.eval()); };    \
                                                                                                   \
            private:                                                                               \
             Operand operand_;                                                                     \
         };                                                                                        \
                                                                                                   \
         /* SubExpr */                                                                             \
         template<typename SubExpr>                                                                \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr,                          \
                                                                 typename SubExpr::field_type>::   \
                                            StandardType,                                          \
                                            typename SubExpr::field_type>,                         \
                                typename SubExpr::field_type> EXTERNAL_NAME(SubExpr const & arg) { \
                                                                                                   \
             typename SubExpr::field_type typedef FieldType;                                       \
                                                                                                   \
             typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type; \
                                                                                                   \
             OBJECT_NAME<Initial, Type, FieldType> typedef ReturnType;                             \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg)))); \
          };

      struct NeboNil { NeboNil() {}; };

      template<typename CurrentMode, typename Test, typename Expr, typename FieldType>
       struct NeboClause;

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Initial, Test, Expr, FieldType> {

         public:
          NeboClause<Initial, Test, Expr, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboClause<ResizePrep<IteratorType, This>,
                        typename Test::template Iterator<IteratorType>::ResizePrepType,
                        typename Expr::template Iterator<IteratorType>::ResizePrepType,
                        FieldType> typedef ResizePrepType;

             NeboClause<SeqWalk<IteratorType, This>,
                        typename Test::template Iterator<IteratorType>::SeqWalkType,
                        typename Expr::template Iterator<IteratorType>::SeqWalkType,
                        FieldType> typedef SeqWalkType;
          };
          NeboClause(Test const & t, Expr const & e)
          : test_(t), expr_(e)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Test const & test(void) const { return test_; };
          inline Expr const & expr(void) const { return expr_; };

         private:
          Test const test_;
          Expr const expr_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Test,
               typename Expr,
               typename FieldType>
       struct NeboClause<ResizePrep<IteratorType, SourceType>, Test, Expr, FieldType> {

         public:
          NeboClause<ResizePrep<IteratorType, SourceType>, Test, Expr, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboClause<Resize<IteratorType, This>,
                     typename Test::ResizeType,
                     typename Expr::ResizeType,
                     FieldType> typedef ResizeType;
          NeboClause(SourceType const & source)
          : test_(source.test()), expr_(source.expr())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Test const & test(void) const { return test_; };
          inline Expr const & expr(void) const { return expr_; };

         private:
          Test const test_;
          Expr const expr_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Test,
               typename Expr,
               typename FieldType>
       struct NeboClause<Resize<IteratorType, SourceType>, Test, Expr, FieldType> {

         public:
          NeboClause<Resize<IteratorType, SourceType>, Test, Expr, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboClause<SeqWalk<IteratorType, This>,
                     typename Test::SeqWalkType,
                     typename Expr::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          NeboClause(MemoryWindow const & size, SourceType const & source)
          : test_(size, source.test()), expr_(size, source.expr())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Test const & test(void) const { return test_; };
          inline Expr const & expr(void) const { return expr_; };

         private:
          Test const test_;
          Expr const expr_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Test,
               typename Expr,
               typename FieldType>
       struct NeboClause<SeqWalk<IteratorType, SourceType>, Test, Expr, FieldType> {

         public:
          NeboClause<SeqWalk<IteratorType, SourceType>, Test, Expr, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboClause(SourceType const & source)
          : test_(source.test()), expr_(source.expr())
          {};
          inline void next(void) { test_.next(); expr_.next(); };
          inline bool at_end(void) const { return (test_.at_end() || expr_.at_end()); };
          inline bool has_length(void) const { return (test_.has_length() || expr_.has_length()); };
          inline bool const check(void) const { return test_.eval(); };
          inline AtomicType const eval(void) const { return expr_.eval(); };

         private:
          Test test_;
          Expr expr_;
      };

      template<typename CurrentMode, typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Initial, ClauseType, Otherwise, FieldType> {

         public:
          NeboCond<Initial, ClauseType, Otherwise, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboCond<ResizePrep<IteratorType, This>,
                      typename ClauseType::template Iterator<IteratorType>::ResizePrepType,
                      typename Otherwise::template Iterator<IteratorType>::ResizePrepType,
                      FieldType> typedef ResizePrepType;

             NeboCond<SeqWalk<IteratorType, This>,
                      typename ClauseType::template Iterator<IteratorType>::SeqWalkType,
                      typename Otherwise::template Iterator<IteratorType>::SeqWalkType,
                      FieldType> typedef SeqWalkType;
          };
          NeboCond(ClauseType const & c, Otherwise const & e)
          : clause_(c), otherwise_(e)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline ClauseType const & clause(void) const { return clause_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          ClauseType const clause_;
          Otherwise const otherwise_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename ClauseType,
               typename Otherwise,
               typename FieldType>
       struct NeboCond<ResizePrep<IteratorType, SourceType>, ClauseType, Otherwise, FieldType> {

         public:
          NeboCond<ResizePrep<IteratorType, SourceType>, ClauseType, Otherwise, FieldType> typedef
          This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboCond<Resize<IteratorType, This>,
                   typename ClauseType::ResizeType,
                   typename Otherwise::ResizeType,
                   FieldType> typedef ResizeType;
          NeboCond(SourceType const & source)
          : clause_(source.clause()), otherwise_(source.otherwise())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline ClauseType const & clause(void) const { return clause_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          ClauseType const clause_;
          Otherwise const otherwise_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename ClauseType,
               typename Otherwise,
               typename FieldType>
       struct NeboCond<Resize<IteratorType, SourceType>, ClauseType, Otherwise, FieldType> {

         public:
          NeboCond<Resize<IteratorType, SourceType>, ClauseType, Otherwise, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboCond<SeqWalk<IteratorType, This>,
                   typename ClauseType::SeqWalkType,
                   typename Otherwise::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          NeboCond(MemoryWindow const & size, SourceType const & source)
          : clause_(size, source.clause()), otherwise_(size, source.otherwise())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline ClauseType const & clause(void) const { return clause_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          ClauseType const clause_;
          Otherwise const otherwise_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename ClauseType,
               typename Otherwise,
               typename FieldType>
       struct NeboCond<SeqWalk<IteratorType, SourceType>, ClauseType, Otherwise, FieldType> {

         public:
          NeboCond<SeqWalk<IteratorType, SourceType>, ClauseType, Otherwise, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboCond(SourceType const & source)
          : clause_(source.clause()), otherwise_(source.otherwise())
          {};
          inline void next(void) { clause_.next(); otherwise_.next(); };
          inline bool at_end(void) const { return (clause_.at_end() || otherwise_.at_end()); };
          inline bool has_length(void) const {
             return (clause_.has_length() || otherwise_.has_length());
          };
          inline AtomicType const eval(void) const {
             return clause_.check() ? clause_.eval() : otherwise_.eval();
          };

         private:
          ClauseType clause_;
          Otherwise otherwise_;
      };

      struct NeboSimpleClause {

         public:
          NeboSimpleClause(bool b, double d)
          : b_(b), d_(d)
          {};
          inline bool check(void) const { return b_; };
          inline double eval(void) const { return d_; };
          template<typename FieldType>
           struct Convert {

             NeboBoolean<Initial, FieldType> typedef Boolean;

             NeboScalar<Initial, FieldType> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef Converted;

             static inline Converted convert(bool b, double d) {
                return Converted(Boolean(b), Scalar(d));
             };
          };

         private:
          bool const b_;
          double const d_;
      };

      struct NeboSimpleFinalClause {

         public:
          NeboSimpleFinalClause(double d)
          : d_(d)
          {};
          inline double eval(void) const { return d_; };

         private:
          double const d_;
      };

      template<typename Otherwise>
       struct NeboSimpleCond {

         public:
          NeboSimpleCond(NeboSimpleClause c, Otherwise otherwise)
          : c_(c), otherwise_(otherwise)
          {};
          inline double eval(void) const { return c_.check() ? c_.eval() : otherwise_.eval(); };
          template<typename FieldType>
           struct Convert {

             NeboSimpleClause::template Convert<FieldType> typedef ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             typename Otherwise::template Convert<FieldType> typedef ConvertingList;

             typename ConvertingList::Converted typedef ConvertedList;

             NeboCond<Initial, ConvertedClause, ConvertedList, FieldType> typedef Converted;

             static inline Converted convert(NeboSimpleClause c, Otherwise o) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()), o.template convert<FieldType>());
             };
          };
          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {

              Convert<FieldType> typedef Convert;

              return Convert::convert(clause(), otherwise());
           };
          inline NeboSimpleClause const & clause(void) const { return c_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          NeboSimpleClause const c_;
          Otherwise const otherwise_;
      };

      template<>
       struct NeboSimpleCond<NeboNil> {

         public:
          NeboSimpleCond(NeboSimpleClause c, NeboNil nil)
          : c_(c)
          {};
          template<typename FieldType>
           struct Convert {

             NeboSimpleClause::template Convert<FieldType> typedef ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             NeboNil typedef ConvertedList;

             NeboCond<Initial, ConvertedClause, ConvertedList, FieldType> typedef Converted;

             static inline Converted convert(NeboSimpleClause c) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()), NeboNil());
             };
          };
          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {

              Convert<FieldType> typedef Convert;

              return Convert::convert(clause());
           };
          inline NeboSimpleClause const & clause(void) const { return c_; };
          inline NeboNil otherwise(void) const { return NeboNil(); };

         private:
          NeboSimpleClause const c_;
      };

      template<typename List>
       struct CondBuilder;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct CondBuilder<NeboCond<Initial, ClauseType, Otherwise, FieldType> > {

         public:
          NeboCond<Initial, ClauseType, Otherwise, FieldType>  typedef List;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseListRecursive;
          template<typename PreceedingResult>
           struct ReverseListRecursive<NeboNil, PreceedingResult> {

             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil nil, PreceedingResult r) { return r; };
          };
          template<typename Next, typename Field, typename Following, typename PreceedingResult>
           struct ReverseListRecursive<NeboCond<Initial, Next, Following, Field>, PreceedingResult> {

             NeboCond<Initial, Next, Following, Field> typedef Remaining;

             NeboCond<Initial, Next, PreceedingResult, Field> typedef NewResult;

             ReverseListRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining l, PreceedingResult r) {
                return InternalCall::reverse(l.otherwise(), NewResult(l.clause(), r));
             };
          };
          List list_;

         public:
          CondBuilder(NeboCond<Initial, ClauseType, Otherwise, FieldType> l)
          : list_(l)
          {};
          template<typename Final>
           struct ReverseList;
          template<typename Final>
           struct ReverseList {

             ReverseListRecursive<List, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(List l, Final f) { return InternalCall::reverse(l, f); };
          };
          template<typename Final>
           inline typename ReverseList<Final>::Result reverse(Final f) {

              ReverseList<Final> typedef InternalCall;

              return InternalCall::reverse(list_, f);
           };
          inline NeboExpression<typename ReverseList<NeboScalar<Initial, FieldType> >::Result,
                                FieldType> operator ()(double d) {

             NeboScalar<Initial, FieldType> typedef Scalar;

             ReverseList<Scalar> typedef Reverser;

             typename Reverser::Result typedef Reversed;

             NeboExpression<Reversed, FieldType> typedef Result;

             return Result(reverse(Scalar(d)));
          };
          template<typename Expr>
           inline NeboExpression<typename ReverseList<typename Standardize<Expr, FieldType>::
                                                      StandardType>::Result,
                                 FieldType> operator ()(Expr e) {

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef FinalType;

              ReverseList<FinalType> typedef Reverser;

              typename Reverser::Result typedef Reversed;

              NeboExpression<Reversed, FieldType> typedef Result;

              return Result(reverse(Standardize::standardType(e)));
           };
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboBoolean<Initial, FieldType>,
                                                 NeboScalar<Initial, FieldType>,
                                                 FieldType>,
                                      List,
                                      FieldType> > operator ()(bool b, double d) {

             NeboBoolean<Initial, FieldType> typedef Boolean;

             NeboScalar<Initial, FieldType> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef NewClause;

             NeboCond<Initial, NewClause, List, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NewClause(Boolean(b), Scalar(d)), list_));
          };
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboBoolean<Initial, FieldType>,
                                                  typename Standardize<Expr, FieldType>::
                                                  StandardType,
                                                  FieldType>,
                                       List,
                                       FieldType> > operator ()(bool b, Expr e) {

              NeboBoolean<Initial, FieldType> typedef Boolean;

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, Boolean, StandardType, FieldType> typedef Clause;

              NeboCond<Initial, Clause, List, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Standardize::standardType(e)), list_));
           };
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial, FieldType>,
                                                  FieldType>,
                                       List,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType> nb,
                                                                double d) {

              NeboScalar<Initial, FieldType> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef NewClause;

              NeboCond<Initial, NewClause, List, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(NewClause(nb.expr(), Scalar(d)), list_));
           };
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  typename Standardize<Expr, FieldType>::
                                                  StandardType,
                                                  FieldType>,
                                       List,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      typename Expr::
                                                                                      field_type> nb,
                                                                Expr e) {

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, BoolExpr, StandardType, FieldType> typedef Clause;

              NeboCond<Initial, Clause, List, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Standardize::standardType(e)), list_));
           };
      };

      template<typename Otherwise>
       struct CondBuilder<NeboSimpleCond<Otherwise> > {

         public:
          NeboSimpleCond<Otherwise>  typedef List;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseListRecursive;
          template<typename PreceedingResult>
           struct ReverseListRecursive<NeboNil, PreceedingResult> {

             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil nil, PreceedingResult r) { return r; };
          };
          template<typename Following, typename PreceedingResult>
           struct ReverseListRecursive<NeboSimpleCond<Following>, PreceedingResult> {

             NeboSimpleCond<Following> typedef Remaining;

             NeboSimpleCond<PreceedingResult> typedef NewResult;

             ReverseListRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining l, PreceedingResult r) {
                return InternalCall::reverse(l.otherwise(), NewResult(l.clause(), r));
             };
          };
          List list_;

         public:
          CondBuilder(NeboSimpleCond<Otherwise> l)
          : list_(l)
          {};
          template<typename Final>
           struct ReverseList;
          template<typename Final>
           struct ReverseList {

             ReverseListRecursive<List, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(List l, Final f) { return InternalCall::reverse(l, f); };
          };
          template<typename Final>
           inline typename ReverseList<Final>::Result reverse(Final f) {

              ReverseList<Final> typedef InternalCall;

              return InternalCall::reverse(list_, f);
           };
          inline double operator ()(double d) { return reverse(NeboSimpleFinalClause(d)).eval(); };
          template<typename Expr>
           inline NeboExpression<typename CondBuilder<typename List::template Convert<typename Expr::
                                                                                      field_type>::
                                                      Converted>::template ReverseList<typename
                                                                                       Standardize<Expr,
                                                                                                   typename
                                                                                                   Expr::
                                                                                                   field_type>::
                                                                                       StandardType>::
                                 Result,
                                 typename Expr::field_type> operator ()(Expr e) {

              typename Expr::field_type typedef FieldType;

              typename List::template Convert<typename Expr::field_type>::Converted typedef
              Converted;

              CondBuilder<Converted> typedef NewCondBuilder;

              return NewCondBuilder(list_.template convert<FieldType>())(e);
           };
          inline CondBuilder<NeboSimpleCond<List> > operator ()(bool b, double d) {

             NeboSimpleCond<List> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NeboSimpleClause(b, d), list_));
          };
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboBoolean<Initial, typename Expr::field_type>,
                                                  typename Standardize<Expr,
                                                                       typename Expr::field_type>::
                                                  StandardType,
                                                  typename Expr::field_type>,
                                       typename List::template Convert<typename Expr::field_type>::
                                       Converted,
                                       typename Expr::field_type> > operator ()(bool b, Expr e) {

              typename Expr::field_type typedef FieldType;

              NeboBoolean<Initial, FieldType> typedef Boolean;

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, Boolean, StandardType, FieldType> typedef Clause;

              typename List::template Convert<typename Expr::field_type>::Converted typedef Previous;

              NeboCond<Initial, Clause, Previous, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Standardize::standardType(e)),
                                     list_.template convert<FieldType>()));
           };
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial, FieldType>,
                                                  FieldType>,
                                       typename List::template Convert<FieldType>::Converted,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType> nb,
                                                                double d) {

              NeboScalar<Initial, FieldType> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              typename List::template Convert<FieldType>::Converted typedef Previous;

              NeboCond<Initial, Clause, Previous, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), list_.template convert<FieldType>()));
           };
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  typename Standardize<Expr,
                                                                       typename Expr::field_type>::
                                                  StandardType,
                                                  typename Expr::field_type>,
                                       typename List::template Convert<typename Expr::field_type>::
                                       Converted,
                                       typename Expr::field_type> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                                      typename
                                                                                                      Expr::
                                                                                                      field_type>
                                                                                nb,
                                                                                Expr e) {

              typename Expr::field_type typedef FieldType;

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, BoolExpr, StandardType, FieldType> typedef Clause;

              typename List::template Convert<typename Expr::field_type>::Converted typedef Previous;

              NeboCond<Initial, Clause, Previous, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Standardize::standardType(e)),
                                     list_.template convert<FieldType>()));
           };
      };

      template<>
       struct CondBuilder<NeboNil> {

         public:
          CondBuilder() {};
      };

      inline double cond(double d) { return d; };

      template<typename Expr>
       inline typename Standardize<Expr, typename Expr::field_type>::StandardTerm cond(Expr e) {

          typename Expr::field_type typedef FieldType;

          Standardize<Expr, FieldType> typedef Standardize;

          return Standardize::standardTerm(e);
       };

      inline CondBuilder<NeboSimpleCond<NeboNil> > cond(bool b, double d) {

         NeboSimpleCond<NeboNil> typedef Cond;

         CondBuilder<Cond> typedef ReturnType;

         return ReturnType(Cond(NeboSimpleClause(b, d), NeboNil()));
      };

      template<typename Expr>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboBoolean<Initial, typename Expr::field_type>,
                                              typename Standardize<Expr, typename Expr::field_type>::
                                              StandardType,
                                              typename Expr::field_type>,
                                   NeboNil,
                                   typename Expr::field_type> > cond(bool b, Expr e) {

          typename Expr::field_type typedef FieldType;

          NeboBoolean<Initial, FieldType> typedef Boolean;

          Standardize<Expr, FieldType> typedef Standardize;

          typename Standardize::StandardType typedef StandardType;

          NeboClause<Initial, Boolean, StandardType, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), Standardize::standardType(e)), NeboNil()));
       };

      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboScalar<Initial, FieldType>,
                                              FieldType>,
                                   NeboNil,
                                   FieldType> > cond(NeboBooleanExpression<BoolExpr, FieldType> nb,
                                                     double d) {

          NeboScalar<Initial, FieldType> typedef Scalar;

          NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), NeboNil()));
       };

      template<typename BoolExpr, typename Expr>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              typename Standardize<Expr, typename Expr::field_type>::
                                              StandardType,
                                              typename Expr::field_type>,
                                   NeboNil,
                                   typename Expr::field_type> > cond(NeboBooleanExpression<BoolExpr,
                                                                                           typename
                                                                                           Expr::
                                                                                           field_type>
                                                                     nb,
                                                                     Expr e) {

          typename Expr::field_type typedef FieldType;

          Standardize<Expr, FieldType> typedef Standardize;

          typename Standardize::StandardType typedef StandardType;

          NeboClause<Initial, BoolExpr, StandardType, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Standardize::standardType(e)), NeboNil()));
       };

#     define nebo_cond cond//;

      template<typename LhsType, typename RhsType>
       inline void field_expression_sequential_execute_internal(LhsType lhs, RhsType rhs) {
          while(!lhs.at_end()){ lhs.ref() = rhs.eval(); lhs.next(); rhs.next(); };
       };

      template<typename CallStyle, typename ExprType, typename FieldType>
       inline FieldType const & field_expression_sequential_execute(FieldType & initial_lhs,
                                                                    NeboExpression<ExprType,
                                                                                   FieldType> const
                                                                    & initial_rhs) {

          field_expression_sequential_execute_internal<typename NeboField<Initial, FieldType>::
                                                       template Iterator<CallStyle>::SeqWalkType,
                                                       typename ExprType::template Iterator<CallStyle>::
                                                       SeqWalkType>(NeboField<Initial, FieldType>(initial_lhs).template
                                                                                                               init<CallStyle>(),
                                                                    initial_rhs.expr().template init<CallStyle>());

          return initial_lhs;
       };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename CallStyle,
                  typename ResizeLhsType,
                  typename ResizeRhsType,
                  typename FieldType>
          inline void field_expression_thread_parallel_execute_internal(ResizeLhsType & lhs,
                                                                        ResizeRhsType const & rhs,
                                                                        typename FieldType::
                                                                        memory_window const & window,
                                                                        BI::interprocess_semaphore *
                                                                        semaphore) {

             field_expression_sequential_execute_internal<typename ResizeLhsType::ResizeType::
                                                          SeqWalkType,
                                                          typename ResizeRhsType::ResizeType::
                                                          SeqWalkType>(lhs.resize(window).init(),
                                                                       rhs.resize(window).init());

             semaphore->post();
          }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename CallStyle, typename ExprType, typename FieldType>
          inline FieldType const & field_expression_thread_parallel_execute(FieldType & initial_lhs,
                                                                            NeboExpression<ExprType,
                                                                                           FieldType>
                                                                            const & initial_rhs,
                                                                            int const
                                                                            number_of_partitions) {

             typename NeboField<Initial, FieldType>::template Iterator<CallStyle>::ResizePrepType
             typedef LhsType;

             typename ExprType::template Iterator<CallStyle>::ResizePrepType typedef RhsType;

             typename FieldType::memory_window typedef MemoryWindow;

             MemoryWindow window = IteratorStyle<CallStyle, FieldType>::memory_window(initial_lhs);

             int x = 1;
             int y = 1;
             int z = 1;

             if(number_of_partitions <= window.extent(2)){ z = number_of_partitions; }
             else if(number_of_partitions <= window.extent(1)){ y = number_of_partitions; }
             else if(number_of_partitions <= window.extent(0)){ x = number_of_partitions; };

             std::vector<typename FieldType::memory_window> vec_window = window.split(structured::
                                                                                      IntVec(x, y, z));

             BI::interprocess_semaphore semaphore(0);

             typename std::vector<typename FieldType::memory_window>::const_iterator window_iterator
             = vec_window.begin();

             typename std::vector<typename FieldType::memory_window>::const_iterator window_end =
             vec_window.end();

             for(; window_iterator != window_end; ++window_iterator){

                ThreadPoolFIFO::self().schedule(boost::bind(&
                                                            field_expression_thread_parallel_execute_internal<CallStyle,
                                                                                                              LhsType,
                                                                                                              RhsType,
                                                                                                              FieldType>,
                                                            NeboField<Initial, FieldType>(initial_lhs).template
                                                                                                       resize_prep<CallStyle>(),
                                                            initial_rhs.expr().template resize_prep<CallStyle>(),
                                                            *window_iterator,
                                                            &semaphore));
             };

             for(int ii = 0; ii < vec_window.size(); ii++){ semaphore.wait(); };

             return initial_lhs;
          }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename CallStyle, typename ExprType, typename FieldType>
       inline FieldType const & field_expression_general_execute(FieldType & initial_lhs,
                                                                 NeboExpression<ExprType, FieldType>
                                                                 const & initial_rhs) {

          return
#                ifdef FIELD_EXPRESSION_THREADS
                    (is_nebo_thread_parallel() ? field_expression_thread_parallel_execute<CallStyle,
                                                                                          ExprType,
                                                                                          FieldType>(initial_lhs,
                                                                                                     initial_rhs,
                                                                                                     get_nebo_soft_thread_count())
                     : field_expression_sequential_execute<CallStyle, ExprType, FieldType>(initial_lhs,
                                                                                           initial_rhs))
#                else
                    field_expression_sequential_execute<CallStyle, ExprType, FieldType>(initial_lhs,
                                                                                        initial_rhs)
#                endif
                 /* FIELD_EXPRESSION_THREADS */
                 ;;
       };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef ExprType;

          return (lhs <<= NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef ExprType;

          return (lhs <<= NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename ExprType, typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             NeboExpression<ExprType, FieldType> const & rhs) {
          return field_expression_general_execute<UseWholeIterator, ExprType, FieldType>(lhs, rhs);
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef ExprType;

          return interior_assign(lhs, NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef ExprType;

          return interior_assign(lhs, NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename ExprType, typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                NeboExpression<ExprType, FieldType> const & rhs) {
          return field_expression_general_execute<UseInteriorIterator, ExprType, FieldType>(lhs, rhs);
       };
   } /* SpatialOps */;

#endif
/* SpatialOps_FieldExpressions_h */
