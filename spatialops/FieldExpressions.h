/* This file was generated by fulmar version 0.7.6.1. */
/*
 * Copyright (c) 2011 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef SpatialOps_FieldExpressions_h
#  define SpatialOps_FieldExpressions_h

#  include <spatialops/SpatialOpsConfigure.h>
#  include <spatialops/structured/IndexTriplet.h>
#  include <spatialops/structured/GhostData.h>
#  include <spatialops/structured/SpatialField.h>
#  include <cmath>
#  include <math.h>

   /*#include <iostream> */

#  ifdef FIELD_EXPRESSION_THREADS
#     include <spatialops/SpatialOpsTools.h>
#     include <vector>
#     include <boost/bind.hpp>
#     include <spatialops/ThreadPool.h>
#     include <spatialops/structured/IntVec.h>
#     include <boost/interprocess/sync/interprocess_semaphore.hpp>
      namespace BI = boost::interprocess;
#  endif
   /* FIELD_EXPRESSION_THREADS */

#  ifdef __CUDACC__
#     include <spatialops/structured/MemoryTypes.h>
#  endif
   /* __CUDACC__ */

   namespace SpatialOps {

      /* Meta-programming compiler flags */
      struct All;
      struct InteriorOnly;

      template<typename IteratorType, typename ExprType, typename FieldType>
       struct CalculateValidGhost;

      /* All */
      template<typename ExprType, typename FieldType>
       struct CalculateValidGhost<All, ExprType, FieldType> {

         typename structured::Minimum<typename ExprType::PossibleValidGhost,
                                      typename structured::GhostFromField<FieldType>::result>::
         result typedef Result;
      };

      /* InteriorOnly */
      template<typename ExprType, typename FieldType>
       struct CalculateValidGhost<InteriorOnly, ExprType, FieldType> {
         typename structured::MinimumGhostFromField<FieldType>::result typedef Result;
      };

      template<typename Type1, typename Type2>
       struct NeboFieldCheck;

      template<typename Type>
       struct NeboFieldCheck<Type, Type> { Type typedef Result; };

      inline structured::IntVec nebo_find_partition(structured::IntVec const & extent,
                                                    int const thread_count) {

         int x = 1;
         int y = 1;
         int z = 1;

         if(thread_count <= extent[2]) { z = thread_count; }
         else if(thread_count <= extent[1]) { y = thread_count; }
         else if(thread_count <= extent[0]) { x = thread_count; };

         return structured::IntVec(x, y, z);
      };

      inline int nebo_partition_count(structured::IntVec const & split) {
         return split[0] * split[1] * split[2];
      };

      inline structured::IntVec nebo_next_partition(structured::IntVec const & current,
                                                    structured::IntVec const & split) {

         structured::IntVec result;

         if(current[2] < split[2] - 1) {
            result = structured::IntVec(current[0], current[1], 1 + current[2]);
         }
         else if(current[1] < split[1] - 1) {
            result = structured::IntVec(current[0], 1 + current[1], 0);
         }
         else { result = structured::IntVec(1 + current[0], 0, 0); };

         return result;
      };

      template<typename Operand, typename FieldType>
       struct NeboExpression {

         public:
          FieldType typedef field_type;
          Operand typedef Expression;
          NeboExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      template<typename Operand, typename FieldType>
       struct NeboBooleanExpression {

         public:
          FieldType typedef field_type;
          Operand typedef Expression;
          NeboBooleanExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      /* Modes: */
      struct Initial;
#     ifdef FIELD_EXPRESSION_THREADS
         struct Resize
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      struct SeqWalk;
#     ifdef __CUDACC__
         struct GPUWalk
#     endif
      /* __CUDACC__ */;
      struct Reduction;

      template<typename CurrentMode, typename FieldType>
       struct NeboScalar;

      template<typename FieldType>
       struct NeboScalar<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar<SeqWalk, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboScalar<Resize, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboScalar<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboScalar<Reduction, FieldType> typedef ReductionType;
          structured::InfiniteGhostData typedef PossibleValidGhost;
          NeboScalar(AtomicType const v)
          : value_(v)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return true; }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const { return SeqWalkType(value_); };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const { return ResizeType(value_); }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const { return GPUWalkType(value_); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const { return ReductionType(value_); };

         private:
          AtomicType const value_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename FieldType>
          struct NeboScalar<Resize, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename FieldType::value_type typedef AtomicType;
             NeboScalar<SeqWalk, FieldType> typedef SeqWalkType;
             NeboScalar(AtomicType const value)
             : value_(value)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(value_);
              };

            private:
             AtomicType const value_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename FieldType>
       struct NeboScalar<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(AtomicType const value)
          : value_(value)
          {};
          inline void next(void) {};
          inline AtomicType eval(void) const { return value_; };

         private:
          AtomicType const value_;
      };

#     ifdef __CUDACC__
         template<typename FieldType>
          struct NeboScalar<GPUWalk, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboScalar(AtomicType const value)
             : value_(value)
             {};
             __device__ inline void start(int x, int y) {};
             __device__ inline void next(void) {};
             __device__ inline AtomicType eval(void) { return value_; };

            private:
             AtomicType const value_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename FieldType>
       struct NeboScalar<Reduction, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(AtomicType const value)
          : value_(value)
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline AtomicType eval(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboBoolean;

      template<typename FieldType>
       struct NeboBoolean<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboBoolean<SeqWalk, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboBoolean<Resize, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboBoolean<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboBoolean<Reduction, FieldType> typedef ReductionType;
          structured::InfiniteGhostData typedef PossibleValidGhost;
          NeboBoolean(bool const v)
          : value_(v)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return true; }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const { return SeqWalkType(value_); };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const { return ResizeType(value_); }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const { return GPUWalkType(value_); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const { return ReductionType(value_); };

         private:
          bool const value_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename FieldType>
          struct NeboBoolean<Resize, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NeboBoolean<SeqWalk, FieldType> typedef SeqWalkType;
             NeboBoolean(bool const value)
             : value_(value)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(value_);
              };

            private:
             bool const value_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename FieldType>
       struct NeboBoolean<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboBoolean(bool const value)
          : value_(value)
          {};
          inline void next(void) {};
          inline bool eval(void) const { return value_; };

         private:
          bool const value_;
      };

#     ifdef __CUDACC__
         template<typename FieldType>
          struct NeboBoolean<GPUWalk, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboBoolean(bool const value)
             : value_(value)
             {};
             __device__ inline void start(int x, int y) {};
             __device__ inline void next(void) {};
             __device__ inline AtomicType eval(void) { return value_; };

            private:
             bool const value_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename FieldType>
       struct NeboBoolean<Reduction, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboBoolean(bool const value)
          : value_(value)
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline bool eval(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboConstField;

      template<typename FieldType>
       struct NeboConstField<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboConstField<SeqWalk, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboConstField<Resize, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboConstField<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboConstField<Reduction, FieldType> typedef ReductionType;
          typename structured::GhostFromField<FieldType>::result typedef PossibleValidGhost;
          NeboConstField(FieldType const & f)
          : field_(f)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return field_.memory_device_type() == EXTERNAL_CUDA_GPU;
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(field_.template resize_ghost_and_shift<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(field_.template resize_ghost<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(field_.template resize_ghost_and_shift<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(field_.template resize_ghost_and_shift<ValidGhost, Shift>());
           };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename FieldType>
          struct NeboConstField<Resize, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NeboConstField<SeqWalk, FieldType> typedef SeqWalkType;
             NeboConstField(FieldType const & f)
             : field_(f)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(FieldType(field_.window_with_ghost().refine(split, location),
                                              field_.field_values(),
                                              structured::ExternalStorage).template shift<Shift>());
              };

            private:
             FieldType const field_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename FieldType>
       struct NeboConstField<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboConstField(FieldType const & f)
          : iter_(f.begin())
          {};
          inline void next(void) { iter_++; };
          inline AtomicType eval(void) const { return *iter_; };

         private:
          typename FieldType::const_iterator iter_;
      };

#     ifdef __CUDACC__
         template<typename FieldType>
          struct NeboConstField<GPUWalk, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboConstField(FieldType const & f)
             : current_(f.field_values(EXTERNAL_CUDA_GPU, f.device_index()) + f.window_with_ghost().offset(0)
               + f.window_with_ghost().glob_dim(0) * (f.window_with_ghost().offset(1) + (f.window_with_ghost().glob_dim(1)
                                                                                         * f.window_with_ghost().offset(2)))),
               xLength_(f.window_with_ghost().glob_dim(0)),
               step_(xLength_ * f.window_with_ghost().glob_dim(1))
             {};
             __device__ inline void start(int x, int y) { current_ += x + y * xLength_; };
             __device__ inline void next(void) { current_ += step_; };
             __device__ inline AtomicType eval(void) { return *current_; };

            private:
             AtomicType const * current_;
             int const xLength_;
             int const step_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename FieldType>
       struct NeboConstField<Reduction, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboConstField(FieldType const & f)
          : iter_(f.begin()), end_(f.end())
          {};
          inline void next(void) { iter_++; };
          inline bool at_end(void) const { return iter_ == end_; };
          inline bool has_length(void) const { return true; };
          inline AtomicType eval(void) const { return *iter_; };

         private:
          typename FieldType::const_iterator iter_;
          typename FieldType::const_iterator const end_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboField;

      template<typename FieldType>
       struct NeboField<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboField<SeqWalk, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboField<Resize, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboField<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboField<Reduction, FieldType> typedef ReductionType;
          typename structured::GhostFromField<FieldType>::result typedef PossibleValidGhost;
          NeboField(FieldType f)
          : field_(f)
          {};
          structured::IndexTriplet<0, 0, 0> typedef Shift;
          template<typename Iterator, typename RhsType>
           inline void assign(RhsType rhs) {

#             ifdef __CUDACC__
                 if(gpu_ready() && rhs.gpu_ready()) { gpu_assign<Iterator, RhsType>(rhs); }
                 else { cpu_assign<Iterator, RhsType>(rhs); }
#             else
                 cpu_assign<Iterator, RhsType>(rhs)
#             endif
              /* __CUDACC__ */;
           };

         private:
          template<typename Iterator, typename RhsType>
           inline void sequential_assign(RhsType rhs) {

              typename CalculateValidGhost<Iterator, RhsType, FieldType>::Result typedef ValidGhost;

              init<ValidGhost, Shift>().assign(rhs.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename Iterator, typename RhsType>
              inline void thread_parallel_assign(RhsType rhs) {

                 BI::interprocess_semaphore semaphore(0);

                 const int thread_count = get_soft_thread_count();

                 typename CalculateValidGhost<Iterator, RhsType, FieldType>::Result typedef
                 ValidGhost;

                 typename RhsType::ResizeType typedef RhsResizeType;

                 const structured::IntVec split = nebo_find_partition(field_.template resize_ghost<ValidGhost>().window_with_ghost().extent(),
                                                                      thread_count);

                 const int max = nebo_partition_count(split);

                 ResizeType new_lhs = resize<ValidGhost>();

                 RhsResizeType new_rhs = rhs.template resize<ValidGhost>();

                 structured::IntVec location = structured::IntVec(0, 0, 0);

                 for(int count = 0; count < max; count++) {

                    ThreadPoolFIFO::self().schedule(boost::bind(&ResizeType::template assign<RhsResizeType>,
                                                                new_lhs,
                                                                new_rhs,
                                                                split,
                                                                location,
                                                                &semaphore));

                    location = nebo_next_partition(location, split);
                 };

                 for(int ii = 0; ii < max; ii++) { semaphore.wait(); };
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
          template<typename Iterator, typename RhsType>
           inline void cpu_assign(RhsType rhs) {

#             ifdef FIELD_EXPRESSION_THREADS
                 if(is_thread_parallel()) { thread_parallel_assign<Iterator, RhsType>(rhs); }
                 else { sequential_assign<Iterator, RhsType>(rhs); }
#             else
                 sequential_assign<Iterator, RhsType>(rhs)
#             endif
              /* FIELD_EXPRESSION_THREADS */;
           };
#         ifdef __CUDACC__
             template<typename Iterator, typename RhsType>
              inline void gpu_assign(RhsType rhs) {

                 typename CalculateValidGhost<Iterator, RhsType, FieldType>::Result typedef
                 ValidGhost;

                 typename RhsType::GPUWalkType typedef RhsGPUWalkType;

                 int extent0 = field_.window_with_ghost().extent(0);

                 int extent1 = field_.window_with_ghost().extent(1);

                 int blockDim = 16;

                 int gDimX = extent0 / blockDim + ((extent0 % blockDim) > 0 ? 1 : 0);

                 int gDimY = extent1 / blockDim + ((extent1 % blockDim) > 0 ? 1 : 0);

                 dim3 dimBlock(blockDim, blockDim);

                 dim3 dimGrid(gDimX, gDimY);

                 gpu_init<ValidGhost, Shift>().gpu_assign_kernel<GPUWalkType, RhsGPUWalkType><<<dimGrid,
                                                                                                dimBlock>>>(rhs.template
                                                                                                                gpu_init<ValidGhost,
                                                                                                                         Shift>())();
              }
#         endif
          /* __CUDACC__ */;
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return field_.memory_device_type() == EXTERNAL_CUDA_GPU;
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) {

              return SeqWalkType(field_.template resize_ghost_and_shift_and_maintain_interior<ValidGhost,
                                                                                              Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) {
                 return ResizeType(field_.template resize_ghost_and_maintain_interior<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) {

                 return GPUWalkType(field_.template resize_ghost_and_shift_and_maintain_interior<ValidGhost,
                                                                                                 Shift>());
              }
#         endif
          /* __CUDACC__ */;
          FieldType field_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename FieldType>
          struct NeboField<Resize, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NeboField<SeqWalk, FieldType> typedef SeqWalkType;
             NeboField(FieldType f)
             : field_(f)
             {};
             structured::IndexTriplet<0, 0, 0> typedef Shift;
#            ifdef FIELD_EXPRESSION_THREADS
                template<typename RhsType>
                 inline void assign(RhsType const & rhs,
                                    structured::IntVec const & split,
                                    structured::IntVec const & location,
                                    BI::interprocess_semaphore * semaphore) {

                    init<Shift>(split, location).assign(rhs.template init<Shift>(split, location));

                    semaphore->post();
                 }
#            endif
             /* FIELD_EXPRESSION_THREADS */;

            private:
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) {

                 return SeqWalkType(FieldType(field_.window_with_ghost().refine(split, location),
                                              field_.field_values(),
                                              structured::ExternalStorage).template
                                                                           shift_and_maintain_interior<Shift>());
              };
             FieldType field_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename FieldType>
       struct NeboField<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboField(FieldType f)
          : iter_(f.begin()), end_(f.end())
          {};
          template<typename RhsType>
           inline void assign(RhsType rhs) {
              while(!at_end()) { ref() = rhs.eval(); next(); rhs.next(); };
           };

         private:
          inline void next(void) { iter_++; };
          inline bool at_end(void) const { return iter_ == end_; };
          inline bool has_length(void) const { return true; };
          inline AtomicType & ref(void) { return *iter_; };
          typename FieldType::iterator iter_;
          typename FieldType::iterator const end_;
      };

#     ifdef __CUDACC__
         template<typename FieldType>
          struct NeboField<GPUWalk, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboField(FieldType f)
             : current_(f.field_values(EXTERNAL_CUDA_GPU, f.device_index()) + f.window_with_ghost().offset(0)
               + f.window_with_ghost().glob_dim(0) * (f.window_with_ghost().offset(1) + (f.window_with_ghost().glob_dim(1)
                                                                                         * f.window_with_ghost().offset(2)))),
               location_(0),
               valid_(false),
               xLength_(f.window_with_ghost().glob_dim(0)),
               xExtent_(f.window_with_ghost().extent(0)),
               yExtent_(f.window_with_ghost().extent(1)),
               zExtent_(f.window_with_ghost().extent(2)),
               step_(xLength_ * f.window_with_ghost().glob_dim(1))
             {};
             template<typename RhsType>
              __global__ inline void gpu_assign_kernel(RhsType rhs) {

                 const int ii = blockIdx.x * blockDim.x + threadIdx.x;

                 const int jj = blockIdx.y * blockDim.y + threadIdx.y;

                 start(ii, jj);

                 rhs.start(ii, jj);

                 if(valid()) { while(!at_end()) { ref() = rhs.eval(); next(); rhs.next(); }; };
              };

            private:
             __device__ inline bool valid(void) { return valid_; };
             __device__ inline void start(int x, int y) {

                valid_ = (x < xExtent_ && x >= 0 && y < yExtent_ && y >= 0);

                if(valid()) { location_ = 0; current_ += x + y * xLength_; };
             };
             __device__ inline void next(void) { current_ += step_; location_++; };
             __device__ inline bool at_end(void) { return location_ >= zExtent_; };
             __device__ inline AtomicType & ref(void) { return *current_; };
             AtomicType * current_;
             int location_;
             int valid_;
             int const xLength_;
             int const xExtent_;
             int const yExtent_;
             int const zExtent_;
             int const step_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct SumOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          SumOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             SumOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             SumOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          SumOp<Reduction,
                typename Operand1::ReductionType,
                typename Operand2::ReductionType,
                FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct SumOp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             SumOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;
             SumOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() + operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct SumOp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             SumOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() + operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() + operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial, FieldType>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   FieldType>,
                             FieldType> operator +(typename FieldType::value_type const & arg1,
                                                   FieldType const & arg2) {

          SumOp<Initial,
                NeboScalar<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>,
                             FieldType> operator +(typename FieldType::value_type const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          SumOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   NeboScalar<Initial, FieldType>,
                                   FieldType>,
                             FieldType> operator +(FieldType const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          SumOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboScalar<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   FieldType>,
                             FieldType> operator +(FieldType const & arg1, FieldType const & arg2) {

          SumOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   SubExpr2,
                                   FieldType>,
                             FieldType> operator +(FieldType const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          SumOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>,
                             FieldType> operator +(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          SumOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   FieldType>,
                             FieldType> operator +(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   FieldType const & arg2) {

          SumOp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial, SubExpr1, SubExpr2, FieldType>, FieldType> operator +(NeboExpression<SubExpr1,
                                                                                                                 FieldType>
                                                                                                  const
                                                                                                  &
                                                                                                  arg1,
                                                                                                  NeboExpression<SubExpr2,
                                                                                                                 FieldType>
                                                                                                  const
                                                                                                  &
                                                                                                  arg2) {

          SumOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          DiffOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             DiffOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             DiffOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          DiffOp<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DiffOp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             DiffOp<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;
             DiffOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() - operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DiffOp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             DiffOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() - operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() - operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> operator -(typename FieldType::value_type const & arg1,
                                                   FieldType const & arg2) {

          DiffOp<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>,
                             FieldType> operator -(typename FieldType::value_type const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          DiffOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg1, FieldType const & arg2) {

          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          DiffOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>,
                             FieldType> operator -(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          DiffOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> operator -(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   FieldType const & arg2) {

          DiffOp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial, SubExpr1, SubExpr2, FieldType>, FieldType> operator -(NeboExpression<SubExpr1,
                                                                                                                  FieldType>
                                                                                                   const
                                                                                                   &
                                                                                                   arg1,
                                                                                                   NeboExpression<SubExpr2,
                                                                                                                  FieldType>
                                                                                                   const
                                                                                                   &
                                                                                                   arg2) {

          DiffOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          ProdOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             ProdOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             ProdOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          ProdOp<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct ProdOp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             ProdOp<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;
             ProdOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() * operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct ProdOp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             ProdOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() * operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() * operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> operator *(typename FieldType::value_type const & arg1,
                                                   FieldType const & arg2) {

          ProdOp<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>,
                             FieldType> operator *(typename FieldType::value_type const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          ProdOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> operator *(FieldType const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> operator *(FieldType const & arg1, FieldType const & arg2) {

          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> operator *(FieldType const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          ProdOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>,
                             FieldType> operator *(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          ProdOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> operator *(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   FieldType const & arg2) {

          ProdOp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial, SubExpr1, SubExpr2, FieldType>, FieldType> operator *(NeboExpression<SubExpr1,
                                                                                                                  FieldType>
                                                                                                   const
                                                                                                   &
                                                                                                   arg1,
                                                                                                   NeboExpression<SubExpr2,
                                                                                                                  FieldType>
                                                                                                   const
                                                                                                   &
                                                                                                   arg2) {

          ProdOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DivOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          DivOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             DivOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             DivOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          DivOp<Reduction,
                typename Operand1::ReductionType,
                typename Operand2::ReductionType,
                FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DivOp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             DivOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;
             DivOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() / operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DivOp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             DivOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() / operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() / operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial, FieldType>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   FieldType>,
                             FieldType> operator /(typename FieldType::value_type const & arg1,
                                                   FieldType const & arg2) {

          DivOp<Initial,
                NeboScalar<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>,
                             FieldType> operator /(typename FieldType::value_type const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          DivOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   NeboScalar<Initial, FieldType>,
                                   FieldType>,
                             FieldType> operator /(FieldType const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          DivOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboScalar<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   FieldType>,
                             FieldType> operator /(FieldType const & arg1, FieldType const & arg2) {

          DivOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   SubExpr2,
                                   FieldType>,
                             FieldType> operator /(FieldType const & arg1,
                                                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          DivOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>,
                             FieldType> operator /(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   typename FieldType::value_type const & arg2) {

          DivOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename FieldType::
                                                                          field_type,
                                                                          FieldType>::Result>,
                                   FieldType>,
                             FieldType> operator /(NeboExpression<SubExpr1, FieldType> const & arg1,
                                                   FieldType const & arg2) {

          DivOp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial, SubExpr1, SubExpr2, FieldType>, FieldType> operator /(NeboExpression<SubExpr1,
                                                                                                                 FieldType>
                                                                                                  const
                                                                                                  &
                                                                                                  arg1,
                                                                                                  NeboExpression<SubExpr2,
                                                                                                                 FieldType>
                                                                                                  const
                                                                                                  &
                                                                                                  arg2) {

          DivOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SinFcn;

      template<typename Operand, typename FieldType>
       struct SinFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          SinFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             SinFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             SinFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          SinFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          SinFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct SinFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             SinFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             SinFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct SinFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SinFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::sin(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct SinFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             SinFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::sin(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct SinFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SinFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sin(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<SinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> sin(FieldType const & arg) {

          SinFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<SinFcn<Initial, SubExpr, FieldType>, FieldType> sin(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const & arg) {

          SinFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct CosFcn;

      template<typename Operand, typename FieldType>
       struct CosFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          CosFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             CosFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             CosFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          CosFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          CosFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct CosFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             CosFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             CosFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct CosFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          CosFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::cos(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct CosFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             CosFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::cos(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct CosFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          CosFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::cos(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<CosFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> cos(FieldType const & arg) {

          CosFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<CosFcn<Initial, SubExpr, FieldType>, FieldType> cos(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const & arg) {

          CosFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanFcn;

      template<typename Operand, typename FieldType>
       struct TanFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          TanFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             TanFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             TanFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          TanFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          TanFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct TanFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             TanFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             TanFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct TanFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::tan(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct TanFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             TanFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::tan(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct TanFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tan(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<TanFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> tan(FieldType const & arg) {

          TanFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<TanFcn<Initial, SubExpr, FieldType>, FieldType> tan(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const & arg) {

          TanFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct ExpFcn;

      template<typename Operand, typename FieldType>
       struct ExpFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          ExpFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             ExpFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             ExpFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          ExpFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          ExpFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct ExpFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             ExpFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             ExpFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct ExpFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ExpFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::exp(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct ExpFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             ExpFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::exp(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct ExpFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ExpFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::exp(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<ExpFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> exp(FieldType const & arg) {

          ExpFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<ExpFcn<Initial, SubExpr, FieldType>, FieldType> exp(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const & arg) {

          ExpFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanhFcn;

      template<typename Operand, typename FieldType>
       struct TanhFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          TanhFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             TanhFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             TanhFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          TanhFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          TanhFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct TanhFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             TanhFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             TanhFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct TanhFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanhFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::tanh(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct TanhFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             TanhFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::tanh(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct TanhFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanhFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tanh(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<TanhFcn<Initial,
                                     NeboConstField<Initial,
                                                    typename NeboFieldCheck<typename FieldType::
                                                                            field_type,
                                                                            FieldType>::Result>,
                                     FieldType>,
                             FieldType> tanh(FieldType const & arg) {

          TanhFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<TanhFcn<Initial, SubExpr, FieldType>, FieldType> tanh(NeboExpression<SubExpr,
                                                                                                  FieldType>
                                                                                   const & arg) {

          TanhFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct AbsFcn;

      template<typename Operand, typename FieldType>
       struct AbsFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          AbsFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             AbsFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             AbsFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          AbsFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          AbsFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct AbsFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             AbsFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             AbsFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct AbsFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          AbsFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::abs(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct AbsFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             AbsFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::abs(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct AbsFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          AbsFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::abs(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<AbsFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> abs(FieldType const & arg) {

          AbsFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<AbsFcn<Initial, SubExpr, FieldType>, FieldType> abs(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const & arg) {

          AbsFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NegFcn;

      template<typename Operand, typename FieldType>
       struct NegFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NegFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NegFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NegFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NegFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          NegFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct NegFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NegFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             NegFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct NegFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          NegFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return -(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct NegFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NegFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return -(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct NegFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          NegFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return -(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<NegFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg) {

          NegFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<NegFcn<Initial, SubExpr, FieldType>, FieldType> operator -(NeboExpression<SubExpr,
                                                                                                       FieldType>
                                                                                        const & arg) {

          NegFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          PowFcn<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             PowFcn<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             PowFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          PowFcn<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct PowFcn<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             PowFcn<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;
             PowFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const {
             return std::pow(operand1_.eval(), operand2_.eval());
          };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct PowFcn<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             PowFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return std::pow(operand1_.eval(), operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const {
             return std::pow(operand1_.eval(), operand2_.eval());
          };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> pow(typename FieldType::value_type const & arg1,
                                            FieldType const & arg2) {

          PowFcn<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>,
                             FieldType> pow(typename FieldType::value_type const & arg1,
                                            NeboExpression<SubExpr2, FieldType> const & arg2) {

          PowFcn<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> pow(FieldType const & arg1,
                                            typename FieldType::value_type const & arg2) {

          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> pow(FieldType const & arg1, FieldType const & arg2) {

          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> pow(FieldType const & arg1,
                                            NeboExpression<SubExpr2, FieldType> const & arg2) {

          PowFcn<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType> const & arg1,
                                            typename FieldType::value_type const & arg2) {

          PowFcn<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType> const & arg1,
                                            FieldType const & arg2) {

          PowFcn<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial, SubExpr1, SubExpr2, FieldType>, FieldType> pow(NeboExpression<SubExpr1,
                                                                                                           FieldType>
                                                                                            const &
                                                                                            arg1,
                                                                                            NeboExpression<SubExpr2,
                                                                                                           FieldType>
                                                                                            const &
                                                                                            arg2) {

          PowFcn<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SqrtFcn;

      template<typename Operand, typename FieldType>
       struct SqrtFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          SqrtFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             SqrtFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             SqrtFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          SqrtFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct SqrtFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             SqrtFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             SqrtFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct SqrtFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::sqrt(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct SqrtFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             SqrtFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::sqrt(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct SqrtFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sqrt(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<SqrtFcn<Initial,
                                     NeboConstField<Initial,
                                                    typename NeboFieldCheck<typename FieldType::
                                                                            field_type,
                                                                            FieldType>::Result>,
                                     FieldType>,
                             FieldType> sqrt(FieldType const & arg) {

          SqrtFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<SqrtFcn<Initial, SubExpr, FieldType>, FieldType> sqrt(NeboExpression<SubExpr,
                                                                                                  FieldType>
                                                                                   const & arg) {

          SqrtFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct LogFcn;

      template<typename Operand, typename FieldType>
       struct LogFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          LogFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             LogFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             LogFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          LogFcn<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          LogFcn(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct LogFcn<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             LogFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             LogFcn(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct LogFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          LogFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return std::log(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct LogFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             LogFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::log(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct LogFcn<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          LogFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::log(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<LogFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename FieldType::
                                                                           field_type,
                                                                           FieldType>::Result>,
                                    FieldType>,
                             FieldType> log(FieldType const & arg) {

          LogFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       };

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<LogFcn<Initial, SubExpr, FieldType>, FieldType> log(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const & arg) {

          LogFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          EqualCmp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             EqualCmp<Resize,
                      typename Operand1::ResizeType,
                      typename Operand2::ResizeType,
                      FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             EqualCmp<GPUWalk,
                      typename Operand1::GPUWalkType,
                      typename Operand2::GPUWalkType,
                      FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          EqualCmp<Reduction,
                   typename Operand1::ReductionType,
                   typename Operand2::ReductionType,
                   FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct EqualCmp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             EqualCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType,
                      FieldType> typedef SeqWalkType;
             EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() == operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct EqualCmp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() == operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() == operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial, FieldType>,
                                             NeboConstField<Initial,
                                                            typename NeboFieldCheck<typename
                                                                                    FieldType::
                                                                                    field_type,
                                                                                    FieldType>::
                                                            Result>,
                                             FieldType>,
                                    FieldType> operator ==(typename FieldType::value_type const &
                                                           arg1,
                                                           FieldType const & arg2) {

          EqualCmp<Initial,
                   NeboScalar<Initial, FieldType>,
                   NeboConstField<Initial, FieldType>,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial, FieldType>,
                                             SubExpr2,
                                             FieldType>,
                                    FieldType> operator ==(typename FieldType::value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          EqualCmp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename NeboFieldCheck<typename
                                                                                    FieldType::
                                                                                    field_type,
                                                                                    FieldType>::
                                                            Result>,
                                             NeboScalar<Initial, FieldType>,
                                             FieldType>,
                                    FieldType> operator ==(FieldType const & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   NeboScalar<Initial, FieldType>,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename NeboFieldCheck<typename
                                                                                    FieldType::
                                                                                    field_type,
                                                                                    FieldType>::
                                                            Result>,
                                             NeboConstField<Initial,
                                                            typename NeboFieldCheck<typename
                                                                                    FieldType::
                                                                                    field_type,
                                                                                    FieldType>::
                                                            Result>,
                                             FieldType>,
                                    FieldType> operator ==(FieldType const & arg1,
                                                           FieldType const & arg2) {

          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   NeboConstField<Initial, FieldType>,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename NeboFieldCheck<typename
                                                                                    FieldType::
                                                                                    field_type,
                                                                                    FieldType>::
                                                            Result>,
                                             SubExpr2,
                                             FieldType>,
                                    FieldType> operator ==(FieldType const & arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          EqualCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboScalar<Initial, FieldType>,
                                             FieldType>,
                                    FieldType> operator ==(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          EqualCmp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboConstField<Initial,
                                                            typename NeboFieldCheck<typename
                                                                                    FieldType::
                                                                                    field_type,
                                                                                    FieldType>::
                                                            Result>,
                                             FieldType>,
                                    FieldType> operator ==(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           FieldType const & arg2) {

          EqualCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial, SubExpr1, SubExpr2, FieldType>, FieldType>
       operator ==(NeboExpression<SubExpr1, FieldType> const & arg1,
                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          EqualCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          InequalCmp<SeqWalk,
                     typename Operand1::SeqWalkType,
                     typename Operand2::SeqWalkType,
                     FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             InequalCmp<Resize,
                        typename Operand1::ResizeType,
                        typename Operand2::ResizeType,
                        FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             InequalCmp<GPUWalk,
                        typename Operand1::GPUWalkType,
                        typename Operand2::GPUWalkType,
                        FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          InequalCmp<Reduction,
                     typename Operand1::ReductionType,
                     typename Operand2::ReductionType,
                     FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct InequalCmp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             InequalCmp<SeqWalk,
                        typename Operand1::SeqWalkType,
                        typename Operand2::SeqWalkType,
                        FieldType> typedef SeqWalkType;
             InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() != operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct InequalCmp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() != operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() != operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial, FieldType>,
                                               NeboConstField<Initial,
                                                              typename NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                              Result>,
                                               FieldType>,
                                    FieldType> operator !=(typename FieldType::value_type const &
                                                           arg1,
                                                           FieldType const & arg2) {

          InequalCmp<Initial,
                     NeboScalar<Initial, FieldType>,
                     NeboConstField<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial, FieldType>,
                                               SubExpr2,
                                               FieldType>,
                                    FieldType> operator !=(typename FieldType::value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          InequalCmp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                              Result>,
                                               NeboScalar<Initial, FieldType>,
                                               FieldType>,
                                    FieldType> operator !=(FieldType const & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     NeboScalar<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                              Result>,
                                               NeboConstField<Initial,
                                                              typename NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                              Result>,
                                               FieldType>,
                                    FieldType> operator !=(FieldType const & arg1,
                                                           FieldType const & arg2) {

          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     NeboConstField<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                              Result>,
                                               SubExpr2,
                                               FieldType>,
                                    FieldType> operator !=(FieldType const & arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          InequalCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial, FieldType>,
                                               FieldType>,
                                    FieldType> operator !=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          InequalCmp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboConstField<Initial,
                                                              typename NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                              Result>,
                                               FieldType>,
                                    FieldType> operator !=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           FieldType const & arg2) {

          InequalCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial, SubExpr1, SubExpr2, FieldType>, FieldType>
       operator !=(NeboExpression<SubExpr1, FieldType> const & arg1,
                   NeboExpression<SubExpr2, FieldType> const & arg2) {

          InequalCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          LessThanCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType,
                      FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             LessThanCmp<Resize,
                         typename Operand1::ResizeType,
                         typename Operand2::ResizeType,
                         FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             LessThanCmp<GPUWalk,
                         typename Operand1::GPUWalkType,
                         typename Operand2::GPUWalkType,
                         FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          LessThanCmp<Reduction,
                      typename Operand1::ReductionType,
                      typename Operand2::ReductionType,
                      FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanCmp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             LessThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType,
                         FieldType> typedef SeqWalkType;
             LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() < operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanCmp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() < operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() < operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial, FieldType>,
                                                NeboConstField<Initial,
                                                               typename NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                               Result>,
                                                FieldType>,
                                    FieldType> operator <(typename FieldType::value_type const &
                                                          arg1,
                                                          FieldType const & arg2) {

          LessThanCmp<Initial,
                      NeboScalar<Initial, FieldType>,
                      NeboConstField<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial, FieldType>,
                                                SubExpr2,
                                                FieldType>,
                                    FieldType> operator <(typename FieldType::value_type const &
                                                          arg1,
                                                          NeboExpression<SubExpr2, FieldType> const
                                                          & arg2) {

          LessThanCmp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                               Result>,
                                                NeboScalar<Initial, FieldType>,
                                                FieldType>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          typename FieldType::value_type const &
                                                          arg2) {

          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      NeboScalar<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                               Result>,
                                                NeboConstField<Initial,
                                                               typename NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                               Result>,
                                                FieldType>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          FieldType const & arg2) {

          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      NeboConstField<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                               Result>,
                                                SubExpr2,
                                                FieldType>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          NeboExpression<SubExpr2, FieldType> const
                                                          & arg2) {

          LessThanCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboScalar<Initial, FieldType>,
                                                FieldType>,
                                    FieldType> operator <(NeboExpression<SubExpr1, FieldType> const
                                                          & arg1,
                                                          typename FieldType::value_type const &
                                                          arg2) {

          LessThanCmp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboConstField<Initial,
                                                               typename NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                               Result>,
                                                FieldType>,
                                    FieldType> operator <(NeboExpression<SubExpr1, FieldType> const
                                                          & arg1,
                                                          FieldType const & arg2) {

          LessThanCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial, SubExpr1, SubExpr2, FieldType>, FieldType>
       operator <(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {

          LessThanCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          LessThanEqualCmp<SeqWalk,
                           typename Operand1::SeqWalkType,
                           typename Operand2::SeqWalkType,
                           FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             LessThanEqualCmp<Resize,
                              typename Operand1::ResizeType,
                              typename Operand2::ResizeType,
                              FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             LessThanEqualCmp<GPUWalk,
                              typename Operand1::GPUWalkType,
                              typename Operand2::GPUWalkType,
                              FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          LessThanEqualCmp<Reduction,
                           typename Operand1::ReductionType,
                           typename Operand2::ReductionType,
                           FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanEqualCmp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             LessThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType,
                              FieldType> typedef SeqWalkType;
             LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() <= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanEqualCmp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() <= operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() <= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial, FieldType>,
                                                     NeboConstField<Initial,
                                                                    typename NeboFieldCheck<typename
                                                                                            FieldType::
                                                                                            field_type,
                                                                                            FieldType>::
                                                                    Result>,
                                                     FieldType>,
                                    FieldType> operator <=(typename FieldType::value_type const &
                                                           arg1,
                                                           FieldType const & arg2) {

          LessThanEqualCmp<Initial,
                           NeboScalar<Initial, FieldType>,
                           NeboConstField<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial, FieldType>,
                                                     SubExpr2,
                                                     FieldType>,
                                    FieldType> operator <=(typename FieldType::value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          LessThanEqualCmp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename NeboFieldCheck<typename
                                                                                            FieldType::
                                                                                            field_type,
                                                                                            FieldType>::
                                                                    Result>,
                                                     NeboScalar<Initial, FieldType>,
                                                     FieldType>,
                                    FieldType> operator <=(FieldType const & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           NeboScalar<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename NeboFieldCheck<typename
                                                                                            FieldType::
                                                                                            field_type,
                                                                                            FieldType>::
                                                                    Result>,
                                                     NeboConstField<Initial,
                                                                    typename NeboFieldCheck<typename
                                                                                            FieldType::
                                                                                            field_type,
                                                                                            FieldType>::
                                                                    Result>,
                                                     FieldType>,
                                    FieldType> operator <=(FieldType const & arg1,
                                                           FieldType const & arg2) {

          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           NeboConstField<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename NeboFieldCheck<typename
                                                                                            FieldType::
                                                                                            field_type,
                                                                                            FieldType>::
                                                                    Result>,
                                                     SubExpr2,
                                                     FieldType>,
                                    FieldType> operator <=(FieldType const & arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          LessThanEqualCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboScalar<Initial, FieldType>,
                                                     FieldType>,
                                    FieldType> operator <=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          LessThanEqualCmp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboConstField<Initial,
                                                                    typename NeboFieldCheck<typename
                                                                                            FieldType::
                                                                                            field_type,
                                                                                            FieldType>::
                                                                    Result>,
                                                     FieldType>,
                                    FieldType> operator <=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           FieldType const & arg2) {

          LessThanEqualCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial, SubExpr1, SubExpr2, FieldType>,
                                    FieldType> operator <=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          LessThanEqualCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          GreaterThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType,
                         FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             GreaterThanCmp<Resize,
                            typename Operand1::ResizeType,
                            typename Operand2::ResizeType,
                            FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             GreaterThanCmp<GPUWalk,
                            typename Operand1::GPUWalkType,
                            typename Operand2::GPUWalkType,
                            FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          GreaterThanCmp<Reduction,
                         typename Operand1::ReductionType,
                         typename Operand2::ReductionType,
                         FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanCmp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             GreaterThanCmp<SeqWalk,
                            typename Operand1::SeqWalkType,
                            typename Operand2::SeqWalkType,
                            FieldType> typedef SeqWalkType;
             GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() > operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanCmp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() > operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() > operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial, FieldType>,
                                                   NeboConstField<Initial,
                                                                  typename NeboFieldCheck<typename
                                                                                          FieldType::
                                                                                          field_type,
                                                                                          FieldType>::
                                                                  Result>,
                                                   FieldType>,
                                    FieldType> operator >(typename FieldType::value_type const &
                                                          arg1,
                                                          FieldType const & arg2) {

          GreaterThanCmp<Initial,
                         NeboScalar<Initial, FieldType>,
                         NeboConstField<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial, FieldType>,
                                                   SubExpr2,
                                                   FieldType>,
                                    FieldType> operator >(typename FieldType::value_type const &
                                                          arg1,
                                                          NeboExpression<SubExpr2, FieldType> const
                                                          & arg2) {

          GreaterThanCmp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename NeboFieldCheck<typename
                                                                                          FieldType::
                                                                                          field_type,
                                                                                          FieldType>::
                                                                  Result>,
                                                   NeboScalar<Initial, FieldType>,
                                                   FieldType>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          typename FieldType::value_type const &
                                                          arg2) {

          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         NeboScalar<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename NeboFieldCheck<typename
                                                                                          FieldType::
                                                                                          field_type,
                                                                                          FieldType>::
                                                                  Result>,
                                                   NeboConstField<Initial,
                                                                  typename NeboFieldCheck<typename
                                                                                          FieldType::
                                                                                          field_type,
                                                                                          FieldType>::
                                                                  Result>,
                                                   FieldType>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          FieldType const & arg2) {

          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         NeboConstField<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename NeboFieldCheck<typename
                                                                                          FieldType::
                                                                                          field_type,
                                                                                          FieldType>::
                                                                  Result>,
                                                   SubExpr2,
                                                   FieldType>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          NeboExpression<SubExpr2, FieldType> const
                                                          & arg2) {

          GreaterThanCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboScalar<Initial, FieldType>,
                                                   FieldType>,
                                    FieldType> operator >(NeboExpression<SubExpr1, FieldType> const
                                                          & arg1,
                                                          typename FieldType::value_type const &
                                                          arg2) {

          GreaterThanCmp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboConstField<Initial,
                                                                  typename NeboFieldCheck<typename
                                                                                          FieldType::
                                                                                          field_type,
                                                                                          FieldType>::
                                                                  Result>,
                                                   FieldType>,
                                    FieldType> operator >(NeboExpression<SubExpr1, FieldType> const
                                                          & arg1,
                                                          FieldType const & arg2) {

          GreaterThanCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial, SubExpr1, SubExpr2, FieldType>,
                                    FieldType> operator >(NeboExpression<SubExpr1, FieldType> const
                                                          & arg1,
                                                          NeboExpression<SubExpr2, FieldType> const
                                                          & arg2) {

          GreaterThanCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          GreaterThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType,
                              FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             GreaterThanEqualCmp<Resize,
                                 typename Operand1::ResizeType,
                                 typename Operand2::ResizeType,
                                 FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             GreaterThanEqualCmp<GPUWalk,
                                 typename Operand1::GPUWalkType,
                                 typename Operand2::GPUWalkType,
                                 FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          GreaterThanEqualCmp<Reduction,
                              typename Operand1::ReductionType,
                              typename Operand2::ReductionType,
                              FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanEqualCmp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             GreaterThanEqualCmp<SeqWalk,
                                 typename Operand1::SeqWalkType,
                                 typename Operand2::SeqWalkType,
                                 FieldType> typedef SeqWalkType;
             GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() >= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanEqualCmp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() >= operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() >= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial, FieldType>,
                                                        NeboConstField<Initial,
                                                                       typename NeboFieldCheck<typename
                                                                                               FieldType::
                                                                                               field_type,
                                                                                               FieldType>::
                                                                       Result>,
                                                        FieldType>,
                                    FieldType> operator >=(typename FieldType::value_type const &
                                                           arg1,
                                                           FieldType const & arg2) {

          GreaterThanEqualCmp<Initial,
                              NeboScalar<Initial, FieldType>,
                              NeboConstField<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial, FieldType>,
                                                        SubExpr2,
                                                        FieldType>,
                                    FieldType> operator >=(typename FieldType::value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          GreaterThanEqualCmp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename NeboFieldCheck<typename
                                                                                               FieldType::
                                                                                               field_type,
                                                                                               FieldType>::
                                                                       Result>,
                                                        NeboScalar<Initial, FieldType>,
                                                        FieldType>,
                                    FieldType> operator >=(FieldType const & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              NeboScalar<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       };

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename NeboFieldCheck<typename
                                                                                               FieldType::
                                                                                               field_type,
                                                                                               FieldType>::
                                                                       Result>,
                                                        NeboConstField<Initial,
                                                                       typename NeboFieldCheck<typename
                                                                                               FieldType::
                                                                                               field_type,
                                                                                               FieldType>::
                                                                       Result>,
                                                        FieldType>,
                                    FieldType> operator >=(FieldType const & arg1,
                                                           FieldType const & arg2) {

          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              NeboConstField<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       };

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename NeboFieldCheck<typename
                                                                                               FieldType::
                                                                                               field_type,
                                                                                               FieldType>::
                                                                       Result>,
                                                        SubExpr2,
                                                        FieldType>,
                                    FieldType> operator >=(FieldType const & arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          GreaterThanEqualCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboScalar<Initial, FieldType>,
                                                        FieldType>,
                                    FieldType> operator >=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           typename FieldType::value_type const &
                                                           arg2) {

          GreaterThanEqualCmp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, FieldType>(arg2)));
       };

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboConstField<Initial,
                                                                       typename NeboFieldCheck<typename
                                                                                               FieldType::
                                                                                               field_type,
                                                                                               FieldType>::
                                                                       Result>,
                                                        FieldType>,
                                    FieldType> operator >=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           FieldType const & arg2) {

          GreaterThanEqualCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboConstField<Initial, FieldType>(arg2)));
       };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial, SubExpr1, SubExpr2, FieldType>,
                                    FieldType> operator >=(NeboExpression<SubExpr1, FieldType> const
                                                           & arg1,
                                                           NeboExpression<SubExpr2, FieldType> const
                                                           & arg2) {

          GreaterThanEqualCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct AndOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          AndOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             AndOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             AndOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          AndOp<Reduction,
                typename Operand1::ReductionType,
                typename Operand2::ReductionType,
                FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct AndOp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             AndOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;
             AndOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() && operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct AndOp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             AndOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() && operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() && operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboBoolean<Initial, FieldType>,
                                          SubBoolExpr2,
                                          FieldType>,
                                    FieldType> operator &&(bool const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType> const &
                                                           arg2) {

          AndOp<Initial, NeboBoolean<Initial, FieldType>, SubBoolExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboBoolean<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolExpr1,
                                          NeboBoolean<Initial, FieldType>,
                                          FieldType>,
                                    FieldType> operator &&(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType> const &
                                                           arg1,
                                                           bool const & arg2) {

          AndOp<Initial, SubBoolExpr1, NeboBoolean<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboBoolean<Initial, FieldType>(arg2)));
       };

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial, SubBoolExpr1, SubBoolExpr2, FieldType>, FieldType>
       operator &&(NeboBooleanExpression<SubBoolExpr1, FieldType> const & arg1,
                   NeboBooleanExpression<SubBoolExpr2, FieldType> const & arg2) {

          AndOp<Initial, SubBoolExpr1, SubBoolExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct OrOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          OrOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             OrOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             OrOp<GPUWalk, typename Operand1::GPUWalkType, typename Operand2::GPUWalkType, FieldType>
             typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          OrOp<Reduction,
               typename Operand1::ReductionType,
               typename Operand2::ReductionType,
               FieldType> typedef ReductionType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return (operand1_.gpu_ready() && operand2_.gpu_ready());
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1_.template init<ValidGhost, Shift>(),
                                 operand2_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {

                 return ResizeType(operand1_.template resize<ValidGhost>(),
                                   operand2_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(operand1_.template gpu_init<ValidGhost, Shift>(),
                                    operand2_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(operand1_.template reduce_init<ValidGhost, Shift>(),
                                   operand2_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct OrOp<Resize, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             OrOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
             typedef SeqWalkType;
             OrOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(operand1_.template init<Shift>(split, location),
                                    operand2_.template init<Shift>(split, location));
              };

            private:
             Operand1 const operand1_;
             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline EvalReturnType eval(void) const { return (operand1_.eval() || operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct OrOp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             OrOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) {
                return (operand1_.eval() || operand2_.eval());
             };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<Reduction, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() || operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboBoolean<Initial, FieldType>,
                                         SubBoolExpr2,
                                         FieldType>,
                                    FieldType> operator ||(bool const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType> const &
                                                           arg2) {

          OrOp<Initial, NeboBoolean<Initial, FieldType>, SubBoolExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboBoolean<Initial, FieldType>(arg1), arg2.expr()));
       };

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolExpr1,
                                         NeboBoolean<Initial, FieldType>,
                                         FieldType>,
                                    FieldType> operator ||(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType> const &
                                                           arg1,
                                                           bool const & arg2) {

          OrOp<Initial, SubBoolExpr1, NeboBoolean<Initial, FieldType>, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboBoolean<Initial, FieldType>(arg2)));
       };

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial, SubBoolExpr1, SubBoolExpr2, FieldType>, FieldType>
       operator ||(NeboBooleanExpression<SubBoolExpr1, FieldType> const & arg1,
                   NeboBooleanExpression<SubBoolExpr2, FieldType> const & arg2) {

          OrOp<Initial, SubBoolExpr1, SubBoolExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NotOp;

      template<typename Operand, typename FieldType>
       struct NotOp<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NotOp<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NotOp<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NotOp<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NotOp<Reduction, typename Operand::ReductionType, FieldType> typedef ReductionType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          NotOp(Operand const & operand)
          : operand_(operand)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return (operand_.gpu_ready()); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(operand_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {
                 return GPUWalkType(operand_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {
              return ReductionType(operand_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Operand const operand_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct NotOp<Resize, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NotOp<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
             NotOp(Operand const & operand)
             : operand_(operand)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {
                 return SeqWalkType(operand_.template init<Shift>(split, location));
              };

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Operand, typename FieldType>
       struct NotOp<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          NotOp(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline EvalReturnType eval(void) const { return !(operand_.eval()); };

         private:
          Operand operand_;
      };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct NotOp<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NotOp(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return !(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Operand, typename FieldType>
       struct NotOp<Reduction, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          NotOp(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return !(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubBoolExpr */
      template<typename SubBoolExpr, typename FieldType>
       inline NeboBooleanExpression<NotOp<Initial, SubBoolExpr, FieldType>, FieldType> operator !(NeboBooleanExpression<SubBoolExpr,
                                                                                                                        FieldType>
                                                                                                  const
                                                                                                  &
                                                                                                  arg) {

          NotOp<Initial, SubBoolExpr, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      struct NeboNil {

#        ifdef FIELD_EXPRESSION_THREADS
            NeboNil typedef ResizeType
#        endif
         /* FIELD_EXPRESSION_THREADS */;

         NeboNil typedef SeqWalkType;

#        ifdef __CUDACC__
            NeboNil typedef GPUWalkType
#        endif
         /* __CUDACC__ */;

         NeboNil typedef ReductionType;

         structured::InfiniteGhostData typedef PossibleValidGhost;

         NeboNil() {};
      };

      template<typename CurrentMode, typename Test, typename Expr, typename FieldType>
       struct NeboClause;

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Initial, Test, Expr, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboClause<SeqWalk, typename Test::SeqWalkType, typename Expr::SeqWalkType, FieldType>
          typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboClause<Resize, typename Test::ResizeType, typename Expr::ResizeType, FieldType>
             typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboClause<GPUWalk, typename Test::GPUWalkType, typename Expr::GPUWalkType, FieldType>
             typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboClause<Reduction,
                     typename Test::ReductionType,
                     typename Expr::ReductionType,
                     FieldType> typedef ReductionType;
          typename structured::Minimum<typename Test::PossibleValidGhost,
                                       typename Expr::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          NeboClause(Test const & t, Expr const & e)
          : test_(t), expr_(e)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return test_.gpu_ready() && expr_.gpu_ready(); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(test_.template init<ValidGhost, Shift>(),
                                 expr_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(test_.template resize<ValidGhost>(), expr_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(test_.template gpu_init<ValidGhost, Shift>(),
                                    expr_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(test_.template reduce_init<ValidGhost, Shift>(),
                                   expr_.template reduce_init<ValidGhost, Shift>());
           };

         private:
          Test const test_;
          Expr const expr_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Test, typename Expr, typename FieldType>
          struct NeboClause<Resize, Test, Expr, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NeboClause<SeqWalk, typename Test::SeqWalkType, typename Expr::SeqWalkType, FieldType>
             typedef SeqWalkType;
             NeboClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(test_.template init<Shift>(split, location),
                                    expr_.template init<Shift>(split, location));
              };

            private:
             Test const test_;
             Expr const expr_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<SeqWalk, Test, Expr, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {};
          inline void next(void) { test_.next(); expr_.next(); };
          inline AtomicType eval(void) const { return expr_.eval(); };
          inline bool const check(void) const { return test_.eval(); };

         private:
          Test test_;
          Expr expr_;
      };

#     ifdef __CUDACC__
         template<typename Test, typename Expr, typename FieldType>
          struct NeboClause<GPUWalk, Test, Expr, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {};
             __device__ inline void start(int x, int y) { test_.start(x, y); expr_.start(x, y); };
             __device__ inline void next(void) { test_.next(); expr_.next(); };
             __device__ inline AtomicType eval(void) { return expr_.eval(); };
             inline bool const check(void) const { return test_.eval(); };

            private:
             Test test_;
             Expr expr_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Reduction, Test, Expr, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {};
          inline void next(void) { test_.next(); expr_.next(); };
          inline bool at_end(void) const { return (test_.at_end() || expr_.at_end()); };
          inline bool has_length(void) const { return (test_.has_length() || expr_.has_length()); };
          inline AtomicType eval(void) const { return expr_.eval(); };
          inline bool const check(void) const { return test_.eval(); };

         private:
          Test test_;
          Expr expr_;
      };

      template<typename CurrentMode, typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Initial, ClauseType, Otherwise, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboCond<SeqWalk,
                   typename ClauseType::SeqWalkType,
                   typename Otherwise::SeqWalkType,
                   FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboCond<Resize,
                      typename ClauseType::ResizeType,
                      typename Otherwise::ResizeType,
                      FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboCond<GPUWalk,
                      typename ClauseType::GPUWalkType,
                      typename Otherwise::GPUWalkType,
                      FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboCond<Reduction,
                   typename ClauseType::ReductionType,
                   typename Otherwise::ReductionType,
                   FieldType> typedef ReductionType;
          typename structured::Minimum<typename ClauseType::PossibleValidGhost,
                                       typename Otherwise::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          NeboCond(ClauseType const & c, Otherwise const & e)
          : clause_(c), otherwise_(e)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const {
                return clause_.gpu_ready() && otherwise_.gpu_ready();
             }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(clause_.template init<ValidGhost, Shift>(),
                                 otherwise_.template init<ValidGhost, Shift>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(clause_.template resize<ValidGhost>(), otherwise_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(clause_.template gpu_init<ValidGhost, Shift>(),
                                    otherwise_.template gpu_init<ValidGhost, Shift>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(clause_.template reduce_init<ValidGhost, Shift>(),
                                   otherwise_.template reduce_init<ValidGhost, Shift>());
           };
          inline ClauseType const & clause(void) const { return clause_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          ClauseType const clause_;
          Otherwise const otherwise_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename ClauseType, typename Otherwise, typename FieldType>
          struct NeboCond<Resize, ClauseType, Otherwise, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NeboCond<SeqWalk,
                      typename ClauseType::SeqWalkType,
                      typename Otherwise::SeqWalkType,
                      FieldType> typedef SeqWalkType;
             NeboCond(ClauseType const & clause, Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(clause_.template init<Shift>(split, location),
                                    otherwise_.template init<Shift>(split, location));
              };

            private:
             ClauseType const clause_;
             Otherwise const otherwise_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<SeqWalk, ClauseType, Otherwise, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {};
          inline void next(void) { clause_.next(); otherwise_.next(); };
          inline AtomicType eval(void) const {
             return (clause_.check() ? clause_.eval() : otherwise_.eval());
          };

         private:
          ClauseType clause_;
          Otherwise otherwise_;
      };

#     ifdef __CUDACC__
         template<typename ClauseType, typename Otherwise, typename FieldType>
          struct NeboCond<GPUWalk, ClauseType, Otherwise, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboCond(ClauseType const & clause, Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {};
             __device__ inline void start(int x, int y) {
                clause_.start(x, y); otherwise_.start(x, y);
             };
             __device__ inline void next(void) { clause_.next(); otherwise_.next(); };
             __device__ inline AtomicType eval(void) {
                return (clause_.check() ? clause_.eval() : otherwise_.eval());
             };

            private:
             ClauseType clause_;
             Otherwise otherwise_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Reduction, ClauseType, Otherwise, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {};
          inline void next(void) { clause_.next(); otherwise_.next(); };
          inline bool at_end(void) const { return (clause_.at_end() || otherwise_.at_end()); };
          inline bool has_length(void) const {
             return (clause_.has_length() || otherwise_.has_length());
          };
          inline AtomicType eval(void) const {
             return (clause_.check() ? clause_.eval() : otherwise_.eval());
          };

         private:
          ClauseType clause_;
          Otherwise otherwise_;
      };

      struct NeboSimpleClause {

         public:
          NeboSimpleClause(bool const & b, double const & d)
          : b_(b), d_(d)
          {};
          inline bool check(void) const { return b_; };
          inline double eval(void) const { return d_; };
          template<typename FieldType>
           struct Convert {

             NeboBoolean<Initial, FieldType> typedef Boolean;

             NeboScalar<Initial, FieldType> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef Converted;

             static inline Converted convert(bool const b, double const d) {
                return Converted(Boolean(b), Scalar(d));
             };
          };

         private:
          bool const b_;
          double const d_;
      };

      struct NeboSimpleFinalClause {

         public:
          NeboSimpleFinalClause(double const d)
          : d_(d)
          {};
          inline double eval(void) const { return d_; };

         private:
          double const d_;
      };

      template<typename Otherwise>
       struct NeboSimpleCond {

         public:
          NeboSimpleCond(NeboSimpleClause const & c, Otherwise const & otherwise)
          : c_(c), otherwise_(otherwise)
          {};
          inline double eval(void) const { return (c_.check() ? c_.eval() : otherwise_.eval()); };
          template<typename FieldType>
           struct Convert {

             NeboSimpleClause::template Convert<FieldType> typedef ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             typename Otherwise::template Convert<FieldType> typedef ConvertingClauses;

             typename ConvertingClauses::Converted typedef ConvertedClauses;

             NeboCond<Initial, ConvertedClause, ConvertedClauses, FieldType> typedef Converted;

             static inline Converted convert(NeboSimpleClause const & c, Otherwise const & o) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()), o.template convert<FieldType>());
             };
          };
          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {

              Convert<FieldType> typedef Convert;

              return Convert::convert(clause(), otherwise());
           };
          inline NeboSimpleClause const & clause(void) const { return c_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          NeboSimpleClause const c_;
          Otherwise const otherwise_;
      };

      template<>
       struct NeboSimpleCond<NeboNil> {

         public:
          NeboSimpleCond(NeboSimpleClause const & c, NeboNil const & nil)
          : c_(c)
          {};
          template<typename FieldType>
           struct Convert {

             NeboSimpleClause::template Convert<FieldType> typedef ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             NeboNil typedef ConvertedClauses;

             NeboCond<Initial, ConvertedClause, ConvertedClauses, FieldType> typedef Converted;

             static inline Converted convert(NeboSimpleClause const & c) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()), NeboNil());
             };
          };
          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {

              Convert<FieldType> typedef Convert;

              return Convert::convert(clause());
           };
          inline NeboSimpleClause const & clause(void) const { return c_; };
          inline NeboNil otherwise(void) const { return NeboNil(); };

         private:
          NeboSimpleClause const c_;
      };

      template<typename Clauses>
       struct CondBuilder;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct CondBuilder<NeboCond<Initial, ClauseType, Otherwise, FieldType> > {

         public:
          NeboCond<Initial, ClauseType, Otherwise, FieldType>  typedef Clauses;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseClausesRecursive;
          template<typename PreceedingResult>
           struct ReverseClausesRecursive<NeboNil, PreceedingResult> {

             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil const & nil, PreceedingResult const & r) {
                return r;
             };
          };
          template<typename Next, typename Field, typename Following, typename PreceedingResult>
           struct ReverseClausesRecursive<NeboCond<Initial, Next, Following, Field>,
                                          PreceedingResult> {

             NeboCond<Initial, Next, Following, Field> typedef Remaining;

             NeboCond<Initial, Next, PreceedingResult, Field> typedef NewResult;

             ReverseClausesRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining const & l, PreceedingResult const & r) {
                return InternalCall::reverse(l.otherwise(), NewResult(l.clause(), r));
             };
          };
          Clauses const clauses_;

         public:
          CondBuilder(NeboCond<Initial, ClauseType, Otherwise, FieldType> const & cs)
          : clauses_(cs)
          {};
          template<typename Final>
           struct ReverseClauses;
          template<typename Final>
           struct ReverseClauses {

             ReverseClausesRecursive<Clauses, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Clauses const & cs, Final const & f) {
                return InternalCall::reverse(cs, f);
             };
          };
          template<typename Final>
           inline typename ReverseClauses<Final>::Result reverse(Final const & f) {

              ReverseClauses<Final> typedef InternalCall;

              return InternalCall::reverse(clauses_, f);
           };
          inline NeboExpression<typename ReverseClauses<NeboScalar<Initial, FieldType> >::Result,
                                FieldType> operator ()(double const d) {

             return NeboExpression<typename ReverseClauses<NeboScalar<Initial, FieldType> >::Result,
                                   FieldType>(reverse(NeboScalar<Initial, FieldType>(d)));
          };
          inline NeboExpression<typename ReverseClauses<NeboConstField<Initial, FieldType> >::Result,
                                FieldType> operator ()(FieldType const & f) {

             NeboConstField<Initial, FieldType> typedef Field;

             NeboExpression<Field, FieldType> typedef Expression;

             return NeboExpression<typename ReverseClauses<Field>::Result, FieldType>(reverse(Field(f)));
          };
          template<typename Expr>
           inline NeboExpression<typename ReverseClauses<Expr>::Result, FieldType> operator ()(NeboExpression<Expr,
                                                                                                              FieldType>
                                                                                               const
                                                                                               & e) {
              return NeboExpression<typename ReverseClauses<Expr>::Result, FieldType>(reverse(e.expr()));
           };
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboBoolean<Initial, FieldType>,
                                                 NeboScalar<Initial, FieldType>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(bool const b, double const d) {

             NeboBoolean<Initial, FieldType> typedef Boolean;

             NeboScalar<Initial, FieldType> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef NewClause;

             NeboCond<Initial, NewClause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NewClause(Boolean(b), Scalar(d)), clauses_));
          };
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboBoolean<Initial, FieldType>,
                                                 NeboConstField<Initial, FieldType>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(bool const b, FieldType const & f) {

             NeboBoolean<Initial, FieldType> typedef Boolean;

             NeboConstField<Initial, FieldType> typedef Field;

             NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Field(f)), clauses_));
          };
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboBoolean<Initial, FieldType>,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(bool const b,
                                                                NeboExpression<Expr, FieldType>
                                                                const & e) {

              NeboBoolean<Initial, FieldType> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()), clauses_));
           };
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial, FieldType>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                double const d) {

              NeboScalar<Initial, FieldType> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), clauses_));
           };
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial, FieldType>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                FieldType const & f) {

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_));
           };
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial, BoolExpr, Expr, FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                NeboExpression<Expr, FieldType>
                                                                const & e) {

              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_));
           };
      };

      template<typename Otherwise>
       struct CondBuilder<NeboSimpleCond<Otherwise> > {

         public:
          NeboSimpleCond<Otherwise>  typedef Clauses;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseClausesRecursive;
          template<typename PreceedingResult>
           struct ReverseClausesRecursive<NeboNil, PreceedingResult> {

             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil const & nil, PreceedingResult const & r) {
                return r;
             };
          };
          template<typename Following, typename PreceedingResult>
           struct ReverseClausesRecursive<NeboSimpleCond<Following>, PreceedingResult> {

             NeboSimpleCond<Following> typedef Remaining;

             NeboSimpleCond<PreceedingResult> typedef NewResult;

             ReverseClausesRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining const & l, PreceedingResult const & r) {
                return InternalCall::reverse(l.otherwise(), NewResult(l.clause(), r));
             };
          };
          Clauses const clauses_;

         public:
          CondBuilder(NeboSimpleCond<Otherwise> const & cs)
          : clauses_(cs)
          {};
          template<typename Final>
           struct ReverseClauses;
          template<typename Final>
           struct ReverseClauses {

             ReverseClausesRecursive<Clauses, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Clauses const & cs, Final const & f) {
                return InternalCall::reverse(cs, f);
             };
          };
          template<typename Final>
           inline typename ReverseClauses<Final>::Result reverse(Final const & f) {

              ReverseClauses<Final> typedef InternalCall;

              return InternalCall::reverse(clauses_, f);
           };
          inline double operator ()(double const d) {
             return reverse(NeboSimpleFinalClause(d)).eval();
          };
          template<typename FieldType>
           inline NeboExpression<typename CondBuilder<typename Clauses::template Convert<FieldType>::
                                                      Converted>::template ReverseClauses<NeboConstField<Initial,
                                                                                                         typename
                                                                                                         NeboFieldCheck<typename
                                                                                                                        FieldType::
                                                                                                                        field_type,
                                                                                                                        FieldType>::
                                                                                                         Result>
                                 >::Result,
                                 typename NeboFieldCheck<typename FieldType::field_type, FieldType>::
                                 Result> operator ()(FieldType const & f) {

              NeboConstField<Initial, FieldType> typedef Field;

              NeboExpression<Field, FieldType> typedef Expression;

              return CondBuilder<typename Clauses::template Convert<FieldType>::Converted>(clauses_.template
                                                                                                    convert<FieldType>())(f);
           };
          template<typename Expr, typename FieldType>
           inline NeboExpression<typename CondBuilder<typename Clauses::template Convert<FieldType>::
                                                      Converted>::template ReverseClauses<Expr>::
                                 Result,
                                 FieldType> operator ()(NeboExpression<Expr, FieldType> const & e) {

              return CondBuilder<typename Clauses::template Convert<FieldType>::Converted>(clauses_.template
                                                                                                    convert<FieldType>())(e);
           };
          inline CondBuilder<NeboSimpleCond<Clauses> > operator ()(bool const b, double const d) {

             NeboSimpleCond<Clauses> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NeboSimpleClause(b, d), clauses_));
          };
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboBoolean<Initial, FieldType>,
                                                  NeboConstField<Initial,
                                                                 typename NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                 Result>,
                                                  FieldType>,
                                       typename Clauses::template Convert<FieldType>::Converted,
                                       FieldType> > operator ()(bool const b, FieldType const & f) {

              NeboBoolean<Initial, FieldType> typedef Boolean;

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

              NeboCond<Initial,
                       Clause,
                       typename Clauses::template Convert<FieldType>::Converted,
                       FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Field(f)), clauses_.template convert<FieldType>()));
           };
          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboBoolean<Initial, FieldType>,
                                                  Expr,
                                                  FieldType>,
                                       typename Clauses::template Convert<typename Expr::field_type>::
                                       Converted,
                                       FieldType> > operator ()(bool const b,
                                                                NeboExpression<Expr, FieldType>
                                                                const & e) {

              NeboBoolean<Initial, FieldType> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              NeboCond<Initial,
                       Clause,
                       typename Clauses::template Convert<typename Expr::field_type>::Converted,
                       FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()), clauses_.template convert<FieldType>()));
           };
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial, FieldType>,
                                                  FieldType>,
                                       typename Clauses::template Convert<FieldType>::Converted,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                double const d) {

              NeboScalar<Initial, FieldType> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              NeboCond<Initial,
                       Clause,
                       typename Clauses::template Convert<FieldType>::Converted,
                       FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), clauses_.template convert<FieldType>()));
           };
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 typename NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                 Result>,
                                                  FieldType>,
                                       typename Clauses::template Convert<FieldType>::Converted,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                FieldType const & f) {

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              NeboCond<Initial,
                       Clause,
                       typename Clauses::template Convert<FieldType>::Converted,
                       FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_.template convert<FieldType>()));
           };
          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial, BoolExpr, Expr, FieldType>,
                                       typename Clauses::template Convert<FieldType>::Converted,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                NeboExpression<Expr, FieldType>
                                                                const & e) {

              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              NeboCond<Initial,
                       Clause,
                       typename Clauses::template Convert<FieldType>::Converted,
                       FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_.template convert<FieldType>()));
           };
      };

      template<>
       struct CondBuilder<NeboNil> {

         public:
          CondBuilder() {};
      };

      inline double cond(double const d) { return d; };

      template<typename FieldType>
       inline NeboExpression<NeboConstField<Initial, FieldType>,
                             typename NeboFieldCheck<typename FieldType::field_type, FieldType>::
                             Result> cond(FieldType const & f) {

          NeboConstField<Initial, FieldType> typedef Field;

          NeboExpression<Field, FieldType> typedef Expression;

          return Expression(Field(f));
       };

      template<typename Expr, typename FieldType>
       inline NeboExpression<Expr, FieldType> cond(NeboExpression<Expr, FieldType> const & e) {
          return e;
       };

      inline CondBuilder<NeboSimpleCond<NeboNil> > cond(bool const b, double const d) {

         NeboSimpleCond<NeboNil> typedef Cond;

         CondBuilder<Cond> typedef ReturnType;

         return ReturnType(Cond(NeboSimpleClause(b, d), NeboNil()));
      };

      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboBoolean<Initial, FieldType>,
                                              NeboConstField<Initial,
                                                             typename NeboFieldCheck<typename
                                                                                     FieldType::
                                                                                     field_type,
                                                                                     FieldType>::
                                                             Result>,
                                              FieldType>,
                                   NeboNil,
                                   FieldType> > cond(bool const b, FieldType const & f) {

          NeboBoolean<Initial, FieldType> typedef Boolean;

          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), Field(f)), NeboNil()));
       };

      template<typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboBoolean<Initial, FieldType>,
                                              Expr,
                                              FieldType>,
                                   NeboNil,
                                   FieldType> > cond(bool const b,
                                                     NeboExpression<Expr, FieldType> const & e) {

          NeboBoolean<Initial, FieldType> typedef Boolean;

          NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), e.expr()), NeboNil()));
       };

      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboScalar<Initial, FieldType>,
                                              FieldType>,
                                   NeboNil,
                                   FieldType> > cond(NeboBooleanExpression<BoolExpr, FieldType>
                                                     const & nb,
                                                     double const d) {

          NeboScalar<Initial, FieldType> typedef Scalar;

          NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), NeboNil()));
       };

      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboConstField<Initial,
                                                             typename NeboFieldCheck<typename
                                                                                     FieldType::
                                                                                     field_type,
                                                                                     FieldType>::
                                                             Result>,
                                              FieldType>,
                                   NeboNil,
                                   FieldType> > cond(NeboBooleanExpression<BoolExpr, FieldType>
                                                     const & nb,
                                                     FieldType const & f) {

          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Field(f)), NeboNil()));
       };

      template<typename BoolExpr, typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial, BoolExpr, Expr, FieldType>,
                                   NeboNil,
                                   FieldType> > cond(NeboBooleanExpression<BoolExpr, FieldType>
                                                     const & nb,
                                                     NeboExpression<Expr, FieldType> const & e) {

          NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), e.expr()), NeboNil()));
       };

#     define nebo_cond cond//;

      template<typename CurrentMode, typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint;

      template<typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint<Initial, Point, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboStencilPoint<SeqWalk, Point, typename Arg::SeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboStencilPoint<Resize, Point, typename Arg::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboStencilPoint<GPUWalk, Point, typename Arg::GPUWalkType, FieldType> typedef
             GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboStencilPoint<Reduction, Point, typename Arg::ReductionType, FieldType> typedef
          ReductionType;
          typename structured::Invalidate<typename Arg::PossibleValidGhost, Point>::result typedef
          PossibleValidGhost;
          NeboStencilPoint(Arg const & a)
          : arg_(a)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return arg_.gpu_ready(); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(arg_.template init<ValidGhost,
                                                    typename structured::Add<Shift, Point>::result>());
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(arg_.template resize<ValidGhost>());
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(arg_.template gpu_init<ValidGhost,
                                                           typename structured::Add<Shift, Point>::
                                                           result>());
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(arg_.template reduce_init<ValidGhost,
                                                             typename structured::Add<Shift, Point>::
                                                             result>());
           };

         private:
          Arg const arg_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Point, typename Arg, typename FieldType>
          struct NeboStencilPoint<Resize, Point, Arg, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NeboStencilPoint<SeqWalk, Point, typename Arg::SeqWalkType, FieldType> typedef
             SeqWalkType;
             NeboStencilPoint(Arg const & a)
             : arg_(a)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(arg_.template init<typename structured::Add<Shift, Point>::
                                                       result>(split, location));
              };

            private:
             Arg const arg_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint<SeqWalk, Point, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboStencilPoint(Arg const & a)
          : arg_(a)
          {};
          inline void next(void) { arg_.next(); };
          inline AtomicType eval(void) const { return arg_.eval(); };

         private:
          Arg arg_;
      };

#     ifdef __CUDACC__
         template<typename Point, typename Arg, typename FieldType>
          struct NeboStencilPoint<GPUWalk, Point, Arg, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboStencilPoint(Arg const & a)
             : arg_(a)
             {};
             __device__ inline void start(int x, int y) { arg_.start(x, y); };
             __device__ inline void next(void) { arg_.next(); };
             __device__ inline AtomicType eval(void) { return arg_.eval(); };

            private:
             Arg arg_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint<Reduction, Point, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboStencilPoint(Arg const & a)
          : arg_(a)
          {};
          inline void next(void) { arg_.next(); };
          inline bool at_end(void) const { return arg_.at_end(); };
          inline bool has_length(void) const { return arg_.has_length(); };
          inline AtomicType eval(void) const { return arg_.eval(); };

         private:
          Arg arg_;
      };

      template<int Length>
       struct NeboStencilCoefCollection {

         public:
          NeboStencilCoefCollection(NeboStencilCoefCollection<Length - 1> const & o, double const c)
          : others_(o), coef_(c)
          {};
          inline NeboStencilCoefCollection<Length + 1> const operator ()(double const c) const {
             return NeboStencilCoefCollection<Length + 1>(*this, c);
          };
          inline double const coef(void) const { return coef_; };
          inline NeboStencilCoefCollection<Length - 1> const others(void) const { return others_; };

         private:
          NeboStencilCoefCollection<Length - 1> const others_;
          double const coef_;
      };

      template<>
       struct NeboStencilCoefCollection<1> {

         public:
          NeboStencilCoefCollection(double const c)
          : coef_(c)
          {};
          inline NeboStencilCoefCollection<2> const operator ()(double const c) const {
             return NeboStencilCoefCollection<2>(*this, c);
          };
          inline double const coef(void) const { return coef_; };

         private:
          double const coef_;
      };

      inline NeboStencilCoefCollection<1> const build_coef_collection(double const c) {
         return NeboStencilCoefCollection<1>(c);
      };

      inline NeboStencilCoefCollection<2> const build_two_point_coef_collection(double const c1,
                                                                                double const c2) {
         return NeboStencilCoefCollection<1>(c1)(c2);
      };

      inline NeboStencilCoefCollection<4> const build_four_point_coef_collection(double const c1,
                                                                                 double const c2,
                                                                                 double const c3,
                                                                                 double const c4) {
         return NeboStencilCoefCollection<1>(c1)(c2)(c3)(c4);
      };

      template<typename PointType, typename CollectionType>
       struct NeboStencilPointCollection {

         public:
          PointType typedef Point;
          CollectionType typedef Collection;
          NeboStencilPointCollection<Point, Collection> typedef MyType;
          enum {length = 1 + Collection::length};
          template<typename NewPoint>
           struct AddPoint { NeboStencilPointCollection<NewPoint, MyType> typedef Result; };
          template<typename GivenPossibleValidGhost>
           struct PossibleGhost {

             typename structured::Invalidate<GivenPossibleValidGhost, Point>::result typedef
             CurrentPossibleValidGhost;

             typename Collection::template PossibleGhost<GivenPossibleValidGhost> typedef
             EarlierPointsPossibleGhost;

             typename EarlierPointsPossibleGhost::Result typedef EarlierPointsPossibleValidGhost;

             typename structured::Minimum<CurrentPossibleValidGhost, EarlierPointsPossibleValidGhost>::
             result typedef Result;
          };
          template<typename ArgPreSeqWalk, typename DestType>
           struct ConstructExpr {

             NeboScalar<SeqWalk, DestType> typedef Coef;

             typename ArgPreSeqWalk::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef, DestType> typedef MultiplyType;

             typename Collection::template ConstructExpr<ArgPreSeqWalk, DestType> typedef
             EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<SeqWalk, EarlierPointsResult, MultiplyType, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefCollection<length> const &
                                                         coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template in_sq_construct<ValidGhost, Shift>(arg,
                                                                                              coefs.others()),
                               MultiplyType(arg.template init<ValidGhost, NewShift>(), Coef(coefs.coef())));
              };

             template<typename Shift>
              static inline Result const rs_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefCollection<length> const &
                                                         coefs,
                                                         structured::IntVec const & split,
                                                         structured::IntVec const & location) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template rs_sq_construct<Shift>(arg,
                                                                                  coefs.others(),
                                                                                  split,
                                                                                  location),
                               MultiplyType(arg.template init<NewShift>(split, location), Coef(coefs.coef())));
              };
          };
#         ifdef __CUDACC__
             template<typename ArgPreGPUWalk, typename DestType>
              struct ConstructGPUExpr {

                NeboScalar<GPUWalk, DestType> typedef Coef;

                typename ArgPreGPUWalk::GPUWalkType typedef Arg;

                ProdOp<GPUWalk, Arg, Coef, DestType> typedef MultiplyType;

                typename Collection::template ConstructExpr<ArgPreGPUWalk, DestType> typedef
                EarlierPointsType;

                typename EarlierPointsType::Result typedef EarlierPointsResult;

                SumOp<GPUWalk, EarlierPointsResult, MultiplyType, DestType> typedef Result;

                template<typename ValidGhost, typename Shift>
                 static inline Result const in_gpu_construct(ArgPreGPUWalk const & arg,
                                                             NeboStencilCoefCollection<length> const
                                                             & coefs) {

                    typename structured::Add<Shift, Point>::result typedef NewShift;

                    return Result(EarlierPointsType::template in_sq_construct<ValidGhost, Shift>(arg,
                                                                                                 coefs.others()),
                                  MultiplyType(arg.template init<ValidGhost, NewShift>(), Coef(coefs.coef())));
                 };
             }
#         endif
          /* __CUDACC__ */;
          template<typename ArgPreReduction, typename DestType>
           struct ConstructReductionExpr {

             NeboScalar<Reduction, DestType> typedef Coef;

             typename ArgPreReduction::ReductionType typedef Arg;

             ProdOp<Reduction, Arg, Coef, DestType> typedef MultiplyType;

             typename Collection::template ConstructReductionExpr<ArgPreReduction, DestType> typedef
             EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<Reduction, EarlierPointsResult, MultiplyType, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_rd_construct(ArgPreReduction const & arg,
                                                         NeboStencilCoefCollection<length> const &
                                                         coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template in_rd_construct<ValidGhost, Shift>(arg,
                                                                                              coefs.others()),
                               MultiplyType(arg.template reduce_init<ValidGhost, NewShift>(), Coef(coefs.coef())));
              };

             template<typename Shift>
              static inline Result const rs_rd_construct(ArgPreReduction const & arg,
                                                         NeboStencilCoefCollection<length> const &
                                                         coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template rs_rd_construct<Shift>(arg, coefs.others()),
                               MultiplyType(arg.template reduce_init<NewShift>(), Coef(coefs.coef())));
              };
          };
      };

      template<typename PointType>
       struct NeboStencilPointCollection<PointType, NeboNil> {

         public:
          PointType typedef Point;
          NeboNil typedef Collection;
          NeboStencilPointCollection<Point, Collection> typedef MyType;
          enum {length = 1};
          template<typename NewPoint>
           struct AddPoint { NeboStencilPointCollection<NewPoint, MyType> typedef Result; };
          template<typename GivenPossibleValidGhost>
           struct PossibleGhost {
             typename structured::Invalidate<GivenPossibleValidGhost, Point>::result typedef Result;
          };
          template<typename ArgPreSeqWalk, typename DestType>
           struct ConstructExpr {

             NeboScalar<SeqWalk, DestType> typedef Coef;

             typename ArgPreSeqWalk::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefCollection<1> const & coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template init<ValidGhost, NewShift>(), Coef(coefs.coef()));
              };

             template<typename Shift>
              static inline Result const rs_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefCollection<1> const & coefs,
                                                         structured::IntVec const & split,
                                                         structured::IntVec const & location) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template init<NewShift>(split, location), Coef(coefs.coef()));
              };
          };
#         ifdef __CUDACC__
             template<typename ArgPreGPUWalk, typename DestType>
              struct ConstructGPUExpr {

                NeboScalar<GPUWalk, DestType> typedef Coef;

                typename ArgPreGPUWalk::GPUWalkType typedef Arg;

                ProdOp<GPUWalk, Arg, Coef, DestType> typedef Result;

                template<typename ValidGhost, typename Shift>
                 static inline Result const in_gpu_construct(ArgPreGPUWalk const & arg,
                                                             NeboStencilCoefCollection<1> const &
                                                             coefs) {

                    typename structured::Add<Shift, Point>::result typedef NewShift;

                    return Result(arg.template init<ValidGhost, NewShift>(), Coef(coefs.coef()));
                 };
             }
#         endif
          /* __CUDACC__ */;
          template<typename ArgPreReduction, typename DestType>
           struct ConstructReductionExpr {

             NeboScalar<Reduction, DestType> typedef Coef;

             typename ArgPreReduction::ReductionType typedef Arg;

             ProdOp<Reduction, Arg, Coef, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_rd_construct(ArgPreReduction const & arg,
                                                         NeboStencilCoefCollection<1> const & coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template reduce_init<ValidGhost, NewShift>(), Coef(coefs.coef()));
              };

             template<typename Shift>
              static inline Result const rs_rd_construct(ArgPreReduction const & arg,
                                                         NeboStencilCoefCollection<1> const & coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template reduce_init<NewShift>(), Coef(coefs.coef()));
              };
          };
      };

      template<typename First>
       struct BuildStencilPointCollection {
         NeboStencilPointCollection<First, NeboNil> typedef Result;
      };

      template<typename First, typename Second>
       struct BuildTwoPointCollection {

         typename BuildStencilPointCollection<First>::Result typedef FirstPoint;

         typename FirstPoint::template AddPoint<Second>::Result typedef Result;
      };

      template<typename First, typename Second, typename Third, typename Fourth>
       struct BuildFourPointCollection {

         typename BuildStencilPointCollection<First>::Result typedef FirstPoint;

         typename FirstPoint::template AddPoint<Second>::Result typedef SecondFirstCollection;

         typename SecondFirstCollection::template AddPoint<Third>::Result typedef
         ThirdSecondFirstCollection;

         typename ThirdSecondFirstCollection::template AddPoint<Fourth>::Result typedef Result;
      };

      template<typename CurrentMode, typename Pts, typename Arg, typename FieldType>
       struct NeboStencil;

      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Initial, Pts, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          NeboStencilCoefCollection<Pts::length> typedef Coefs;
          typename Pts::template ConstructExpr<Arg, FieldType> typedef ConstructExpr;
          typename ConstructExpr::Result typedef ArgSeqWalkType;
#         ifdef __CUDACC__
             typename Pts::template ConstructGPUExpr<Arg, FieldType> typedef ConstructGPUExpr;
             typename ConstructGPUExpr::Result typedef ArgGPUWalkType
#         endif
          /* __CUDACC__ */;
          typename Pts::template ConstructReductionExpr<Arg, FieldType> typedef
          ConstructReductionExpr;
          typename ConstructReductionExpr::Result typedef ArgReductionType;
          NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef SeqWalkType;
#         ifdef FIELD_EXPRESSION_THREADS
             NeboStencil<Resize, Pts, typename Arg::ResizeType, FieldType> typedef ResizeType
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             NeboStencil<GPUWalk, Pts, ArgGPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboStencil<Reduction, Pts, ArgReductionType, FieldType> typedef ReductionType;
          typename Pts::template PossibleGhost<typename Arg::PossibleValidGhost>::Result typedef
          PossibleValidGhost;
          NeboStencil(Arg const & a, Coefs const & coefs)
          : arg_(a), coefs_(coefs)
          {};
#         ifdef __CUDACC__
             inline bool gpu_ready(void) const { return arg_.gpu_ready(); }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(ConstructExpr::template in_sq_construct<ValidGhost, Shift>(arg_,
                                                                                            coefs_));
           };
#         ifdef FIELD_EXPRESSION_THREADS
             template<typename ValidGhost>
              inline ResizeType resize(void) const {
                 return ResizeType(arg_.template resize<ValidGhost>(), coefs_);
              }
#         endif
          /* FIELD_EXPRESSION_THREADS */;
#         ifdef __CUDACC__
             template<typename ValidGhost, typename Shift>
              inline GPUWalkType gpu_init(void) const {

                 return GPUWalkType(ConstructGPUExpr::template in_gpu_construct<ValidGhost, Shift>(arg_,
                                                                                                   coefs_));
              }
#         endif
          /* __CUDACC__ */;
          template<typename ValidGhost, typename Shift>
           inline ReductionType reduce_init(void) const {

              return ReductionType(ConstructExpr::template in_reduce_construct<ValidGhost, Shift>(arg_,
                                                                                                  coefs_));
           };

         private:
          Arg const arg_;
          Coefs const coefs_;
      };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<Resize, Pts, Arg, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             NeboStencilCoefCollection<Pts::length> typedef Coefs;
             typename Pts::template ConstructExpr<Arg, FieldType> typedef ConstructExpr;
             typename ConstructExpr::Result typedef ArgSeqWalkType;
             NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef SeqWalkType;
             NeboStencil(Arg const & arg, Coefs const & coefs)
             : arg_(arg), coefs_(coefs)
             {};
             template<typename Shift>
              inline SeqWalkType init(structured::IntVec const & split,
                                      structured::IntVec const & location) const {

                 return SeqWalkType(ConstructExpr::template rs_sq_construct<Shift>(arg_,
                                                                                   coefs_,
                                                                                   split,
                                                                                   location));
              };

            private:
             Arg const arg_;
             Coefs const coefs_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<SeqWalk, Pts, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboStencil(Arg const & arg)
          : arg_(arg)
          {};
          inline void next(void) { arg_.next(); };
          inline AtomicType eval(void) const { return arg_.eval(); };

         private:
          Arg arg_;
      };

#     ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<GPUWalk, Pts, Arg, FieldType> {

            public:
             FieldType typedef field_type;
             typename field_type::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboStencil(Arg const & a)
             : arg_(a)
             {};
             __device__ inline void start(int x, int y) { arg_.start(x, y); };
             __device__ inline void next(void) { arg_.next(); };
             __device__ inline AtomicType eval(void) { return arg_.eval(); };

            private:
             Arg arg_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Reduction, Pts, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename field_type::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboStencil(Arg const & arg)
          : arg_(arg)
          {};
          inline void next(void) { arg_.next(); };
          inline bool at_end(void) const { return arg_.at_end(); };
          inline bool has_length(void) const { return arg_.has_length(); };
          inline AtomicType eval(void) const { return arg_.eval(); };

         private:
          Arg arg_;
      };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef RhsType;

          NeboField<Initial, FieldType>(lhs).template assign<All, RhsType>(RhsType(rhs));

          return lhs;
       };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef RhsType;

          NeboField<Initial, FieldType>(lhs).template assign<All, RhsType>(RhsType(rhs));

          return lhs;
       };

      template<typename RhsType, typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             NeboExpression<RhsType, FieldType> const & rhs) {

          NeboField<Initial, FieldType>(lhs).template assign<All, RhsType>(rhs.expr());

          return lhs;
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef RhsType;

          NeboField<Initial, FieldType>(lhs).template assign<InteriorOnly, RhsType>(RhsType(rhs));

          return lhs;
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef RhsType;

          NeboField<Initial, FieldType>(lhs).template assign<InteriorOnly, RhsType>(RhsType(rhs));

          return lhs;
       };

      template<typename RhsType, typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                NeboExpression<RhsType, FieldType> const & rhs) {

          NeboField<Initial, FieldType>(lhs).template assign<InteriorOnly, RhsType>(rhs.expr());

          return lhs;
       };
   } /* SpatialOps */;

#endif
/* SpatialOps_FieldExpressions_h */
