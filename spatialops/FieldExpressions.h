/* This file was generated by fulmar version 0.7.6.1. */
/*
 * Copyright (c) 2011 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef SpatialOps_FieldExpressions_h
#  define SpatialOps_FieldExpressions_h

#  include <spatialops/SpatialOpsConfigure.h>
#  include <spatialops/structured/IndexTriplet.h>
#  include <spatialops/structured/GhostData.h>
#  include <spatialops/structured/SpatialField.h>
#  include <cmath>
#  include <math.h>

   /*#include <iostream> */

#  ifdef FIELD_EXPRESSION_THREADS
#     include <spatialops/SpatialOpsTools.h>
#     include <vector>
#     include <boost/bind.hpp>
#     include <spatialops/ThreadPool.h>
#     include <spatialops/structured/IntVec.h>
#     include <boost/interprocess/sync/interprocess_semaphore.hpp>
      namespace BI = boost::interprocess;
#  endif
   /* FIELD_EXPRESSION_THREADS */

   namespace SpatialOps {

      /* Meta-programming compiler flags */
      struct UseWholeIterator;
      struct UseInteriorIterator;

      template<typename IteratorType, typename FirstType, typename SecondType>
       struct IteratorStyle;

      /* UseWholeIterator */
      template<typename FirstType, typename SecondType>
       struct IteratorStyle<UseWholeIterator, FirstType, SecondType> { FirstType typedef result; };

      /* UseInteriorIterator */
      template<typename FirstType, typename SecondType>
       struct IteratorStyle<UseInteriorIterator, FirstType, SecondType> {
         SecondType typedef result;
      };

      template<bool Boolean, typename FirstType, typename SecondType>
       struct TemplateIf;

      /* true */
      template<typename TrueResult, typename FalseResult>
       struct TemplateIf<true, TrueResult, FalseResult> { TrueResult typedef result; };

      /* false */
      template<typename TrueResult, typename FalseResult>
       struct TemplateIf<false, TrueResult, FalseResult> { FalseResult typedef result; };

      template<typename Operand, typename FieldType>
       struct NeboExpression {

         public:
          FieldType typedef field_type;
          Operand typedef Expression;
          NeboExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      template<typename Operand, typename FieldType>
       struct NeboBooleanExpression {

         public:
          FieldType typedef field_type;
          Operand typedef Expression;
          NeboBooleanExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      /* Modes: */
      struct Initial;
      struct ResizePrep;
      struct Resize;
      struct SeqWalk;
#     ifdef __CUDACC__
         struct GPUWalk
#     endif
      /* __CUDACC__ */;

      template<typename CurrentMode, typename FieldType>
       struct NeboScalar;

      template<typename FieldType>
       struct NeboScalar<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
#         ifdef __CUDACC__
             NeboScalar<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboScalar<ResizePrep, FieldType> typedef ResizePrepType;
          NeboScalar<SeqWalk, FieldType> typedef SeqWalkType;
          structured::InfiniteGhostData typedef PossibleValidGhost;
          NeboScalar(AtomicType const v)
          : value_(v)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const { return SeqWalkType(value()); };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const { return ResizePrepType(value()); };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename FieldType>
       struct NeboScalar<ResizePrep, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar<Resize, FieldType> typedef ResizeType;
          NeboScalar(AtomicType const value)
          : value_(value)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(value());
          };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename FieldType>
       struct NeboScalar<Resize, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar<SeqWalk, FieldType> typedef SeqWalkType;
          NeboScalar(AtomicType const value)
          : value_(value)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const { return SeqWalkType(value()); };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename FieldType>
       struct NeboScalar<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(AtomicType const value)
          : value_(value)
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline AtomicType const eval(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboBoolean;

      template<typename FieldType>
       struct NeboBoolean<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             NeboBoolean<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboBoolean<ResizePrep, FieldType> typedef ResizePrepType;
          NeboBoolean<SeqWalk, FieldType> typedef SeqWalkType;
          structured::InfiniteGhostData typedef PossibleValidGhost;
          NeboBoolean(bool const v)
          : value_(v)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const { return SeqWalkType(value()); };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const { return ResizePrepType(value()); };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename FieldType>
       struct NeboBoolean<ResizePrep, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean<Resize, FieldType> typedef ResizeType;
          NeboBoolean(bool const value)
          : value_(value)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(value());
          };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename FieldType>
       struct NeboBoolean<Resize, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean<SeqWalk, FieldType> typedef SeqWalkType;
          NeboBoolean(bool const value)
          : value_(value)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const { return SeqWalkType(value()); };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename FieldType>
       struct NeboBoolean<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean(bool const value)
          : value_(value)
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline bool const eval(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboConstField;

      template<typename FieldType>
       struct NeboConstField<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             NeboConstField<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboConstField<ResizePrep, FieldType> typedef ResizePrepType;
          NeboConstField<SeqWalk, FieldType> typedef SeqWalkType;
          typename structured::GhostFromField<FieldType>::result typedef PossibleValidGhost;
          NeboConstField(FieldType const & f)
          : field_(f)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(field().template resize_ghost_and_shift<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(field().template resize_ghost<ValidGhost>());
           };
          inline FieldType const & field(void) const { return field_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(field()); }
#         endif
          /* __CUDACC__ */;

         private:
          FieldType const field_;
      };

      template<typename FieldType>
       struct NeboConstField<ResizePrep, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboConstField<Resize, FieldType> typedef ResizeType;
          NeboConstField(FieldType const & f)
          : field_(f)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {

             return ResizeType(FieldType(field().window_with_ghost().refine(split, location),
                                         field().field_values(),
                                         structured::ExternalStorage));
          };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename FieldType>
       struct NeboConstField<Resize, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboConstField<SeqWalk, FieldType> typedef SeqWalkType;
          NeboConstField(FieldType const & f)
          : field_(f)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(field().template shift<Shift>());
           };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename FieldType>
       struct NeboConstField<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboConstField(FieldType const & f)
          : iter_(f.begin()), end_(f.end())
          {};
          inline void next(void) { ++iter_; };
          inline bool at_end(void) const { return (iter_ == end_); };
          inline bool has_length(void) const { return true; };
          inline AtomicType const & eval(void) const { return *iter_; };

         private:
          typename FieldType::const_iterator iter_;
          typename FieldType::const_iterator const end_;
      };

#     ifdef __CUDACC__
         template<typename FieldType>
          struct NeboConstField<GPUWalk, FieldType> {

            public:
             FieldType typedef field_type;
             typename FieldType::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboConstField(FieldType const & f)
             : current_(f.field_values(EXTERNAL_CUDA_GPU, f.device_index())),
               xLength_(f.window_with_ghost().glob_dim(0)),
               step_((xLength_ * f.window_with_ghost().glob_dim(1)))
             {};
             __device__ inline void start(int x, int y) { current_ += x + y * xLength_; };
             __device__ inline void next(void) { current_ += step_; };
             __device__ inline AtomicType eval(void) { return *current_; };

            private:
             const AtomicType * current_;
             int xLength_;
             int step_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename CurrentMode, typename FieldType>
       struct NeboField;

      template<typename FieldType>
       struct NeboField<Initial, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             NeboField<GPUWalk, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboField<ResizePrep, FieldType> typedef ResizePrepType;
          NeboField<SeqWalk, FieldType> typedef SeqWalkType;
          typename structured::GhostFromField<FieldType>::result typedef PossibleValidGhost;
          NeboField(FieldType f)
          : field_(f)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) {

              return SeqWalkType(field().template resize_ghost_and_shift_and_maintain_interior<ValidGhost,
                                                                                               Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) {
              return ResizePrepType(field().template resize_ghost_and_maintain_interior<ValidGhost>());
           };
          inline FieldType & field(void) { return field_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) { return GPUWalkType(field()); }
#         endif
          /* __CUDACC__ */;

         private:
          FieldType field_;
      };

      template<typename FieldType>
       struct NeboField<ResizePrep, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboField<Resize, FieldType> typedef ResizeType;
          NeboField(FieldType f)
          : field_(f)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) {

             return ResizeType(FieldType(field().window_with_ghost().refine(split, location),
                                         field().field_values(),
                                         structured::ExternalStorage));
          };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename FieldType>
       struct NeboField<Resize, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboField<SeqWalk, FieldType> typedef SeqWalkType;
          NeboField(FieldType f)
          : field_(f)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) {
              return SeqWalkType(field().template shift_and_maintain_interior<Shift>());
           };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename FieldType>
       struct NeboField<SeqWalk, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboField(FieldType f)
          : iter_(f.begin()), end_(f.end())
          {};
          inline void next(void) { ++iter_; };
          inline bool at_end(void) const { return (iter_ == end_); };
          inline bool has_length(void) const { return true; };
          inline AtomicType & ref(void) { return *iter_; };
          inline AtomicType * ptr(void) { return &(*iter_); };

         private:
          typename FieldType::iterator iter_;
          typename FieldType::iterator const end_;
      };

#     ifdef __CUDACC__
         template<typename FieldType>
          struct NeboField<GPUWalk, FieldType> {

            public:
             FieldType typedef field_type;
             typename FieldType::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             NeboField(FieldType & f)
             : current_(f.field_values(EXTERNAL_CUDA_GPU, f.device_index())),
               location_(0),
               xLength_(f.window_with_ghost().glob_dim(0)),
               xExtent_(f.window_with_ghost().extent(0)),
               yExtent_(f.window_with_ghost().extent(1)),
               zExtent_(f.window_with_ghost().extent(2)),
               step_((xLength_ * f.window_with_ghost().glob_dim(1))),
               valid_(false)
             {};
             __device__ inline void start(int x, int y) {

                valid_ = (x < xExtent_ && x >= 0 && y < yExtent_ && y >= 0);

                if(valid()) { location_ = 0; current_ = x + y * xLength_; };
             };
             __device__ inline void next(void) { current_ += step_; location_ ++; };
             __device__ inline bool valid(void) { return valid_; };
             __device__ inline bool at_end(void) { return location_ >= zExtent_; };
             __device__ inline AtomicType & ref(void) { return *current_; };

            private:
             AtomicType * current_;
             int location_;
             int xLength_;
             int xExtent_;
             int yExtent_;
             int zExtent_;
             int step_;
             int valid_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename Input, typename FieldType>
       struct Standardize;

      template<typename FieldType>
       struct Standardize<FieldType, FieldType> {

         NeboConstField<Initial, FieldType> typedef StandardType;

         NeboExpression<StandardType, FieldType> typedef StandardTerm;

         static inline StandardType standardType(FieldType const & given) {
            return StandardType(given);
         };

         static inline StandardTerm standardTerm(FieldType const & given) {
            return StandardTerm(StandardType(given));
         };
      };

      template<typename ExprType, typename FieldType>
       struct Standardize<NeboExpression<ExprType, FieldType>, FieldType> {

         ExprType typedef StandardType;

         NeboExpression<StandardType, FieldType> typedef StandardTerm;

         static inline StandardType standardType(NeboExpression<ExprType, FieldType> const & given) {
            return given.expr();
         };

         static inline StandardTerm standardTerm(NeboExpression<ExprType, FieldType> const & given) {
            return given;
         };
      };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct SumOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             SumOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          SumOp<ResizePrep,
                typename Operand1::ResizePrepType,
                typename Operand2::ResizePrepType,
                FieldType> typedef ResizePrepType;
          SumOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SumOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SumOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() + operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<SumOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator +(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<SumOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator +(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                   typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                   StandardType,
                                   typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator +(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct SumOp<GPUWalk, Operand1, Operand2, FieldType> {

            public:
             FieldType typedef field_type;
             typename FieldType::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             SumOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {};
             __device__ inline void start(int x, int y) {

                operand1_.start(x, y);

                operand2_.start(x, y);
             };
             __device__ inline void next(void) { operand1_.next(); operand2_.next(); };
             __device__ inline AtomicType eval(void) { return operand1_.eval() + operand2_.eval(); };

            private:
             Operand1 operand1_;
             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             DiffOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          DiffOp<ResizePrep,
                 typename Operand1::ResizePrepType,
                 typename Operand2::ResizePrepType,
                 FieldType> typedef ResizePrepType;
          DiffOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DiffOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DiffOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() - operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<DiffOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator -(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<DiffOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator -(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator -(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             ProdOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          ProdOp<ResizePrep,
                 typename Operand1::ResizePrepType,
                 typename Operand2::ResizePrepType,
                 FieldType> typedef ResizePrepType;
          ProdOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ProdOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ProdOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() * operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<ProdOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator *(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<ProdOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator *(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator *(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DivOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             DivOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          DivOp<ResizePrep,
                typename Operand1::ResizePrepType,
                typename Operand2::ResizePrepType,
                FieldType> typedef ResizePrepType;
          DivOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DivOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DivOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() / operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<DivOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator /(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<DivOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator /(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                   typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                   StandardType,
                                   typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator /(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SinFcn;

      template<typename Operand, typename FieldType>
       struct SinFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             SinFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          SinFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          SinFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          SinFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct SinFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SinFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          SinFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct SinFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SinFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          SinFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct SinFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SinFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sin(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<SinFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> sin(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          SinFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct SinFcn<GPUWalk, Operand, FieldType> {

            public:
             FieldType typedef field_type;
             typename FieldType::memory_window typedef MemoryWindow;
             typename field_type::value_type typedef AtomicType;
             SinFcn(Operand const & operand)
             : operand_(operand)
             {};
             __device__ inline void start(int x, int y) { operand_.start(x, y); };
             __device__ inline void next(void) { operand_.next(); };
             __device__ inline AtomicType eval(void) { return std::sin(operand_.eval()); };

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct CosFcn;

      template<typename Operand, typename FieldType>
       struct CosFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             CosFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          CosFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          CosFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          CosFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct CosFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          CosFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          CosFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct CosFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          CosFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          CosFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct CosFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          CosFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::cos(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<CosFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> cos(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          CosFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanFcn;

      template<typename Operand, typename FieldType>
       struct TanFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             TanFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          TanFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          TanFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          TanFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct TanFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          TanFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct TanFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          TanFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct TanFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tan(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<TanFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> tan(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          TanFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct ExpFcn;

      template<typename Operand, typename FieldType>
       struct ExpFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             ExpFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          ExpFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          ExpFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          ExpFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct ExpFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ExpFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          ExpFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct ExpFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ExpFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          ExpFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct ExpFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ExpFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::exp(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<ExpFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> exp(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          ExpFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanhFcn;

      template<typename Operand, typename FieldType>
       struct TanhFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             TanhFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          TanhFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          TanhFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          TanhFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct TanhFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanhFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          TanhFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct TanhFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanhFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          TanhFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct TanhFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanhFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tanh(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<TanhFcn<Initial,
                                     typename Standardize<SubExpr, typename SubExpr::field_type>::
                                     StandardType,
                                     typename SubExpr::field_type>,
                             typename SubExpr::field_type> tanh(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          TanhFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct AbsFcn;

      template<typename Operand, typename FieldType>
       struct AbsFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             AbsFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          AbsFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          AbsFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          AbsFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct AbsFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AbsFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          AbsFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct AbsFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AbsFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          AbsFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct AbsFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          AbsFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::abs(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<AbsFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> abs(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          AbsFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NegFcn;

      template<typename Operand, typename FieldType>
       struct NegFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             NegFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NegFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          NegFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          NegFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct NegFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NegFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          NegFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct NegFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NegFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          NegFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct NegFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          NegFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return -(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<NegFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> operator -(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          NegFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             PowFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          PowFcn<ResizePrep,
                 typename Operand1::ResizePrepType,
                 typename Operand2::ResizePrepType,
                 FieldType> typedef ResizePrepType;
          PowFcn<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          PowFcn<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          PowFcn<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const {
             return std::pow(operand1_.eval(), operand2_.eval());
          };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<PowFcn<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> pow(SubExpr1 const & arg1,
                                                                SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<PowFcn<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> pow(SubExpr1 const & arg1,
                                                                typename SubExpr1::field_type::
                                                                value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> pow(typename SubExpr2::field_type::
                                                                value_type const & arg1,
                                                                SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SqrtFcn;

      template<typename Operand, typename FieldType>
       struct SqrtFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             SqrtFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          SqrtFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          SqrtFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct SqrtFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SqrtFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct SqrtFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SqrtFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct SqrtFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sqrt(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<SqrtFcn<Initial,
                                     typename Standardize<SubExpr, typename SubExpr::field_type>::
                                     StandardType,
                                     typename SubExpr::field_type>,
                             typename SubExpr::field_type> sqrt(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          SqrtFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct LogFcn;

      template<typename Operand, typename FieldType>
       struct LogFcn<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             LogFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          LogFcn<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          LogFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          LogFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct LogFcn<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LogFcn<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          LogFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct LogFcn<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LogFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          LogFcn(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct LogFcn<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          LogFcn(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::log(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<LogFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> log(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          LogFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             EqualCmp<GPUWalk,
                      typename Operand1::GPUWalkType,
                      typename Operand2::GPUWalkType,
                      FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          EqualCmp<ResizePrep,
                   typename Operand1::ResizePrepType,
                   typename Operand2::ResizePrepType,
                   FieldType> typedef ResizePrepType;
          EqualCmp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          EqualCmp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          EqualCmp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() == operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             typename Standardize<SubExpr1,
                                                                  typename SubExpr1::field_type>::
                                             StandardType,
                                             typename Standardize<SubExpr2,
                                                                  typename SubExpr1::field_type>::
                                             StandardType,
                                             typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator ==(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          EqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             typename Standardize<SubExpr1,
                                                                  typename SubExpr1::field_type>::
                                             StandardType,
                                             NeboScalar<Initial, typename SubExpr1::field_type>,
                                             typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator ==(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          EqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial, typename SubExpr2::field_type>,
                                             typename Standardize<SubExpr2,
                                                                  typename SubExpr2::field_type>::
                                             StandardType,
                                             typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator ==(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          EqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             InequalCmp<GPUWalk,
                        typename Operand1::GPUWalkType,
                        typename Operand2::GPUWalkType,
                        FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          InequalCmp<ResizePrep,
                     typename Operand1::ResizePrepType,
                     typename Operand2::ResizePrepType,
                     FieldType> typedef ResizePrepType;
          InequalCmp<SeqWalk,
                     typename Operand1::SeqWalkType,
                     typename Operand2::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          InequalCmp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          InequalCmp<SeqWalk,
                     typename Operand1::SeqWalkType,
                     typename Operand2::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() != operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               typename Standardize<SubExpr1,
                                                                    typename SubExpr1::field_type>::
                                               StandardType,
                                               typename Standardize<SubExpr2,
                                                                    typename SubExpr1::field_type>::
                                               StandardType,
                                               typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator !=(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          InequalCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               typename Standardize<SubExpr1,
                                                                    typename SubExpr1::field_type>::
                                               StandardType,
                                               NeboScalar<Initial, typename SubExpr1::field_type>,
                                               typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator !=(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          InequalCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial, typename SubExpr2::field_type>,
                                               typename Standardize<SubExpr2,
                                                                    typename SubExpr2::field_type>::
                                               StandardType,
                                               typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator !=(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          InequalCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             LessThanCmp<GPUWalk,
                         typename Operand1::GPUWalkType,
                         typename Operand2::GPUWalkType,
                         FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          LessThanCmp<ResizePrep,
                      typename Operand1::ResizePrepType,
                      typename Operand2::ResizePrepType,
                      FieldType> typedef ResizePrepType;
          LessThanCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType,
                      FieldType> typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanCmp<Resize,
                      typename Operand1::ResizeType,
                      typename Operand2::ResizeType,
                      FieldType> typedef ResizeType;
          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType,
                      FieldType> typedef SeqWalkType;
          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() < operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                typename Standardize<SubExpr1,
                                                                     typename SubExpr1::field_type>::
                                                StandardType,
                                                typename Standardize<SubExpr2,
                                                                     typename SubExpr1::field_type>::
                                                StandardType,
                                                typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <(SubExpr1 const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          LessThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                typename Standardize<SubExpr1,
                                                                     typename SubExpr1::field_type>::
                                                StandardType,
                                                NeboScalar<Initial, typename SubExpr1::field_type>,
                                                typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <(SubExpr1 const & arg1,
                                                                              typename SubExpr1::
                                                                              field_type::value_type
                                                                              const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          LessThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial, typename SubExpr2::field_type>,
                                                typename Standardize<SubExpr2,
                                                                     typename SubExpr2::field_type>::
                                                StandardType,
                                                typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator <(typename SubExpr2::
                                                                              field_type::value_type
                                                                              const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          LessThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             LessThanEqualCmp<GPUWalk,
                              typename Operand1::GPUWalkType,
                              typename Operand2::GPUWalkType,
                              FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          LessThanEqualCmp<ResizePrep,
                           typename Operand1::ResizePrepType,
                           typename Operand2::ResizePrepType,
                           FieldType> typedef ResizePrepType;
          LessThanEqualCmp<SeqWalk,
                           typename Operand1::SeqWalkType,
                           typename Operand2::SeqWalkType,
                           FieldType> typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanEqualCmp<Resize,
                           typename Operand1::ResizeType,
                           typename Operand2::ResizeType,
                           FieldType> typedef ResizeType;
          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LessThanEqualCmp<SeqWalk,
                           typename Operand1::SeqWalkType,
                           typename Operand2::SeqWalkType,
                           FieldType> typedef SeqWalkType;
          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() <= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     typename Standardize<SubExpr1,
                                                                          typename SubExpr1::
                                                                          field_type>::StandardType,
                                                     typename Standardize<SubExpr2,
                                                                          typename SubExpr1::
                                                                          field_type>::StandardType,
                                                     typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <=(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          LessThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     typename Standardize<SubExpr1,
                                                                          typename SubExpr1::
                                                                          field_type>::StandardType,
                                                     NeboScalar<Initial,
                                                                typename SubExpr1::field_type>,
                                                     typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator <=(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          LessThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial,
                                                                typename SubExpr2::field_type>,
                                                     typename Standardize<SubExpr2,
                                                                          typename SubExpr2::
                                                                          field_type>::StandardType,
                                                     typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator <=(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          LessThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             GreaterThanCmp<GPUWalk,
                            typename Operand1::GPUWalkType,
                            typename Operand2::GPUWalkType,
                            FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          GreaterThanCmp<ResizePrep,
                         typename Operand1::ResizePrepType,
                         typename Operand2::ResizePrepType,
                         FieldType> typedef ResizePrepType;
          GreaterThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType,
                         FieldType> typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanCmp<Resize,
                         typename Operand1::ResizeType,
                         typename Operand2::ResizeType,
                         FieldType> typedef ResizeType;
          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType,
                         FieldType> typedef SeqWalkType;
          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() > operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   typename Standardize<SubExpr1,
                                                                        typename SubExpr1::
                                                                        field_type>::StandardType,
                                                   typename Standardize<SubExpr2,
                                                                        typename SubExpr1::
                                                                        field_type>::StandardType,
                                                   typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >(SubExpr1 const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          GreaterThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   typename Standardize<SubExpr1,
                                                                        typename SubExpr1::
                                                                        field_type>::StandardType,
                                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                                   typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >(SubExpr1 const & arg1,
                                                                              typename SubExpr1::
                                                                              field_type::value_type
                                                                              const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          GreaterThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                                   typename Standardize<SubExpr2,
                                                                        typename SubExpr2::
                                                                        field_type>::StandardType,
                                                   typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator >(typename SubExpr2::
                                                                              field_type::value_type
                                                                              const & arg1,
                                                                              SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          GreaterThanCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             GreaterThanEqualCmp<GPUWalk,
                                 typename Operand1::GPUWalkType,
                                 typename Operand2::GPUWalkType,
                                 FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          GreaterThanEqualCmp<ResizePrep,
                              typename Operand1::ResizePrepType,
                              typename Operand2::ResizePrepType,
                              FieldType> typedef ResizePrepType;
          GreaterThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType,
                              FieldType> typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanEqualCmp<Resize,
                              typename Operand1::ResizeType,
                              typename Operand2::ResizeType,
                              FieldType> typedef ResizeType;
          GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          GreaterThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType,
                              FieldType> typedef SeqWalkType;
          GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          GreaterThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() >= operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        typename Standardize<SubExpr1,
                                                                             typename SubExpr1::
                                                                             field_type>::
                                                        StandardType,
                                                        typename Standardize<SubExpr2,
                                                                             typename SubExpr1::
                                                                             field_type>::
                                                        StandardType,
                                                        typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >=(SubExpr1 const & arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          GreaterThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        typename Standardize<SubExpr1,
                                                                             typename SubExpr1::
                                                                             field_type>::
                                                        StandardType,
                                                        NeboScalar<Initial,
                                                                   typename SubExpr1::field_type>,
                                                        typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type> operator >=(SubExpr1 const & arg1,
                                                                               typename SubExpr1::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          GreaterThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial,
                                                                   typename SubExpr2::field_type>,
                                                        typename Standardize<SubExpr2,
                                                                             typename SubExpr2::
                                                                             field_type>::
                                                        StandardType,
                                                        typename SubExpr2::field_type>,
                                    typename SubExpr2::field_type> operator >=(typename SubExpr2::
                                                                               field_type::
                                                                               value_type const &
                                                                               arg1,
                                                                               SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          GreaterThanEqualCmp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct AndOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             AndOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          AndOp<ResizePrep,
                typename Operand1::ResizePrepType,
                typename Operand2::ResizePrepType,
                FieldType> typedef ResizePrepType;
          AndOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AndOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AndOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() && operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2>
       inline NeboBooleanExpression<AndOp<Initial,
                                          typename SubBoolExpr1::Expression,
                                          typename SubBoolExpr2::Expression,
                                          typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator &&(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          AndOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(arg2.expr())));
       };

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1>
       inline NeboBooleanExpression<AndOp<Initial,
                                          typename SubBoolExpr1::Expression,
                                          NeboBoolean<Initial, typename SubBoolExpr1::field_type>,
                                          typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator &&(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   bool const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          NeboBoolean<Initial, typename SubBoolExpr1::field_type> typedef Type2;

          AndOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(Type2(arg2))));
       };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboBoolean<Initial, typename SubBoolExpr2::field_type>,
                                          typename SubBoolExpr2::Expression,
                                          typename SubBoolExpr2::field_type>,
                                    typename SubBoolExpr2::field_type> operator &&(bool const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr2::field_type typedef FieldType;

          NeboBoolean<Initial, typename SubBoolExpr2::field_type> typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          AndOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)), Type2(arg2.expr())));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct OrOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<Initial, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             OrOp<GPUWalk, typename Operand1::GPUWalkType, typename Operand2::GPUWalkType, FieldType>
             typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          OrOp<ResizePrep,
               typename Operand1::ResizePrepType,
               typename Operand2::ResizePrepType,
               FieldType> typedef ResizePrepType;
          OrOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Operand1::PossibleValidGhost,
                                       typename Operand2::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(operand1().template init<ValidGhost, Shift>(),
                                 operand2().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(operand1().template resize_prep<ValidGhost>(),
                                    operand2().template resize_prep<ValidGhost>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const {
                return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());
             }
#         endif
          /* __CUDACC__ */;

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<ResizePrep, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          OrOp<Resize, typename Operand1::ResizeType, typename Operand2::ResizeType, FieldType>
          typedef ResizeType;
          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand1().resize(split, location), operand2().resize(split, location));
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<Resize, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          OrOp<SeqWalk, typename Operand1::SeqWalkType, typename Operand2::SeqWalkType, FieldType>
          typedef SeqWalkType;
          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>());
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<SeqWalk, Operand1, Operand2, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() || operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2>
       inline NeboBooleanExpression<OrOp<Initial,
                                         typename SubBoolExpr1::Expression,
                                         typename SubBoolExpr2::Expression,
                                         typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator ||(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          OrOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(arg2.expr())));
       };

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1>
       inline NeboBooleanExpression<OrOp<Initial,
                                         typename SubBoolExpr1::Expression,
                                         NeboBoolean<Initial, typename SubBoolExpr1::field_type>,
                                         typename SubBoolExpr1::field_type>,
                                    typename SubBoolExpr1::field_type> operator ||(SubBoolExpr1
                                                                                   const & arg1,
                                                                                   bool const & arg2) {

          typename SubBoolExpr1::field_type typedef FieldType;

          typename SubBoolExpr1::Expression typedef Type1;

          NeboBoolean<Initial, typename SubBoolExpr1::field_type> typedef Type2;

          OrOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(arg1.expr()), Type2(Type2(arg2))));
       };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboBoolean<Initial, typename SubBoolExpr2::field_type>,
                                         typename SubBoolExpr2::Expression,
                                         typename SubBoolExpr2::field_type>,
                                    typename SubBoolExpr2::field_type> operator ||(bool const & arg1,
                                                                                   SubBoolExpr2
                                                                                   const & arg2) {

          typename SubBoolExpr2::field_type typedef FieldType;

          NeboBoolean<Initial, typename SubBoolExpr2::field_type> typedef Type1;

          typename SubBoolExpr2::Expression typedef Type2;

          OrOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)), Type2(arg2.expr())));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NotOp;

      template<typename Operand, typename FieldType>
       struct NotOp<Initial, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             NotOp<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NotOp<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef ResizePrepType;
          NotOp<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          typename Operand::PossibleValidGhost typedef PossibleValidGhost;
          NotOp(Operand const & operand)
          : operand_(operand)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(operand().template resize_prep<ValidGhost>());
           };
          inline Operand const & operand(void) const { return operand_; };
#         ifdef __CUDACC__
             inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); }
#         endif
          /* __CUDACC__ */;

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct NotOp<ResizePrep, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NotOp<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;
          NotOp(Operand const & operand)
          : operand_(operand)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(operand().resize(split, location));
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct NotOp<Resize, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NotOp<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;
          NotOp(Operand const & operand)
          : operand_(operand)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(operand().template init<Shift>());
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename Operand, typename FieldType>
       struct NotOp<SeqWalk, Operand, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          bool typedef EvalReturnType;
          NotOp(Operand const & operand)
          : operand_(operand)
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return !(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubBoolExpr */
      template<typename SubBoolExpr>
       inline NeboBooleanExpression<NotOp<Initial,
                                          typename SubBoolExpr::Expression,
                                          typename SubBoolExpr::field_type>,
                                    typename SubBoolExpr::field_type> operator !(SubBoolExpr const &
                                                                                 arg) {

          typename SubBoolExpr::field_type typedef FieldType;

          typename SubBoolExpr::Expression typedef Type;

          NotOp<Initial, Type, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(arg.expr())));
       };

#     define BUILD_BINARY_FUNCTION(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                      \
         template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>  \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Initial, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
#            ifdef __CUDACC__                                                                      \
                OBJECT_NAME<GPUWalk,                                                               \
                            typename Operand1::GPUWalkType,                                        \
                            typename Operand2::GPUWalkType,                                        \
                            FieldType> typedef GPUWalkType                                         \
#            endif                                                                                 \
             /* __CUDACC__ */;                                                                     \
             OBJECT_NAME<ResizePrep,                                                               \
                         typename Operand1::ResizePrepType,                                        \
                         typename Operand2::ResizePrepType,                                        \
                         FieldType> typedef ResizePrepType;                                        \
             OBJECT_NAME<SeqWalk,                                                                  \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             typename structured::Minimum<typename Operand1::PossibleValidGhost,                   \
                                          typename Operand2::PossibleValidGhost>::result typedef   \
             PossibleValidGhost;                                                                   \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             template<typename ValidGhost, typename Shift>                                         \
              inline SeqWalkType init(void) const {                                                \
                                                                                                   \
                 return SeqWalkType(operand1().template init<ValidGhost, Shift>(),                 \
                                    operand2().template init<ValidGhost, Shift>());                \
              };                                                                                   \
             template<typename ValidGhost>                                                         \
              inline ResizePrepType resize_prep(void) const {                                      \
                                                                                                   \
                 return ResizePrepType(operand1().template resize_prep<ValidGhost>(),              \
                                       operand2().template resize_prep<ValidGhost>());             \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
#            ifdef __CUDACC__                                                                      \
                inline GPUWalkType gpu_init(void) const {                                          \
                   return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());               \
                }                                                                                  \
#            endif                                                                                 \
             /* __CUDACC__ */;                                                                     \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<ResizePrep, Operand1, Operand2, FieldType> {                          \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize,                                                                   \
                         typename Operand1::ResizeType,                                            \
                         typename Operand2::ResizeType,                                            \
                         FieldType> typedef ResizeType;                                            \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             inline ResizeType resize(structured::IntVec const & split,                            \
                                      structured::IntVec const & location) const {                 \
                                                                                                   \
                return ResizeType(operand1().resize(split, location),                              \
                                  operand2().resize(split, location));                             \
             };                                                                                    \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Resize, Operand1, Operand2, FieldType> {                              \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk,                                                                  \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             template<typename Shift>                                                              \
              inline SeqWalkType init(void) const {                                                \
                 return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>()); \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<SeqWalk, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             inline void next(void) { operand1_.next(); operand2_.next(); };                       \
             inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); }; \
             inline bool has_length(void) const {                                                  \
                return (operand1_.has_length() || operand2_.has_length());                         \
             };                                                                                    \
             inline EvalReturnType eval(void) const {                                              \
                return INTERNAL_NAME(operand1_.eval(), operand2_.eval());                          \
             };                                                                                    \
                                                                                                   \
            private:                                                                               \
             Operand1 operand1_;                                                                   \
             Operand2 operand2_;                                                                   \
         };                                                                                        \
                                                                                                   \
         /* SubExpr X SubExpr */                                                                   \
         template<typename SubExpr1, typename SubExpr2>                                            \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };                                                                                       \
                                                                                                   \
         /* SubExpr X Scalar */                                                                    \
         template<typename SubExpr1>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            NeboScalar<Initial, typename SubExpr1::field_type>,    \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             typename SubExpr1::   \
                                                                             field_type::value_type \
                                                                             const & arg2) {       \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;                     \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Type2(arg2))));                                    \
          };                                                                                       \
                                                                                                   \
         /* Scalar X SubExpr */                                                                    \
         template<typename SubExpr2>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            NeboScalar<Initial, typename SubExpr2::field_type>,    \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr2::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr2::field_type>,                        \
                                typename SubExpr2::field_type> EXTERNAL_NAME(typename SubExpr2::   \
                                                                             field_type::value_type \
                                                                             const & arg1,         \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr2::field_type typedef FieldType;                                      \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;                     \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Type1(arg1)),                                      \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };

#     define BUILD_BINARY_OPERATOR(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                      \
         template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>  \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Initial, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
#            ifdef __CUDACC__                                                                      \
                OBJECT_NAME<GPUWalk,                                                               \
                            typename Operand1::GPUWalkType,                                        \
                            typename Operand2::GPUWalkType,                                        \
                            FieldType> typedef GPUWalkType                                         \
#            endif                                                                                 \
             /* __CUDACC__ */;                                                                     \
             OBJECT_NAME<ResizePrep,                                                               \
                         typename Operand1::ResizePrepType,                                        \
                         typename Operand2::ResizePrepType,                                        \
                         FieldType> typedef ResizePrepType;                                        \
             OBJECT_NAME<SeqWalk,                                                                  \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             typename structured::Minimum<typename Operand1::PossibleValidGhost,                   \
                                          typename Operand2::PossibleValidGhost>::result typedef   \
             PossibleValidGhost;                                                                   \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             template<typename ValidGhost, typename Shift>                                         \
              inline SeqWalkType init(void) const {                                                \
                                                                                                   \
                 return SeqWalkType(operand1().template init<ValidGhost, Shift>(),                 \
                                    operand2().template init<ValidGhost, Shift>());                \
              };                                                                                   \
             template<typename ValidGhost>                                                         \
              inline ResizePrepType resize_prep(void) const {                                      \
                                                                                                   \
                 return ResizePrepType(operand1().template resize_prep<ValidGhost>(),              \
                                       operand2().template resize_prep<ValidGhost>());             \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
#            ifdef __CUDACC__                                                                      \
                inline GPUWalkType gpu_init(void) const {                                          \
                   return GPUWalkType(operand1().gpu_init(), operand2().gpu_init());               \
                }                                                                                  \
#            endif                                                                                 \
             /* __CUDACC__ */;                                                                     \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<ResizePrep, Operand1, Operand2, FieldType> {                          \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize,                                                                   \
                         typename Operand1::ResizeType,                                            \
                         typename Operand2::ResizeType,                                            \
                         FieldType> typedef ResizeType;                                            \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             inline ResizeType resize(structured::IntVec const & split,                            \
                                      structured::IntVec const & location) const {                 \
                                                                                                   \
                return ResizeType(operand1().resize(split, location),                              \
                                  operand2().resize(split, location));                             \
             };                                                                                    \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Resize, Operand1, Operand2, FieldType> {                              \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk,                                                                  \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             template<typename Shift>                                                              \
              inline SeqWalkType init(void) const {                                                \
                 return SeqWalkType(operand1().template init<Shift>(), operand2().template init<Shift>()); \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<SeqWalk, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(Operand1 const & operand1, Operand2 const & operand2)                     \
             : operand1_(operand1), operand2_(operand2)                                            \
             {};                                                                                   \
             inline void next(void) { operand1_.next(); operand2_.next(); };                       \
             inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); }; \
             inline bool has_length(void) const {                                                  \
                return (operand1_.has_length() || operand2_.has_length());                         \
             };                                                                                    \
             inline EvalReturnType eval(void) const {                                              \
                return (operand1_.eval() INTERNAL_NAME operand2_.eval());                          \
             };                                                                                    \
                                                                                                   \
            private:                                                                               \
             Operand1 operand1_;                                                                   \
             Operand2 operand2_;                                                                   \
         };                                                                                        \
                                                                                                   \
         /* SubExpr X SubExpr */                                                                   \
         template<typename SubExpr1, typename SubExpr2>                                            \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };                                                                                       \
                                                                                                   \
         /* SubExpr X Scalar */                                                                    \
         template<typename SubExpr1>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            NeboScalar<Initial, typename SubExpr1::field_type>,    \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             typename SubExpr1::   \
                                                                             field_type::value_type \
                                                                             const & arg2) {       \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;                     \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Type2(arg2))));                                    \
          };                                                                                       \
                                                                                                   \
         /* Scalar X SubExpr */                                                                    \
         template<typename SubExpr2>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            NeboScalar<Initial, typename SubExpr2::field_type>,    \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr2::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr2::field_type>,                        \
                                typename SubExpr2::field_type> EXTERNAL_NAME(typename SubExpr2::   \
                                                                             field_type::value_type \
                                                                             const & arg1,         \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr2::field_type typedef FieldType;                                      \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;                     \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Type1(arg1)),                                      \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };

#     define BUILD_UNARY_FUNCTION(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                       \
         template<typename CurrentMode, typename Operand, typename FieldType>                      \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand, typename FieldType>                                            \
          struct OBJECT_NAME<Initial, Operand, FieldType> {                                        \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
#            ifdef __CUDACC__                                                                      \
                OBJECT_NAME<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef GPUWalkType \
#            endif                                                                                 \
             /* __CUDACC__ */;                                                                     \
             OBJECT_NAME<ResizePrep, typename Operand::ResizePrepType, FieldType> typedef          \
             ResizePrepType;                                                                       \
             OBJECT_NAME<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;   \
             typename Operand::PossibleValidGhost typedef PossibleValidGhost;                      \
             OBJECT_NAME(Operand const & operand)                                                  \
             : operand_(operand)                                                                   \
             {};                                                                                   \
             template<typename ValidGhost, typename Shift>                                         \
              inline SeqWalkType init(void) const {                                                \
                 return SeqWalkType(operand().template init<ValidGhost, Shift>());                 \
              };                                                                                   \
             template<typename ValidGhost>                                                         \
              inline ResizePrepType resize_prep(void) const {                                      \
                 return ResizePrepType(operand().template resize_prep<ValidGhost>());              \
              };                                                                                   \
             inline Operand const & operand(void) const { return operand_; };                      \
#            ifdef __CUDACC__                                                                      \
                inline GPUWalkType gpu_init(void) const { return GPUWalkType(operand().gpu_init()); } \
#            endif                                                                                 \
             /* __CUDACC__ */;                                                                     \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename Operand, typename FieldType>                                            \
          struct OBJECT_NAME<ResizePrep, Operand, FieldType> {                                     \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize, typename Operand::ResizeType, FieldType> typedef ResizeType;      \
             OBJECT_NAME(Operand const & operand)                                                  \
             : operand_(operand)                                                                   \
             {};                                                                                   \
             inline ResizeType resize(structured::IntVec const & split,                            \
                                      structured::IntVec const & location) const {                 \
                return ResizeType(operand().resize(split, location));                              \
             };                                                                                    \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename Operand, typename FieldType>                                            \
          struct OBJECT_NAME<Resize, Operand, FieldType> {                                         \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef SeqWalkType;   \
             OBJECT_NAME(Operand const & operand)                                                  \
             : operand_(operand)                                                                   \
             {};                                                                                   \
             template<typename Shift>                                                              \
              inline SeqWalkType init(void) const {                                                \
                 return SeqWalkType(operand().template init<Shift>());                             \
              };                                                                                   \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename Operand, typename FieldType>                                            \
          struct OBJECT_NAME<SeqWalk, Operand, FieldType> {                                        \
                                                                                                   \
            public:                                                                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(Operand const & operand)                                                  \
             : operand_(operand)                                                                   \
             {};                                                                                   \
             inline void next(void) { operand_.next(); };                                          \
             inline bool at_end(void) const { return (operand_.at_end()); };                       \
             inline bool has_length(void) const { return (operand_.has_length()); };               \
             inline EvalReturnType eval(void) const { return INTERNAL_NAME(operand_.eval()); };    \
                                                                                                   \
            private:                                                                               \
             Operand operand_;                                                                     \
         };                                                                                        \
                                                                                                   \
         /* SubExpr */                                                                             \
         template<typename SubExpr>                                                                \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr,                          \
                                                                 typename SubExpr::field_type>::   \
                                            StandardType,                                          \
                                            typename SubExpr::field_type>,                         \
                                typename SubExpr::field_type> EXTERNAL_NAME(SubExpr const & arg) { \
                                                                                                   \
             typename SubExpr::field_type typedef FieldType;                                       \
                                                                                                   \
             typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type; \
                                                                                                   \
             OBJECT_NAME<Initial, Type, FieldType> typedef ReturnType;                             \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg)))); \
          };

      struct NeboNil {

         NeboNil typedef ResizePrepType;

         NeboNil typedef SeqWalkType;

         structured::InfiniteGhostData typedef PossibleValidGhost;

         NeboNil() {};
      };

      template<typename CurrentMode, typename Test, typename Expr, typename FieldType>
       struct NeboClause;

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Initial, Test, Expr, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboClause<ResizePrep,
                     typename Test::ResizePrepType,
                     typename Expr::ResizePrepType,
                     FieldType> typedef ResizePrepType;
          NeboClause<SeqWalk, typename Test::SeqWalkType, typename Expr::SeqWalkType, FieldType>
          typedef SeqWalkType;
          typename structured::Minimum<typename Test::PossibleValidGhost,
                                       typename Expr::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          NeboClause(Test const & t, Expr const & e)
          : test_(t), expr_(e)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(test().template init<ValidGhost, Shift>(),
                                 expr().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(test().template resize_prep<ValidGhost>(),
                                    expr().template resize_prep<ValidGhost>());
           };
          inline Test const & test(void) const { return test_; };
          inline Expr const & expr(void) const { return expr_; };

         private:
          Test const test_;
          Expr const expr_;
      };

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<ResizePrep, Test, Expr, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboClause<Resize, typename Test::ResizeType, typename Expr::ResizeType, FieldType>
          typedef ResizeType;
          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(test().resize(split, location), expr().resize(split, location));
          };
          inline Test const & test(void) const { return test_; };
          inline Expr const & expr(void) const { return expr_; };

         private:
          Test const test_;
          Expr const expr_;
      };

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Resize, Test, Expr, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboClause<SeqWalk, typename Test::SeqWalkType, typename Expr::SeqWalkType, FieldType>
          typedef SeqWalkType;
          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(test().template init<Shift>(), expr().template init<Shift>());
           };
          inline Test const & test(void) const { return test_; };
          inline Expr const & expr(void) const { return expr_; };

         private:
          Test const test_;
          Expr const expr_;
      };

      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<SeqWalk, Test, Expr, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {};
          inline void next(void) { test_.next(); expr_.next(); };
          inline bool at_end(void) const { return (test_.at_end() || expr_.at_end()); };
          inline bool has_length(void) const { return (test_.has_length() || expr_.has_length()); };
          inline bool const check(void) const { return test_.eval(); };
          inline AtomicType const eval(void) const { return expr_.eval(); };

         private:
          Test test_;
          Expr expr_;
      };

      template<typename CurrentMode, typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Initial, ClauseType, Otherwise, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboCond<ResizePrep,
                   typename ClauseType::ResizePrepType,
                   typename Otherwise::ResizePrepType,
                   FieldType> typedef ResizePrepType;
          NeboCond<SeqWalk,
                   typename ClauseType::SeqWalkType,
                   typename Otherwise::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          typename structured::Minimum<typename ClauseType::PossibleValidGhost,
                                       typename Otherwise::PossibleValidGhost>::result typedef
          PossibleValidGhost;
          NeboCond(ClauseType const & c, Otherwise const & e)
          : clause_(c), otherwise_(e)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(clause().template init<ValidGhost, Shift>(),
                                 otherwise().template init<ValidGhost, Shift>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {

              return ResizePrepType(clause().template resize_prep<ValidGhost>(),
                                    otherwise().template resize_prep<ValidGhost>());
           };
          inline ClauseType const & clause(void) const { return clause_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          ClauseType const clause_;
          Otherwise const otherwise_;
      };

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<ResizePrep, ClauseType, Otherwise, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboCond<Resize,
                   typename ClauseType::ResizeType,
                   typename Otherwise::ResizeType,
                   FieldType> typedef ResizeType;
          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(clause().resize(split, location), otherwise().resize(split, location));
          };
          inline ClauseType const & clause(void) const { return clause_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          ClauseType const clause_;
          Otherwise const otherwise_;
      };

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Resize, ClauseType, Otherwise, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboCond<SeqWalk,
                   typename ClauseType::SeqWalkType,
                   typename Otherwise::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(clause().template init<Shift>(), otherwise().template init<Shift>());
           };
          inline ClauseType const & clause(void) const { return clause_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          ClauseType const clause_;
          Otherwise const otherwise_;
      };

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<SeqWalk, ClauseType, Otherwise, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {};
          inline void next(void) { clause_.next(); otherwise_.next(); };
          inline bool at_end(void) const { return (clause_.at_end() || otherwise_.at_end()); };
          inline bool has_length(void) const {
             return (clause_.has_length() || otherwise_.has_length());
          };
          inline AtomicType const eval(void) const {
             return clause_.check() ? clause_.eval() : otherwise_.eval();
          };

         private:
          ClauseType clause_;
          Otherwise otherwise_;
      };

      struct NeboSimpleClause {

         public:
          NeboSimpleClause(bool b, double d)
          : b_(b), d_(d)
          {};
          inline bool check(void) const { return b_; };
          inline double eval(void) const { return d_; };
          template<typename FieldType>
           struct Convert {

             NeboBoolean<Initial, FieldType> typedef Boolean;

             NeboScalar<Initial, FieldType> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef Converted;

             static inline Converted convert(bool b, double d) {
                return Converted(Boolean(b), Scalar(d));
             };
          };

         private:
          bool const b_;
          double const d_;
      };

      struct NeboSimpleFinalClause {

         public:
          NeboSimpleFinalClause(double d)
          : d_(d)
          {};
          inline double eval(void) const { return d_; };

         private:
          double const d_;
      };

      template<typename Otherwise>
       struct NeboSimpleCond {

         public:
          NeboSimpleCond(NeboSimpleClause c, Otherwise otherwise)
          : c_(c), otherwise_(otherwise)
          {};
          inline double eval(void) const { return c_.check() ? c_.eval() : otherwise_.eval(); };
          template<typename FieldType>
           struct Convert {

             NeboSimpleClause::template Convert<FieldType> typedef ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             typename Otherwise::template Convert<FieldType> typedef ConvertingList;

             typename ConvertingList::Converted typedef ConvertedList;

             NeboCond<Initial, ConvertedClause, ConvertedList, FieldType> typedef Converted;

             static inline Converted convert(NeboSimpleClause c, Otherwise o) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()), o.template convert<FieldType>());
             };
          };
          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {

              Convert<FieldType> typedef Convert;

              return Convert::convert(clause(), otherwise());
           };
          inline NeboSimpleClause const & clause(void) const { return c_; };
          inline Otherwise const & otherwise(void) const { return otherwise_; };

         private:
          NeboSimpleClause const c_;
          Otherwise const otherwise_;
      };

      template<>
       struct NeboSimpleCond<NeboNil> {

         public:
          NeboSimpleCond(NeboSimpleClause c, NeboNil nil)
          : c_(c)
          {};
          template<typename FieldType>
           struct Convert {

             NeboSimpleClause::template Convert<FieldType> typedef ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             NeboNil typedef ConvertedList;

             NeboCond<Initial, ConvertedClause, ConvertedList, FieldType> typedef Converted;

             static inline Converted convert(NeboSimpleClause c) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()), NeboNil());
             };
          };
          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {

              Convert<FieldType> typedef Convert;

              return Convert::convert(clause());
           };
          inline NeboSimpleClause const & clause(void) const { return c_; };
          inline NeboNil otherwise(void) const { return NeboNil(); };

         private:
          NeboSimpleClause const c_;
      };

      template<typename List>
       struct CondBuilder;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct CondBuilder<NeboCond<Initial, ClauseType, Otherwise, FieldType> > {

         public:
          NeboCond<Initial, ClauseType, Otherwise, FieldType>  typedef List;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseListRecursive;
          template<typename PreceedingResult>
           struct ReverseListRecursive<NeboNil, PreceedingResult> {

             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil nil, PreceedingResult r) { return r; };
          };
          template<typename Next, typename Field, typename Following, typename PreceedingResult>
           struct ReverseListRecursive<NeboCond<Initial, Next, Following, Field>, PreceedingResult> {

             NeboCond<Initial, Next, Following, Field> typedef Remaining;

             NeboCond<Initial, Next, PreceedingResult, Field> typedef NewResult;

             ReverseListRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining l, PreceedingResult r) {
                return InternalCall::reverse(l.otherwise(), NewResult(l.clause(), r));
             };
          };
          List list_;

         public:
          CondBuilder(NeboCond<Initial, ClauseType, Otherwise, FieldType> l)
          : list_(l)
          {};
          template<typename Final>
           struct ReverseList;
          template<typename Final>
           struct ReverseList {

             ReverseListRecursive<List, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(List l, Final f) { return InternalCall::reverse(l, f); };
          };
          template<typename Final>
           inline typename ReverseList<Final>::Result reverse(Final f) {

              ReverseList<Final> typedef InternalCall;

              return InternalCall::reverse(list_, f);
           };
          inline NeboExpression<typename ReverseList<NeboScalar<Initial, FieldType> >::Result,
                                FieldType> operator ()(double d) {

             NeboScalar<Initial, FieldType> typedef Scalar;

             ReverseList<Scalar> typedef Reverser;

             typename Reverser::Result typedef Reversed;

             NeboExpression<Reversed, FieldType> typedef Result;

             return Result(reverse(Scalar(d)));
          };
          template<typename Expr>
           inline NeboExpression<typename ReverseList<typename Standardize<Expr, FieldType>::
                                                      StandardType>::Result,
                                 FieldType> operator ()(Expr e) {

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef FinalType;

              ReverseList<FinalType> typedef Reverser;

              typename Reverser::Result typedef Reversed;

              NeboExpression<Reversed, FieldType> typedef Result;

              return Result(reverse(Standardize::standardType(e)));
           };
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboBoolean<Initial, FieldType>,
                                                 NeboScalar<Initial, FieldType>,
                                                 FieldType>,
                                      List,
                                      FieldType> > operator ()(bool b, double d) {

             NeboBoolean<Initial, FieldType> typedef Boolean;

             NeboScalar<Initial, FieldType> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef NewClause;

             NeboCond<Initial, NewClause, List, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NewClause(Boolean(b), Scalar(d)), list_));
          };
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboBoolean<Initial, FieldType>,
                                                  typename Standardize<Expr, FieldType>::
                                                  StandardType,
                                                  FieldType>,
                                       List,
                                       FieldType> > operator ()(bool b, Expr e) {

              NeboBoolean<Initial, FieldType> typedef Boolean;

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, Boolean, StandardType, FieldType> typedef Clause;

              NeboCond<Initial, Clause, List, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Standardize::standardType(e)), list_));
           };
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial, FieldType>,
                                                  FieldType>,
                                       List,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType> nb,
                                                                double d) {

              NeboScalar<Initial, FieldType> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef NewClause;

              NeboCond<Initial, NewClause, List, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(NewClause(nb.expr(), Scalar(d)), list_));
           };
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  typename Standardize<Expr, FieldType>::
                                                  StandardType,
                                                  FieldType>,
                                       List,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      typename Expr::
                                                                                      field_type> nb,
                                                                Expr e) {

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, BoolExpr, StandardType, FieldType> typedef Clause;

              NeboCond<Initial, Clause, List, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Standardize::standardType(e)), list_));
           };
      };

      template<typename Otherwise>
       struct CondBuilder<NeboSimpleCond<Otherwise> > {

         public:
          NeboSimpleCond<Otherwise>  typedef List;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseListRecursive;
          template<typename PreceedingResult>
           struct ReverseListRecursive<NeboNil, PreceedingResult> {

             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil nil, PreceedingResult r) { return r; };
          };
          template<typename Following, typename PreceedingResult>
           struct ReverseListRecursive<NeboSimpleCond<Following>, PreceedingResult> {

             NeboSimpleCond<Following> typedef Remaining;

             NeboSimpleCond<PreceedingResult> typedef NewResult;

             ReverseListRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining l, PreceedingResult r) {
                return InternalCall::reverse(l.otherwise(), NewResult(l.clause(), r));
             };
          };
          List list_;

         public:
          CondBuilder(NeboSimpleCond<Otherwise> l)
          : list_(l)
          {};
          template<typename Final>
           struct ReverseList;
          template<typename Final>
           struct ReverseList {

             ReverseListRecursive<List, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(List l, Final f) { return InternalCall::reverse(l, f); };
          };
          template<typename Final>
           inline typename ReverseList<Final>::Result reverse(Final f) {

              ReverseList<Final> typedef InternalCall;

              return InternalCall::reverse(list_, f);
           };
          inline double operator ()(double d) { return reverse(NeboSimpleFinalClause(d)).eval(); };
          template<typename Expr>
           inline NeboExpression<typename CondBuilder<typename List::template Convert<typename Expr::
                                                                                      field_type>::
                                                      Converted>::template ReverseList<typename
                                                                                       Standardize<Expr,
                                                                                                   typename
                                                                                                   Expr::
                                                                                                   field_type>::
                                                                                       StandardType>::
                                 Result,
                                 typename Expr::field_type> operator ()(Expr e) {

              typename Expr::field_type typedef FieldType;

              typename List::template Convert<typename Expr::field_type>::Converted typedef
              Converted;

              CondBuilder<Converted> typedef NewCondBuilder;

              return NewCondBuilder(list_.template convert<FieldType>())(e);
           };
          inline CondBuilder<NeboSimpleCond<List> > operator ()(bool b, double d) {

             NeboSimpleCond<List> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NeboSimpleClause(b, d), list_));
          };
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboBoolean<Initial, typename Expr::field_type>,
                                                  typename Standardize<Expr,
                                                                       typename Expr::field_type>::
                                                  StandardType,
                                                  typename Expr::field_type>,
                                       typename List::template Convert<typename Expr::field_type>::
                                       Converted,
                                       typename Expr::field_type> > operator ()(bool b, Expr e) {

              typename Expr::field_type typedef FieldType;

              NeboBoolean<Initial, FieldType> typedef Boolean;

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, Boolean, StandardType, FieldType> typedef Clause;

              typename List::template Convert<typename Expr::field_type>::Converted typedef Previous;

              NeboCond<Initial, Clause, Previous, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Standardize::standardType(e)),
                                     list_.template convert<FieldType>()));
           };
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial, FieldType>,
                                                  FieldType>,
                                       typename List::template Convert<FieldType>::Converted,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType> nb,
                                                                double d) {

              NeboScalar<Initial, FieldType> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              typename List::template Convert<FieldType>::Converted typedef Previous;

              NeboCond<Initial, Clause, Previous, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), list_.template convert<FieldType>()));
           };
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  typename Standardize<Expr,
                                                                       typename Expr::field_type>::
                                                  StandardType,
                                                  typename Expr::field_type>,
                                       typename List::template Convert<typename Expr::field_type>::
                                       Converted,
                                       typename Expr::field_type> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                                      typename
                                                                                                      Expr::
                                                                                                      field_type>
                                                                                nb,
                                                                                Expr e) {

              typename Expr::field_type typedef FieldType;

              Standardize<Expr, FieldType> typedef Standardize;

              typename Standardize::StandardType typedef StandardType;

              NeboClause<Initial, BoolExpr, StandardType, FieldType> typedef Clause;

              typename List::template Convert<typename Expr::field_type>::Converted typedef Previous;

              NeboCond<Initial, Clause, Previous, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Standardize::standardType(e)),
                                     list_.template convert<FieldType>()));
           };
      };

      template<>
       struct CondBuilder<NeboNil> {

         public:
          CondBuilder() {};
      };

      inline double cond(double d) { return d; };

      template<typename Expr>
       inline typename Standardize<Expr, typename Expr::field_type>::StandardTerm cond(Expr e) {

          typename Expr::field_type typedef FieldType;

          Standardize<Expr, FieldType> typedef Standardize;

          return Standardize::standardTerm(e);
       };

      inline CondBuilder<NeboSimpleCond<NeboNil> > cond(bool b, double d) {

         NeboSimpleCond<NeboNil> typedef Cond;

         CondBuilder<Cond> typedef ReturnType;

         return ReturnType(Cond(NeboSimpleClause(b, d), NeboNil()));
      };

      template<typename Expr>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboBoolean<Initial, typename Expr::field_type>,
                                              typename Standardize<Expr, typename Expr::field_type>::
                                              StandardType,
                                              typename Expr::field_type>,
                                   NeboNil,
                                   typename Expr::field_type> > cond(bool b, Expr e) {

          typename Expr::field_type typedef FieldType;

          NeboBoolean<Initial, FieldType> typedef Boolean;

          Standardize<Expr, FieldType> typedef Standardize;

          typename Standardize::StandardType typedef StandardType;

          NeboClause<Initial, Boolean, StandardType, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), Standardize::standardType(e)), NeboNil()));
       };

      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboScalar<Initial, FieldType>,
                                              FieldType>,
                                   NeboNil,
                                   FieldType> > cond(NeboBooleanExpression<BoolExpr, FieldType> nb,
                                                     double d) {

          NeboScalar<Initial, FieldType> typedef Scalar;

          NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), NeboNil()));
       };

      template<typename BoolExpr, typename Expr>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              typename Standardize<Expr, typename Expr::field_type>::
                                              StandardType,
                                              typename Expr::field_type>,
                                   NeboNil,
                                   typename Expr::field_type> > cond(NeboBooleanExpression<BoolExpr,
                                                                                           typename
                                                                                           Expr::
                                                                                           field_type>
                                                                     nb,
                                                                     Expr e) {

          typename Expr::field_type typedef FieldType;

          Standardize<Expr, FieldType> typedef Standardize;

          typename Standardize::StandardType typedef StandardType;

          NeboClause<Initial, BoolExpr, StandardType, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Standardize::standardType(e)), NeboNil()));
       };

#     define nebo_cond cond//;

      template<typename CurrentMode, typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint;

      template<typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint<Initial, Point, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
#         ifdef __CUDACC__
             NeboStencilPoint<GPUWalk, Point, typename Arg::GPUWalkType, FieldType> typedef
             GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboStencilPoint<ResizePrep, Point, typename Arg::ResizePrepType, FieldType> typedef
          ResizePrepType;
          NeboStencilPoint<SeqWalk, Point, typename Arg::SeqWalkType, FieldType> typedef SeqWalkType;
          typename structured::Invalidate<typename Arg::PossibleValidGhost, Point>::result typedef
          PossibleValidGhost;
          NeboStencilPoint(Arg const & a)
          : arg_(a)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(arg().template init<ValidGhost,
                                                     typename structured::Add<Shift, Point>::result>());
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(arg().template resize_prep<ValidGhost>());
           };
          inline Arg const & arg(void) const { return arg_; };

         private:
          Arg const arg_;
      };

      template<typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint<ResizePrep, Point, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboStencilPoint<Resize, Point, typename Arg::ResizeType, FieldType> typedef ResizeType;
          NeboStencilPoint(Arg const & a)
          : arg_(a)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(arg().resize(split, location));
          };
          inline Arg const & arg(void) const { return arg_; };

         private:
          Arg const arg_;
      };

      template<typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint<Resize, Point, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboStencilPoint<SeqWalk, Point, typename Arg::SeqWalkType, FieldType> typedef SeqWalkType;
          NeboStencilPoint(Arg const & a)
          : arg_(a)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(arg().template init<typename structured::Add<Shift, Point>::result>());
           };
          inline Arg const & arg(void) const { return arg_; };

         private:
          Arg const arg_;
      };

      template<typename Point, typename Arg, typename FieldType>
       struct NeboStencilPoint<SeqWalk, Point, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboStencilPoint(Arg const & a)
          : arg_(a)
          {};
          inline void next(void) { arg_.next(); };
          inline bool at_end(void) const { return arg_.at_end(); };
          inline bool has_length(void) const { return arg_.has_length(); };
          inline AtomicType const eval(void) const { return arg_.eval(); };

         private:
          Arg arg_;
      };

      template<int Length>
       struct NeboStencilCoefList {

         public:
          NeboStencilCoefList(NeboStencilCoefList<Length - 1> const & l, double c)
          : list_(l), coef_(c)
          {};
          inline NeboStencilCoefList<Length + 1> const operator()(double c) const {
             return NeboStencilCoefList<Length + 1>(*this, c);
          };
          inline double const coef(void) const { return coef_; };
          inline NeboStencilCoefList<Length - 1> const list(void) const { return list_; };

         private:
          NeboStencilCoefList<Length - 1> const list_;
          double const coef_;
      };

      template<>
       struct NeboStencilCoefList<1> {

         public:
          NeboStencilCoefList(double c)
          : coef_(c)
          {};
          inline NeboStencilCoefList<2> const operator()(double c) const {
             return NeboStencilCoefList<2>(*this, c);
          };
          inline double const coef(void) const { return coef_; };

         private:
          double const coef_;
      };

      inline NeboStencilCoefList<1> const build_coef_list(double const c) {
         return NeboStencilCoefList<1>(c);
      };

      inline NeboStencilCoefList<2> const build_two_point_coef_list(double const c1, double const c2) {
         return NeboStencilCoefList<1>(c1)(c2);
      };

      inline NeboStencilCoefList<4> const build_four_point_coef_list(double const c1,
                                                                     double const c2,
                                                                     double const c3,
                                                                     double const c4) {
         return NeboStencilCoefList<1>(c1)(c2)(c3)(c4);
      };

      template<typename PointType, typename ListType>
       struct NeboStencilPointList {

         public:
          PointType typedef Point;
          ListType typedef List;
          NeboStencilPointList<Point, List> typedef MyType;
          enum {length = 1 + List::length};
          template<typename NewPoint>
           struct AddPoint { NeboStencilPointList<NewPoint, MyType> typedef Result; };
          template<typename GivenPossibleValidGhost>
           struct PossibleGhost {

             typename structured::Invalidate<GivenPossibleValidGhost, Point>::result typedef
             CurrentPossibleValidGhost;

             typename List::template PossibleGhost<GivenPossibleValidGhost> typedef
             EarlierPointsPossibleGhost;

             typename EarlierPointsPossibleGhost::Result typedef EarlierPointsPossibleValidGhost;

             typename structured::Minimum<CurrentPossibleValidGhost, EarlierPointsPossibleValidGhost>::
             result typedef Result;
          };
          template<typename ArgPreSeqWalk, typename DestType>
           struct ConstructExpr {

             NeboScalar<SeqWalk, DestType> typedef Coef;

             typename ArgPreSeqWalk::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef, DestType> typedef MultiplyType;

             typename List::template ConstructExpr<ArgPreSeqWalk, DestType> typedef
             EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<SeqWalk, EarlierPointsResult, MultiplyType, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefList<length> const & coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template in_sq_construct<ValidGhost, Shift>(arg,
                                                                                              coefs.list()),
                               MultiplyType(arg.template init<ValidGhost, NewShift>(), Coef(coefs.coef())));
              };

             template<typename Shift>
              static inline Result const rs_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefList<length> const & coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(EarlierPointsType::template rs_sq_construct<Shift>(arg, coefs.list()),
                               MultiplyType(arg.template init<NewShift>(), Coef(coefs.coef())));
              };
          };
      };

      template<typename PointType>
       struct NeboStencilPointList<PointType, NeboNil> {

         public:
          PointType typedef Point;
          NeboNil typedef List;
          NeboStencilPointList<Point, List> typedef MyType;
          enum {length = 1};
          template<typename NewPoint>
           struct AddPoint { NeboStencilPointList<NewPoint, MyType> typedef Result; };
          template<typename GivenPossibleValidGhost>
           struct PossibleGhost {
             typename structured::Invalidate<GivenPossibleValidGhost, Point>::result typedef Result;
          };
          template<typename ArgPreSeqWalk, typename DestType>
           struct ConstructExpr {

             NeboScalar<SeqWalk, DestType> typedef Coef;

             typename ArgPreSeqWalk::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef, DestType> typedef Result;

             template<typename ValidGhost, typename Shift>
              static inline Result const in_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefList<1> const & coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template init<ValidGhost, NewShift>(), Coef(coefs.coef()));
              };

             template<typename Shift>
              static inline Result const rs_sq_construct(ArgPreSeqWalk const & arg,
                                                         NeboStencilCoefList<1> const & coefs) {

                 typename structured::Add<Shift, Point>::result typedef NewShift;

                 return Result(arg.template init<NewShift>(), Coef(coefs.coef()));
              };
          };
      };

      template<typename First>
       struct BuildStencilPointList { NeboStencilPointList<First, NeboNil> typedef Result; };

      template<typename First, typename Second>
       struct BuildTwoPointList {

         typename BuildStencilPointList<First>::Result typedef FirstPoint;

         typename FirstPoint::template AddPoint<Second>::Result typedef Result;
      };

      template<typename First, typename Second, typename Third, typename Fourth>
       struct BuildFourPointList {

         typename BuildStencilPointList<First>::Result typedef FirstPoint;

         typename FirstPoint::template AddPoint<Second>::Result typedef SecondFirstList;

         typename SecondFirstList::template AddPoint<Third>::Result typedef ThirdSecondFirstList;

         typename ThirdSecondFirstList::template AddPoint<Fourth>::Result typedef Result;
      };

      template<typename CurrentMode, typename Pts, typename Arg, typename FieldType>
       struct NeboStencil;

      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Initial, Pts, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          enum {numPts = Pts::length};
          NeboStencilCoefList<numPts> typedef Coefs;
          typename Pts::template ConstructExpr<Arg, FieldType> typedef ConstructExpr;
          typename ConstructExpr::Result typedef ArgSeqWalkType;
#         ifdef __CUDACC__
             NeboStencil<GPUWalk, Pts, typename Arg::GPUWalkType, FieldType> typedef GPUWalkType
#         endif
          /* __CUDACC__ */;
          NeboStencil<ResizePrep, Pts, typename Arg::ResizePrepType, FieldType> typedef
          ResizePrepType;
          NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef SeqWalkType;
          typename Pts::template PossibleGhost<typename Arg::PossibleValidGhost>::Result typedef
          PossibleValidGhost;
          NeboStencil(Arg const & a, Coefs const & coefs)
          : arg_(a), coefs_(coefs)
          {};
          template<typename ValidGhost, typename Shift>
           inline SeqWalkType init(void) const {

              return SeqWalkType(ConstructExpr::template in_sq_construct<ValidGhost, Shift>(arg(),
                                                                                            coefs()));
           };
          template<typename ValidGhost>
           inline ResizePrepType resize_prep(void) const {
              return ResizePrepType(arg().template resize_prep<ValidGhost>(), coefs());
           };
          inline Arg const & arg(void) const { return arg_; };
          inline Coefs const & coefs(void) const { return coefs_; };

         private:
          Arg const arg_;
          Coefs const coefs_;
      };

      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<ResizePrep, Pts, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          enum {numPts = Pts::length};
          NeboStencilCoefList<numPts> typedef Coefs;
          NeboStencil<Resize, Pts, typename Arg::ResizeType, FieldType> typedef ResizeType;
          NeboStencil(Arg const & arg, Coefs const & coefs)
          : arg_(arg), coefs_(coefs)
          {};
          inline ResizeType resize(structured::IntVec const & split,
                                   structured::IntVec const & location) const {
             return ResizeType(arg().resize(split, location), coefs());
          };
          inline Arg const & arg(void) const { return arg_; };
          inline Coefs const & coefs(void) const { return coefs_; };

         private:
          Arg const arg_;
          Coefs const coefs_;
      };

      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Resize, Pts, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          enum {numPts = Pts::length};
          NeboStencilCoefList<numPts> typedef Coefs;
          typename Pts::template ConstructExpr<Arg, FieldType> typedef ConstructExpr;
          typename ConstructExpr::Result typedef ArgSeqWalkType;
          NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef SeqWalkType;
          NeboStencil(Arg const & arg, Coefs const & coefs)
          : arg_(arg), coefs_(coefs)
          {};
          template<typename Shift>
           inline SeqWalkType init(void) const {
              return SeqWalkType(ConstructExpr::template rs_sq_construct<Shift>(arg(), coefs()));
           };
          inline Arg const & arg(void) const { return arg_; };
          inline Coefs const & coefs(void) const { return coefs_; };

         private:
          Arg const arg_;
          Coefs const coefs_;
      };

      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<SeqWalk, Pts, Arg, FieldType> {

         public:
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboStencil(Arg const & arg)
          : arg_(arg)
          {};
          inline void next(void) { arg_.next(); };
          inline bool at_end(void) const { return arg_.at_end(); };
          inline bool has_length(void) const { return arg_.has_length(); };
          inline AtomicType const eval(void) const { return arg_.eval(); };

         private:
          Arg arg_;
      };

      template<typename LhsType, typename RhsType>
       inline void nebo_assignment_sequential_execute_internal(LhsType lhs, RhsType rhs) {
          while(!lhs.at_end()){ lhs.ref() = rhs.eval(); lhs.next(); rhs.next(); };
       };

      template<typename ValidGhost, typename InitialShift, typename ExprType, typename FieldType>
       inline FieldType const & nebo_assignment_sequential_execute(FieldType & initial_lhs,
                                                                   NeboExpression<ExprType,
                                                                                  FieldType> const &
                                                                   initial_rhs) {

          nebo_assignment_sequential_execute_internal(NeboField<Initial, FieldType>(initial_lhs).template
                                                                                                 init<ValidGhost,
                                                                                                      InitialShift>(),
                                                      initial_rhs.expr().template init<ValidGhost,
                                                                                       InitialShift>());

          return initial_lhs;
       };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename InitialShift,
                  typename ResizeLhsType,
                  typename ResizeRhsType,
                  typename FieldType>
          inline void nebo_assignment_thread_parallel_execute_internal(ResizeLhsType & lhs,
                                                                       ResizeRhsType const & rhs,
                                                                       structured::IntVec const &
                                                                       split,
                                                                       structured::IntVec const &
                                                                       location,
                                                                       BI::interprocess_semaphore *
                                                                       semaphore) {

             nebo_assignment_sequential_execute_internal(lhs.resize(split, location).template init<InitialShift>(),
                                                         rhs.resize(split, location).template init<InitialShift>());

             semaphore->post();
          }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename ValidGhost, typename InitialShift, typename ExprType, typename FieldType>
          inline FieldType const & nebo_assignment_thread_parallel_execute(FieldType & initial_lhs,
                                                                           NeboExpression<ExprType,
                                                                                          FieldType>
                                                                           const & initial_rhs,
                                                                           int const
                                                                           number_of_partitions) {

             typename NeboField<Initial, FieldType>::ResizePrepType typedef LhsType;

             typename ExprType::ResizePrepType typedef RhsType;

             typename FieldType::memory_window typedef MemoryWindow;

             structured::IntVec extent = initial_lhs.template resize_ghost<ValidGhost>().window_with_ghost().extent();

             int x = 1;
             int y = 1;
             int z = 1;

             if(number_of_partitions <= extent[2]){ z = number_of_partitions; }
             else if(number_of_partitions <= extent[1]){ y = number_of_partitions; }
             else if(number_of_partitions <= extent[0]){ x = number_of_partitions; };

             structured::IntVec split = structured::IntVec(x, y, z);

             BI::interprocess_semaphore semaphore(0);

             int count = 0;

             for(; count < number_of_partitions; ++count){

                structured::IntVec location = structured::IntVec(((x == 1) ? 0 : count),
                                                                 ((y == 1) ? 0 : count),
                                                                 ((z == 1) ? 0 : count));

                ThreadPoolFIFO::self().schedule(boost::bind(&
                                                            nebo_assignment_thread_parallel_execute_internal<InitialShift,
                                                                                                             LhsType,
                                                                                                             RhsType,
                                                                                                             FieldType>,
                                                            NeboField<Initial, FieldType>(initial_lhs).template
                                                                                                       resize_prep<ValidGhost>(),
                                                            initial_rhs.expr().template resize_prep<ValidGhost>(),
                                                            split,
                                                            location,
                                                            &semaphore));
             };

             for(int ii = 0 ;ii < number_of_partitions ;ii++){ semaphore.wait(); };

             return initial_lhs;
          }
#     endif
      /* FIELD_EXPRESSION_THREADS */;

      template<typename CallStyle, typename ExprType, typename FieldType>
       inline FieldType const & nebo_assignment_general_execute(FieldType & initial_lhs,
                                                                NeboExpression<ExprType, FieldType>
                                                                const & initial_rhs) {

          typename IteratorStyle<CallStyle,
                                 typename structured::Minimum<typename ExprType::PossibleValidGhost,
                                                              typename structured::GhostFromField<FieldType>::
                                                              result>::result,
                                 typename structured::MinimumGhostFromField<FieldType>::result>::
          result typedef ValidGhost;

          structured::IndexTriplet<0, 0, 0> typedef InitialShift;

          return
#                ifdef FIELD_EXPRESSION_THREADS
                    (is_thread_parallel() ? nebo_assignment_thread_parallel_execute<ValidGhost,
                                                                                    InitialShift,
                                                                                    ExprType,
                                                                                    FieldType>(initial_lhs,
                                                                                               initial_rhs,
                                                                                               get_soft_thread_count())
                     : nebo_assignment_sequential_execute<ValidGhost,
                                                          InitialShift,
                                                          ExprType,
                                                          FieldType>(initial_lhs, initial_rhs))
#                else
                    nebo_assignment_sequential_execute<ValidGhost, InitialShift, ExprType, FieldType>(initial_lhs,
                                                                                                      initial_rhs)
#                endif
                 /* FIELD_EXPRESSION_THREADS */
          ;
       };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef ExprType;

          return (lhs <<= NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef ExprType;

          return (lhs <<= NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename ExprType, typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             NeboExpression<ExprType, FieldType> const & rhs) {
          return nebo_assignment_general_execute<UseWholeIterator, ExprType, FieldType>(lhs, rhs);
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef ExprType;

          return interior_assign(lhs, NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef ExprType;

          return interior_assign(lhs, NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename ExprType, typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                NeboExpression<ExprType, FieldType> const & rhs) {
          return nebo_assignment_general_execute<UseInteriorIterator, ExprType, FieldType>(lhs, rhs);
       };

#     ifdef __CUDACC__
         template<typename Dest, typename Src>
          __global__ inline void gpu_assign_kernel(Dest dest, Src src) {

             const int ii = blockIdx.x * blockDim.x + threadIdx.x;

             const int jj = blockIdx.y * blockDim.y + threadIdx.y;

             dest.start(ii, jj);

             src.start(ii, jj);

             if(dest.valid()) {
                while(!dest.at_end()) { dest.ref() = src.eval(); dest.next(); src.next(); };
             };
          }
#     endif
      /* __CUDACC__ */;

#     ifdef __CUDACC__
         template<typename ExprType, typename FieldType>
          inline void gpu_assign(FieldType & initial_lhs,
                                 NeboExpression<ExprType, FieldType> const & initial_rhs) {

             typename FieldType::memory_window typedef MemoryWindow;

             MemoryWindow mw = initial_lhs.window_with_ghost();

             int blockDim = 16;

             int gDimX = mw.extent(0) / blockDim + (mw.extent(0) % blockDim > 0 ? 1 : 0);

             int gDimY = mw.extent(1) / blockDim + (mw.extent(1) % blockDim > 0 ? 1 : 0);

             dim3 dimBlock(blockDim, blockDim);

             dim3 dimGrid(gDimX, gDimY);

             NeboField<GPUWalk, FieldType> typedef LhsType;

             typename ExprType::GPUWalkType typedef RhsType;

             LhsType lhs(initial_lhs);

             gpu_assign_kernel<LhsType, RhsType><<<dimGrid, dimBlock>>>(LhsType(initial_lhs),
                                                                        initial_rhs.expr().gpu_init());
          }
#     endif
      /* __CUDACC__ */;

#     ifdef __CUDACC__
         template<typename FieldType>
          inline void operator |=(FieldType & lhs, FieldType const & rhs) {

             NeboConstField<Initial, FieldType> typedef ExprType;

             lhs |= NeboExpression<ExprType, FieldType>(ExprType(rhs));
          }
#     endif
      /* __CUDACC__ */;

#     ifdef __CUDACC__
         template<typename ExprType, typename FieldType>
          inline void operator |=(FieldType & lhs, NeboExpression<ExprType, FieldType> const & rhs) {
             gpu_assign(lhs, rhs);
          }
#     endif
      /* __CUDACC__ */;
   } /* SpatialOps */;

#endif
/* SpatialOps_FieldExpressions_h */
