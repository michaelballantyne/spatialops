/* This file was generated by fulmar version 0.7.6. */
#ifndef SpatialOps_FieldExpressions_h
#  define SpatialOps_FieldExpressions_h

#  include <spatialops/SpatialOpsConfigure.h>
#  include <spatialops/structured/SpatialField.h>
#  include <cmath>

   /*#include <iostream> */

#  ifdef FIELD_EXPRESSION_THREADS
#     include <vector>
#     include <boost/bind.hpp>
#     include <boost/ref.hpp>
#     include <spatialops/ThreadPool.h>
#     include <spatialops/structured/IntVec.h>
#     include <boost/interprocess/sync/interprocess_semaphore.hpp>
      namespace BI = boost::interprocess;
#  endif /* FIELD_EXPRESSION_THREADS */

   namespace SpatialOps {

      /* Meta-programming compiler flags */
      struct UseWholeIterator;
      struct UseInteriorIterator;

      template<typename Use, typename FieldType>
       struct IteratorStyle;

      /* UseWholeIterator */
      template<typename FieldType>
       struct IteratorStyle<UseWholeIterator, FieldType> {

         typename FieldType::memory_window typedef MemoryWindow;

         static inline MemoryWindow const & memory_window(FieldType const & field) {
            return field.window_with_ghost();
         };
      };

      /* UseInteriorIterator */
      template<typename FieldType>
       struct IteratorStyle<UseInteriorIterator, FieldType> {

         typename FieldType::memory_window typedef MemoryWindow;

         static inline MemoryWindow const & memory_window(FieldType const & field) {
            return field.window_without_ghost();
         };
      };

      template<typename Operand, typename FieldType>
       struct NeboExpression {

         public:
          FieldType typedef field_type;
          NeboExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      template<typename Operand, typename FieldType>
       struct NeboBooleanExpression {

         public:
          FieldType typedef field_type;
          NeboBooleanExpression(Operand const & given)
          : expr_(given)
          {};
          inline Operand const & expr(void) const { return expr_; };

         private:
          Operand expr_;
      };

      /* Modes: */
      struct Initial;
      template<typename IteratorType, typename SourceType>
       struct ResizePrep;
      template<typename IteratorType, typename SourceType>
       struct Resize;
      template<typename IteratorType, typename SourceType>
       struct SeqWalk;

      template<typename CurrentMode, typename FieldType>
       struct NeboScalar;

      template<typename FieldType>
       struct NeboScalar<Initial, FieldType> {

         public:
          NeboScalar<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboScalar<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboScalar<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(AtomicType const v)
          : value_(v)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboScalar<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboScalar<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboScalar<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(SourceType const source)
          : value_(source.value())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboScalar<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboScalar<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboScalar<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(MemoryWindow const & size, SourceType const source)
          : value_(source.value())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline AtomicType const value(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboScalar<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboScalar<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboScalar(SourceType const source)
          : value_(source.value())
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline AtomicType const eval(void) const { return value_; };

         private:
          AtomicType const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboBoolean;

      template<typename FieldType>
       struct NeboBoolean<Initial, FieldType> {

         public:
          NeboBoolean<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboBoolean<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboBoolean<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          NeboBoolean(bool const v)
          : value_(v)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboBoolean<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboBoolean<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          NeboBoolean(SourceType const source)
          : value_(source.value())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboBoolean<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboBoolean<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          NeboBoolean(MemoryWindow const & size, SourceType const source)
          : value_(source.value())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline bool const value(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboBoolean<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboBoolean<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboBoolean(SourceType const source)
          : value_(source.value())
          {};
          inline void next(void) {};
          inline bool at_end(void) const { return false; };
          inline bool has_length(void) const { return false; };
          inline bool const eval(void) const { return value_; };

         private:
          bool const value_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboConstField;

      template<typename FieldType>
       struct NeboConstField<Initial, FieldType> {

         public:
          NeboConstField<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboConstField<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboConstField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          NeboConstField(FieldType const & f)
          : field_(f)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboConstField<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboConstField<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboConstField<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          NeboConstField(SourceType const & source)
          : field_(source.field())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboConstField<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboConstField<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboConstField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          NeboConstField(MemoryWindow const & size, SourceType const & source)
          : field_(size, source.field().field_values(), structured::ExternalStorage)
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline FieldType const & field(void) const { return field_; };

         private:
          FieldType const field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboConstField<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboConstField<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboConstField(SourceType const & source)
          : iter_(source.field().begin()), end_(source.field().end())
          {};
          inline void next(void) { ++iter_; };
          inline bool at_end(void) const { return (iter_ == end_); };
          inline bool has_length(void) const { return true; };
          inline AtomicType const & eval(void) const { return *iter_; };

         private:
          typename FieldType::const_iterator iter_;
          typename FieldType::const_iterator const end_;
      };

      template<typename CurrentMode, typename FieldType>
       struct NeboField;

      template<typename FieldType>
       struct NeboField<Initial, FieldType> {

         public:
          NeboField<Initial, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NeboField<ResizePrep<IteratorType, This>, FieldType> typedef ResizePrepType;

             NeboField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          };
          NeboField(FieldType & f)
          : field_(f)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboField<ResizePrep<IteratorType, SourceType>, FieldType> {

         public:
          NeboField<ResizePrep<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboField<Resize<IteratorType, This>, FieldType> typedef ResizeType;
          NeboField(SourceType & source)
          : field_(source.field())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) {
             return ResizeType(newSize, *this);
          };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboField<Resize<IteratorType, SourceType>, FieldType> {

         public:
          NeboField<Resize<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NeboField<SeqWalk<IteratorType, This>, FieldType> typedef SeqWalkType;
          NeboField(MemoryWindow const & size, SourceType & source)
          : field_(size, source.field().field_values(), structured::ExternalStorage)
          {};
          inline SeqWalkType init(void) { return SeqWalkType(*this); };
          inline FieldType & field(void) { return field_; };

         private:
          FieldType field_;
      };

      template<typename IteratorType, typename SourceType, typename FieldType>
       struct NeboField<SeqWalk<IteratorType, SourceType>, FieldType> {

         public:
          NeboField<SeqWalk<IteratorType, SourceType>, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef AtomicType;
          NeboField(SourceType & source)
          : iter_(source.field().begin()), end_(source.field().end())
          {};
          inline void next(void) { ++iter_; };
          inline bool at_end(void) const { return (iter_ == end_); };
          inline bool has_length(void) const { return true; };
          inline AtomicType & ref(void) { return *iter_; };
          inline AtomicType * ptr(void) { return &(*iter_); };

         private:
          typename FieldType::iterator iter_;
          typename FieldType::iterator const end_;
      };

      template<typename Input, typename FieldType>
       struct Standardize;

      template<typename FieldType>
       struct Standardize<FieldType, FieldType> {

         NeboConstField<Initial, FieldType> typedef StandardType;

         NeboExpression<StandardType, FieldType> typedef StandardTerm;

         static inline StandardType standardType(FieldType const & given) {
            return StandardType(given);
         };

         static inline StandardTerm standardTerm(FieldType const & given) {
            return StandardTerm(StandardType(given));
         };
      };

      template<typename ExprType, typename FieldType>
       struct Standardize<NeboExpression<ExprType, FieldType>, FieldType> {

         ExprType typedef StandardType;

         NeboExpression<StandardType, FieldType> typedef StandardTerm;

         static inline StandardType standardType(NeboExpression<ExprType, FieldType> const & given) {
            return given.expr();
         };

         static inline StandardTerm standardTerm(NeboExpression<ExprType, FieldType> const & given) {
            return given;
         };
      };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct SumOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Initial, Operand1, Operand2, FieldType> {

         public:
          SumOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             SumOp<ResizePrep<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                   typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                   FieldType> typedef ResizePrepType;

             SumOp<SeqWalk<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                   typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          };
          SumOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct SumOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          SumOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SumOp<Resize<IteratorType, This>,
                typename Operand1::ResizeType,
                typename Operand2::ResizeType,
                FieldType> typedef ResizeType;
          SumOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct SumOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          SumOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SumOp<SeqWalk<IteratorType, This>,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;
          SumOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct SumOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          SumOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SumOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() + operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<SumOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator +(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<SumOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator +(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                   typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                   StandardType,
                                   typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator +(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          SumOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Initial, Operand1, Operand2, FieldType> {

         public:
          DiffOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             DiffOp<ResizePrep<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                    typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             DiffOp<SeqWalk<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                    typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          DiffOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DiffOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DiffOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DiffOp<Resize<IteratorType, This>,
                 typename Operand1::ResizeType,
                 typename Operand2::ResizeType,
                 FieldType> typedef ResizeType;
          DiffOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DiffOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DiffOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DiffOp<SeqWalk<IteratorType, This>,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;
          DiffOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DiffOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DiffOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DiffOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() - operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<DiffOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator -(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<DiffOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator -(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator -(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          DiffOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Initial, Operand1, Operand2, FieldType> {

         public:
          ProdOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             ProdOp<ResizePrep<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                    typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             ProdOp<SeqWalk<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                    typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          ProdOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct ProdOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          ProdOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ProdOp<Resize<IteratorType, This>,
                 typename Operand1::ResizeType,
                 typename Operand2::ResizeType,
                 FieldType> typedef ResizeType;
          ProdOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct ProdOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          ProdOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ProdOp<SeqWalk<IteratorType, This>,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;
          ProdOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct ProdOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          ProdOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ProdOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() * operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<ProdOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator *(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<ProdOp<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator *(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator *(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          ProdOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct DivOp;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Initial, Operand1, Operand2, FieldType> {

         public:
          DivOp<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             DivOp<ResizePrep<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                   typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                   FieldType> typedef ResizePrepType;

             DivOp<SeqWalk<IteratorType, This>,
                   typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                   typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                   FieldType> typedef SeqWalkType;
          };
          DivOp(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DivOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DivOp<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DivOp<Resize<IteratorType, This>,
                typename Operand1::ResizeType,
                typename Operand2::ResizeType,
                FieldType> typedef ResizeType;
          DivOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DivOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DivOp<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          DivOp<SeqWalk<IteratorType, This>,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;
          DivOp(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DivOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          DivOp<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          DivOp(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const { return (operand1_.eval() / operand2_.eval()); };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<DivOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                   StandardType,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator /(SubExpr1 const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<DivOp<Initial,
                                   typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                   StandardType,
                                   NeboScalar<Initial, typename SubExpr1::field_type>,
                                   typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> operator /(SubExpr1 const & arg1,
                                                                       typename SubExpr1::field_type::
                                                                       value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial, typename SubExpr2::field_type>,
                                   typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                   StandardType,
                                   typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> operator /(typename SubExpr2::field_type::
                                                                       value_type const & arg1,
                                                                       SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          DivOp<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SinFcn;

      template<typename Operand, typename FieldType>
       struct SinFcn<Initial, Operand, FieldType> {

         public:
          SinFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             SinFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             SinFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          SinFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SinFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SinFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SinFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          SinFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SinFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SinFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SinFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          SinFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SinFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SinFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SinFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sin(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<SinFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> sin(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          SinFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct CosFcn;

      template<typename Operand, typename FieldType>
       struct CosFcn<Initial, Operand, FieldType> {

         public:
          CosFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             CosFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             CosFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          CosFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct CosFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          CosFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          CosFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          CosFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct CosFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          CosFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          CosFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          CosFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct CosFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          CosFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          CosFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::cos(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<CosFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> cos(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          CosFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanFcn;

      template<typename Operand, typename FieldType>
       struct TanFcn<Initial, Operand, FieldType> {

         public:
          TanFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             TanFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             TanFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          TanFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          TanFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          TanFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tan(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<TanFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> tan(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          TanFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct ExpFcn;

      template<typename Operand, typename FieldType>
       struct ExpFcn<Initial, Operand, FieldType> {

         public:
          ExpFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             ExpFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             ExpFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          ExpFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct ExpFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          ExpFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ExpFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          ExpFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct ExpFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          ExpFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          ExpFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          ExpFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct ExpFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          ExpFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          ExpFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::exp(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<ExpFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> exp(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          ExpFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanhFcn;

      template<typename Operand, typename FieldType>
       struct TanhFcn<Initial, Operand, FieldType> {

         public:
          TanhFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             TanhFcn<ResizePrep<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::ResizePrepType,
                     FieldType> typedef ResizePrepType;

             TanhFcn<SeqWalk<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          };
          TanhFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanhFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanhFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanhFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          TanhFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanhFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanhFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          TanhFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          TanhFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct TanhFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          TanhFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          TanhFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::tanh(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<TanhFcn<Initial,
                                     typename Standardize<SubExpr, typename SubExpr::field_type>::
                                     StandardType,
                                     typename SubExpr::field_type>,
                             typename SubExpr::field_type> tanh(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          TanhFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct AbsFcn;

      template<typename Operand, typename FieldType>
       struct AbsFcn<Initial, Operand, FieldType> {

         public:
          AbsFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             AbsFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             AbsFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          AbsFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct AbsFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          AbsFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AbsFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          AbsFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct AbsFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          AbsFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          AbsFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          AbsFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct AbsFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          AbsFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          AbsFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::abs(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<AbsFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> abs(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          AbsFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NegFcn;

      template<typename Operand, typename FieldType>
       struct NegFcn<Initial, Operand, FieldType> {

         public:
          NegFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             NegFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             NegFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          NegFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NegFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NegFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NegFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          NegFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NegFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NegFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          NegFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          NegFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct NegFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          NegFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          NegFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return -(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<NegFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> operator -(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          NegFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn;

      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Initial, Operand1, Operand2, FieldType> {

         public:
          PowFcn<Initial, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             PowFcn<ResizePrep<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::ResizePrepType,
                    typename Operand2::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             PowFcn<SeqWalk<IteratorType, This>,
                    typename Operand1::template Iterator<IteratorType>::SeqWalkType,
                    typename Operand2::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          PowFcn(Operand1 const & op1, Operand2 const & op2)
          : operand1_(op1), operand2_(op2)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct PowFcn<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          PowFcn<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          PowFcn<Resize<IteratorType, This>,
                 typename Operand1::ResizeType,
                 typename Operand2::ResizeType,
                 FieldType> typedef ResizeType;
          PowFcn(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct PowFcn<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          PowFcn<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          PowFcn<SeqWalk<IteratorType, This>,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;
          PowFcn(MemoryWindow const & size, SourceType const & source)
          : operand1_(size, source.operand1()), operand2_(size, source.operand2())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand1 const & operand1(void) const { return operand1_; };
          inline Operand2 const & operand2(void) const { return operand2_; };

         private:
          Operand1 const operand1_;
          Operand2 const operand2_;
      };

      template<typename IteratorType,
               typename SourceType,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct PowFcn<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {

         public:
          PowFcn<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          PowFcn(SourceType const & source)
          : operand1_(source.operand1()), operand2_(source.operand2())
          {};
          inline void next(void) { operand1_.next(); operand2_.next(); };
          inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); };
          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          };
          inline EvalReturnType eval(void) const {
             return std::pow(operand1_.eval(), operand2_.eval());
          };

         private:
          Operand1 operand1_;
          Operand2 operand2_;
      };

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2>
       inline NeboExpression<PowFcn<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename Standardize<SubExpr2, typename SubExpr1::field_type>::
                                    StandardType,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> pow(SubExpr1 const & arg1,
                                                                SubExpr2 const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      /* SubExpr X Scalar */
      template<typename SubExpr1>
       inline NeboExpression<PowFcn<Initial,
                                    typename Standardize<SubExpr1, typename SubExpr1::field_type>::
                                    StandardType,
                                    NeboScalar<Initial, typename SubExpr1::field_type>,
                                    typename SubExpr1::field_type>,
                             typename SubExpr1::field_type> pow(SubExpr1 const & arg1,
                                                                typename SubExpr1::field_type::
                                                                value_type const & arg2) {

          typename SubExpr1::field_type typedef FieldType;

          typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef Type1;

          NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)),
                                       Type2(Type2(arg2))));
       };

      /* Scalar X SubExpr */
      template<typename SubExpr2>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial, typename SubExpr2::field_type>,
                                    typename Standardize<SubExpr2, typename SubExpr2::field_type>::
                                    StandardType,
                                    typename SubExpr2::field_type>,
                             typename SubExpr2::field_type> pow(typename SubExpr2::field_type::
                                                                value_type const & arg1,
                                                                SubExpr2 const & arg2) {

          typename SubExpr2::field_type typedef FieldType;

          NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;

          typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef Type2;

          PowFcn<Initial, Type1, Type2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type1(Type1(arg1)),
                                       Type2(Standardize<SubExpr2, FieldType>::standardType(arg2))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SqrtFcn;

      template<typename Operand, typename FieldType>
       struct SqrtFcn<Initial, Operand, FieldType> {

         public:
          SqrtFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             SqrtFcn<ResizePrep<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::ResizePrepType,
                     FieldType> typedef ResizePrepType;

             SqrtFcn<SeqWalk<IteratorType, This>,
                     typename Operand::template Iterator<IteratorType>::SeqWalkType,
                     FieldType> typedef SeqWalkType;
          };
          SqrtFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SqrtFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SqrtFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SqrtFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          SqrtFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SqrtFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SqrtFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          SqrtFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          SqrtFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct SqrtFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          SqrtFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          SqrtFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::sqrt(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<SqrtFcn<Initial,
                                     typename Standardize<SubExpr, typename SubExpr::field_type>::
                                     StandardType,
                                     typename SubExpr::field_type>,
                             typename SubExpr::field_type> sqrt(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          SqrtFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct LogFcn;

      template<typename Operand, typename FieldType>
       struct LogFcn<Initial, Operand, FieldType> {

         public:
          LogFcn<Initial, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          template<typename IteratorType>
           struct Iterator {

             LogFcn<ResizePrep<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::ResizePrepType,
                    FieldType> typedef ResizePrepType;

             LogFcn<SeqWalk<IteratorType, This>,
                    typename Operand::template Iterator<IteratorType>::SeqWalkType,
                    FieldType> typedef SeqWalkType;
          };
          LogFcn(Operand const & op)
          : operand_(op)
          {};
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::SeqWalkType init(void) const {
              return typename Iterator<IteratorType>::SeqWalkType(*this);
           };
          template<typename IteratorType>
           inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {
              return typename Iterator<IteratorType>::ResizePrepType(*this);
           };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct LogFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {

         public:
          LogFcn<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LogFcn<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType> typedef
          ResizeType;
          LogFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline ResizeType resize(MemoryWindow const & newSize) const {
             return ResizeType(newSize, *this);
          };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct LogFcn<Resize<IteratorType, SourceType>, Operand, FieldType> {

         public:
          LogFcn<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          LogFcn<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;
          LogFcn(MemoryWindow const & size, SourceType const & source)
          : operand_(size, source.operand())
          {};
          inline SeqWalkType init(void) const { return SeqWalkType(*this); };
          inline Operand const & operand(void) const { return operand_; };

         private:
          Operand const operand_;
      };

      template<typename IteratorType, typename SourceType, typename Operand, typename FieldType>
       struct LogFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {

         public:
          LogFcn<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;
          FieldType typedef field_type;
          typename FieldType::memory_window typedef MemoryWindow;
          typename FieldType::value_type typedef EvalReturnType;
          LogFcn(SourceType const & source)
          : operand_(source.operand())
          {};
          inline void next(void) { operand_.next(); };
          inline bool at_end(void) const { return (operand_.at_end()); };
          inline bool has_length(void) const { return (operand_.has_length()); };
          inline EvalReturnType eval(void) const { return std::log(operand_.eval()); };

         private:
          Operand operand_;
      };

      /* SubExpr */
      template<typename SubExpr>
       inline NeboExpression<LogFcn<Initial,
                                    typename Standardize<SubExpr, typename SubExpr::field_type>::
                                    StandardType,
                                    typename SubExpr::field_type>,
                             typename SubExpr::field_type> log(SubExpr const & arg) {

          typename SubExpr::field_type typedef FieldType;

          typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type;

          LogFcn<Initial, Type, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg))));
       };

#     define BUILD_BINARY_FUNCTION(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                      \
         template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>  \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Initial, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Initial, Operand1, Operand2, FieldType> typedef This;                     \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             template<typename IteratorType>                                                       \
              struct Iterator {                                                                    \
                                                                                                   \
                OBJECT_NAME<ResizePrep<IteratorType, This>,                                        \
                            typename Operand1::template Iterator<IteratorType>::ResizePrepType,    \
                            typename Operand2::template Iterator<IteratorType>::ResizePrepType,    \
                            FieldType> typedef ResizePrepType;                                     \
                                                                                                   \
                OBJECT_NAME<SeqWalk<IteratorType, This>,                                           \
                            typename Operand1::template Iterator<IteratorType>::SeqWalkType,       \
                            typename Operand2::template Iterator<IteratorType>::SeqWalkType,       \
                            FieldType> typedef SeqWalkType;                                        \
             };                                                                                    \
             OBJECT_NAME(Operand1 const & op1, Operand2 const & op2)                               \
             : operand1_(op1), operand2_(op2)                                                      \
             {};                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::SeqWalkType init(void) const {               \
                 return typename Iterator<IteratorType>::SeqWalkType(*this);                       \
              };                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {     \
                 return typename Iterator<IteratorType>::ResizePrepType(*this);                    \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> { \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType>      \
             typedef This;                                                                         \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize<IteratorType, This>,                                               \
                         typename Operand1::ResizeType,                                            \
                         typename Operand2::ResizeType,                                            \
                         FieldType> typedef ResizeType;                                            \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline ResizeType resize(MemoryWindow const & newSize) const {                        \
                return ResizeType(newSize, *this);                                                 \
             };                                                                                    \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {    \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef  \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk<IteratorType, This>,                                              \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             OBJECT_NAME(MemoryWindow const & size, SourceType const & source)                     \
             : operand1_(size, source.operand1()), operand2_(size, source.operand2())              \
             {};                                                                                   \
             inline SeqWalkType init(void) const { return SeqWalkType(*this); };                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {   \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline void next(void) { operand1_.next(); operand2_.next(); };                       \
             inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); }; \
             inline bool has_length(void) const {                                                  \
                return (operand1_.has_length() || operand2_.has_length());                         \
             };                                                                                    \
             inline EvalReturnType eval(void) const {                                              \
                return INTERNAL_NAME(operand1_.eval(), operand2_.eval());                          \
             };                                                                                    \
                                                                                                   \
            private:                                                                               \
             Operand1 operand1_;                                                                   \
             Operand2 operand2_;                                                                   \
         };                                                                                        \
                                                                                                   \
         /* SubExpr X SubExpr */                                                                   \
         template<typename SubExpr1, typename SubExpr2>                                            \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };                                                                                       \
                                                                                                   \
         /* SubExpr X Scalar */                                                                    \
         template<typename SubExpr1>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            NeboScalar<Initial, typename SubExpr1::field_type>,    \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             typename SubExpr1::   \
                                                                             field_type::value_type \
                                                                             const & arg2) {       \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;                     \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Type2(arg2))));                                    \
          };                                                                                       \
                                                                                                   \
         /* Scalar X SubExpr */                                                                    \
         template<typename SubExpr2>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            NeboScalar<Initial, typename SubExpr2::field_type>,    \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr2::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr2::field_type>,                        \
                                typename SubExpr2::field_type> EXTERNAL_NAME(typename SubExpr2::   \
                                                                             field_type::value_type \
                                                                             const & arg1,         \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr2::field_type typedef FieldType;                                      \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;                     \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Type1(arg1)),                                      \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };

#     define BUILD_BINARY_OPERATOR(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                      \
         template<typename CurrentMode, typename Operand1, typename Operand2, typename FieldType>  \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand1, typename Operand2, typename FieldType>                        \
          struct OBJECT_NAME<Initial, Operand1, Operand2, FieldType> {                             \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Initial, Operand1, Operand2, FieldType> typedef This;                     \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             template<typename IteratorType>                                                       \
              struct Iterator {                                                                    \
                                                                                                   \
                OBJECT_NAME<ResizePrep<IteratorType, This>,                                        \
                            typename Operand1::template Iterator<IteratorType>::ResizePrepType,    \
                            typename Operand2::template Iterator<IteratorType>::ResizePrepType,    \
                            FieldType> typedef ResizePrepType;                                     \
                                                                                                   \
                OBJECT_NAME<SeqWalk<IteratorType, This>,                                           \
                            typename Operand1::template Iterator<IteratorType>::SeqWalkType,       \
                            typename Operand2::template Iterator<IteratorType>::SeqWalkType,       \
                            FieldType> typedef SeqWalkType;                                        \
             };                                                                                    \
             OBJECT_NAME(Operand1 const & op1, Operand2 const & op2)                               \
             : operand1_(op1), operand2_(op2)                                                      \
             {};                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::SeqWalkType init(void) const {               \
                 return typename Iterator<IteratorType>::SeqWalkType(*this);                       \
              };                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {     \
                 return typename Iterator<IteratorType>::ResizePrepType(*this);                    \
              };                                                                                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType> { \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand1, Operand2, FieldType>      \
             typedef This;                                                                         \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize<IteratorType, This>,                                               \
                         typename Operand1::ResizeType,                                            \
                         typename Operand2::ResizeType,                                            \
                         FieldType> typedef ResizeType;                                            \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline ResizeType resize(MemoryWindow const & newSize) const {                        \
                return ResizeType(newSize, *this);                                                 \
             };                                                                                    \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> {    \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Resize<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef  \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk<IteratorType, This>,                                              \
                         typename Operand1::SeqWalkType,                                           \
                         typename Operand2::SeqWalkType,                                           \
                         FieldType> typedef SeqWalkType;                                           \
             OBJECT_NAME(MemoryWindow const & size, SourceType const & source)                     \
             : operand1_(size, source.operand1()), operand2_(size, source.operand2())              \
             {};                                                                                   \
             inline SeqWalkType init(void) const { return SeqWalkType(*this); };                   \
             inline Operand1 const & operand1(void) const { return operand1_; };                   \
             inline Operand2 const & operand2(void) const { return operand2_; };                   \
                                                                                                   \
            private:                                                                               \
             Operand1 const operand1_;                                                             \
             Operand2 const operand2_;                                                             \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType,                                                           \
                  typename SourceType,                                                             \
                  typename Operand1,                                                               \
                  typename Operand2,                                                               \
                  typename FieldType>                                                              \
          struct OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> {   \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand1, Operand2, FieldType> typedef \
             This;                                                                                 \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand1_(source.operand1()), operand2_(source.operand2())                          \
             {};                                                                                   \
             inline void next(void) { operand1_.next(); operand2_.next(); };                       \
             inline bool at_end(void) const { return (operand1_.at_end() || operand2_.at_end()); }; \
             inline bool has_length(void) const {                                                  \
                return (operand1_.has_length() || operand2_.has_length());                         \
             };                                                                                    \
             inline EvalReturnType eval(void) const {                                              \
                return (operand1_.eval() INTERNAL_NAME operand2_.eval());                          \
             };                                                                                    \
                                                                                                   \
            private:                                                                               \
             Operand1 operand1_;                                                                   \
             Operand2 operand2_;                                                                   \
         };                                                                                        \
                                                                                                   \
         /* SubExpr X SubExpr */                                                                   \
         template<typename SubExpr1, typename SubExpr2>                                            \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr1::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };                                                                                       \
                                                                                                   \
         /* SubExpr X Scalar */                                                                    \
         template<typename SubExpr1>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr1,                         \
                                                                 typename SubExpr1::field_type>::  \
                                            StandardType,                                          \
                                            NeboScalar<Initial, typename SubExpr1::field_type>,    \
                                            typename SubExpr1::field_type>,                        \
                                typename SubExpr1::field_type> EXTERNAL_NAME(SubExpr1 const & arg1, \
                                                                             typename SubExpr1::   \
                                                                             field_type::value_type \
                                                                             const & arg2) {       \
                                                                                                   \
             typename SubExpr1::field_type typedef FieldType;                                      \
                                                                                                   \
             typename Standardize<SubExpr1, typename SubExpr1::field_type>::StandardType typedef   \
             Type1;                                                                                \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr1::field_type> typedef Type2;                     \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Standardize<SubExpr1, FieldType>::standardType(arg1)), \
                                          Type2(Type2(arg2))));                                    \
          };                                                                                       \
                                                                                                   \
         /* Scalar X SubExpr */                                                                    \
         template<typename SubExpr2>                                                               \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            NeboScalar<Initial, typename SubExpr2::field_type>,    \
                                            typename Standardize<SubExpr2,                         \
                                                                 typename SubExpr2::field_type>::  \
                                            StandardType,                                          \
                                            typename SubExpr2::field_type>,                        \
                                typename SubExpr2::field_type> EXTERNAL_NAME(typename SubExpr2::   \
                                                                             field_type::value_type \
                                                                             const & arg1,         \
                                                                             SubExpr2 const & arg2) { \
                                                                                                   \
             typename SubExpr2::field_type typedef FieldType;                                      \
                                                                                                   \
             NeboScalar<Initial, typename SubExpr2::field_type> typedef Type1;                     \
                                                                                                   \
             typename Standardize<SubExpr2, typename SubExpr2::field_type>::StandardType typedef   \
             Type2;                                                                                \
                                                                                                   \
             OBJECT_NAME<Initial, Type1, Type2, FieldType> typedef ReturnType;                     \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type1(Type1(arg1)),                                      \
                                          Type2(Standardize<SubExpr2, FieldType>::standardType(arg2)))); \
          };

#     define BUILD_UNARY_FUNCTION(OBJECT_NAME, INTERNAL_NAME, EXTERNAL_NAME)                       \
         template<typename CurrentMode, typename Operand, typename FieldType>                      \
          struct OBJECT_NAME;                                                                      \
                                                                                                   \
         template<typename Operand, typename FieldType>                                            \
          struct OBJECT_NAME<Initial, Operand, FieldType> {                                        \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Initial, Operand, FieldType> typedef This;                                \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             template<typename IteratorType>                                                       \
              struct Iterator {                                                                    \
                                                                                                   \
                OBJECT_NAME<ResizePrep<IteratorType, This>,                                        \
                            typename Operand::template Iterator<IteratorType>::ResizePrepType,     \
                            FieldType> typedef ResizePrepType;                                     \
                                                                                                   \
                OBJECT_NAME<SeqWalk<IteratorType, This>,                                           \
                            typename Operand::template Iterator<IteratorType>::SeqWalkType,        \
                            FieldType> typedef SeqWalkType;                                        \
             };                                                                                    \
             OBJECT_NAME(Operand const & op)                                                       \
             : operand_(op)                                                                        \
             {};                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::SeqWalkType init(void) const {               \
                 return typename Iterator<IteratorType>::SeqWalkType(*this);                       \
              };                                                                                   \
             template<typename IteratorType>                                                       \
              inline typename Iterator<IteratorType>::ResizePrepType resize_prep(void) const {     \
                 return typename Iterator<IteratorType>::ResizePrepType(*this);                    \
              };                                                                                   \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType, typename SourceType, typename Operand, typename FieldType> \
          struct OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand, FieldType> {           \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<ResizePrep<IteratorType, SourceType>, Operand, FieldType> typedef This;   \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<Resize<IteratorType, This>, typename Operand::ResizeType, FieldType>      \
             typedef ResizeType;                                                                   \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand_(source.operand())                                                          \
             {};                                                                                   \
             inline ResizeType resize(MemoryWindow const & newSize) const {                        \
                return ResizeType(newSize, *this);                                                 \
             };                                                                                    \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType, typename SourceType, typename Operand, typename FieldType> \
          struct OBJECT_NAME<Resize<IteratorType, SourceType>, Operand, FieldType> {               \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<Resize<IteratorType, SourceType>, Operand, FieldType> typedef This;       \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             OBJECT_NAME<SeqWalk<IteratorType, This>, typename Operand::SeqWalkType, FieldType>    \
             typedef SeqWalkType;                                                                  \
             OBJECT_NAME(MemoryWindow const & size, SourceType const & source)                     \
             : operand_(size, source.operand())                                                    \
             {};                                                                                   \
             inline SeqWalkType init(void) const { return SeqWalkType(*this); };                   \
             inline Operand const & operand(void) const { return operand_; };                      \
                                                                                                   \
            private:                                                                               \
             Operand const operand_;                                                               \
         };                                                                                        \
                                                                                                   \
         template<typename IteratorType, typename SourceType, typename Operand, typename FieldType> \
          struct OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand, FieldType> {              \
                                                                                                   \
            public:                                                                                \
             OBJECT_NAME<SeqWalk<IteratorType, SourceType>, Operand, FieldType> typedef This;      \
             FieldType typedef field_type;                                                         \
             typename FieldType::memory_window typedef MemoryWindow;                               \
             typename FieldType::value_type typedef EvalReturnType;                                \
             OBJECT_NAME(SourceType const & source)                                                \
             : operand_(source.operand())                                                          \
             {};                                                                                   \
             inline void next(void) { operand_.next(); };                                          \
             inline bool at_end(void) const { return (operand_.at_end()); };                       \
             inline bool has_length(void) const { return (operand_.has_length()); };               \
             inline EvalReturnType eval(void) const { return INTERNAL_NAME(operand_.eval()); };    \
                                                                                                   \
            private:                                                                               \
             Operand operand_;                                                                     \
         };                                                                                        \
                                                                                                   \
         /* SubExpr */                                                                             \
         template<typename SubExpr>                                                                \
          inline NeboExpression<OBJECT_NAME<Initial,                                               \
                                            typename Standardize<SubExpr,                          \
                                                                 typename SubExpr::field_type>::   \
                                            StandardType,                                          \
                                            typename SubExpr::field_type>,                         \
                                typename SubExpr::field_type> EXTERNAL_NAME(SubExpr const & arg) { \
                                                                                                   \
             typename SubExpr::field_type typedef FieldType;                                       \
                                                                                                   \
             typename Standardize<SubExpr, typename SubExpr::field_type>::StandardType typedef Type; \
                                                                                                   \
             OBJECT_NAME<Initial, Type, FieldType> typedef ReturnType;                             \
                                                                                                   \
             NeboExpression<ReturnType, FieldType> typedef ReturnTerm;                             \
                                                                                                   \
             return ReturnTerm(ReturnType(Type(Standardize<SubExpr, FieldType>::standardType(arg)))); \
          };

      template<typename LhsType, typename RhsType>
       inline void field_expression_sequential_execute_internal(LhsType lhs, RhsType rhs) {
          while(!lhs.at_end()){ lhs.ref() = rhs.eval(); lhs.next(); rhs.next(); };
       };

      template<typename CallStyle, typename ExprType, typename FieldType>
       inline FieldType const & field_expression_sequential_execute(FieldType & initial_lhs,
                                                                    NeboExpression<ExprType,
                                                                                   FieldType> const
                                                                    & initial_rhs) {

          field_expression_sequential_execute_internal<typename NeboField<Initial, FieldType>::
                                                       template Iterator<CallStyle>::SeqWalkType,
                                                       typename ExprType::template Iterator<CallStyle>::
                                                       SeqWalkType>(NeboField<Initial, FieldType>(initial_lhs).template
                                                                                                               init<CallStyle>(),
                                                                    initial_rhs.expr().template init<CallStyle>());

          return initial_lhs;
       };

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename CallStyle,
                  typename ResizeLhsType,
                  typename ResizeRhsType,
                  typename FieldType>
          inline void field_expression_thread_parallel_execute_internal(ResizeLhsType & lhs,
                                                                        ResizeRhsType const & rhs,
                                                                        typename FieldType::
                                                                        memory_window const & window,
                                                                        BI::interprocess_semaphore *
                                                                        semaphore) {

             field_expression_sequential_execute_internal<typename ResizeLhsType::ResizeType::
                                                          SeqWalkType,
                                                          typename ResizeRhsType::ResizeType::
                                                          SeqWalkType>(lhs.resize(window).init(),
                                                                       rhs.resize(window).init());

             semaphore->post();
          }
#     endif /* FIELD_EXPRESSION_THREADS */;

#     ifdef FIELD_EXPRESSION_THREADS
         template<typename CallStyle, typename ExprType, typename FieldType>
          inline FieldType const & field_expression_thread_parallel_execute(FieldType & initial_lhs,
                                                                            NeboExpression<ExprType,
                                                                                           FieldType>
                                                                            const & initial_rhs,
                                                                            int const
                                                                            number_of_partitions) {

             typename NeboField<Initial, FieldType>::template Iterator<CallStyle>::ResizePrepType
             typedef LhsType;

             typename ExprType::template Iterator<CallStyle>::ResizePrepType typedef RhsType;

             typename FieldType::memory_window typedef MemoryWindow;

             MemoryWindow window = IteratorStyle<CallStyle, FieldType>::memory_window(initial_lhs);

             int x = 1;
             int y = 1;
             int z = 1;

             if(number_of_partitions <= window.extent(2)){ z = number_of_partitions; }
             else if(number_of_partitions <= window.extent(1)){ y = number_of_partitions; }
             else if(number_of_partitions <= window.extent(0)){ x = number_of_partitions; };

             std::vector<typename FieldType::memory_window> vec_window = window.split(structured::
                                                                                      IntVec(x, y, z));

             BI::interprocess_semaphore semaphore(0);

             typename std::vector<typename FieldType::memory_window>::const_iterator window_iterator
             = vec_window.begin();

             typename std::vector<typename FieldType::memory_window>::const_iterator window_end =
             vec_window.end();

             for(; window_iterator != window_end; ++window_iterator){

                ThreadPoolFIFO::self().schedule(boost::bind(&
                                                            field_expression_thread_parallel_execute_internal<CallStyle,
                                                                                                              LhsType,
                                                                                                              RhsType,
                                                                                                              FieldType>,
                                                            NeboField<Initial, FieldType>(initial_lhs).template
                                                                                                       resize_prep<CallStyle>(),
                                                            initial_rhs.expr().template resize_prep<CallStyle>(),
                                                            *window_iterator,
                                                            &semaphore));
             };

             for(int ii = 0; ii < vec_window.size(); ii++){ semaphore.wait(); };

             return initial_lhs;
          }
#     endif /* FIELD_EXPRESSION_THREADS */;

      template<typename CallStyle, typename ExprType, typename FieldType>
       inline FieldType const & field_expression_general_execute(FieldType & initial_lhs,
                                                                 NeboExpression<ExprType, FieldType>
                                                                 const & initial_rhs) {

          return
#                ifdef FIELD_EXPRESSION_THREADS
                    field_expression_thread_parallel_execute<CallStyle, ExprType, FieldType>(initial_lhs,
                                                                                             initial_rhs,
                                                                                             NTHREADS)
#                else
                    field_expression_sequential_execute<CallStyle, ExprType, FieldType>(initial_lhs,
                                                                                        initial_rhs)
#                endif /* FIELD_EXPRESSION_THREADS */
                 ;;
       };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef ExprType;

          return (lhs <<= NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef ExprType;

          return (lhs <<= NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename ExprType, typename FieldType>
       inline FieldType const & operator <<=(FieldType & lhs,
                                             NeboExpression<ExprType, FieldType> const & rhs) {
          return field_expression_general_execute<UseWholeIterator, ExprType, FieldType>(lhs, rhs);
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                typename FieldType::value_type const & rhs) {

          NeboScalar<Initial, FieldType> typedef ExprType;

          return interior_assign(lhs, NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs, FieldType const & rhs) {

          NeboConstField<Initial, FieldType> typedef ExprType;

          return interior_assign(lhs, NeboExpression<ExprType, FieldType>(ExprType(rhs)));
       };

      template<typename ExprType, typename FieldType>
       inline FieldType const & interior_assign(FieldType & lhs,
                                                NeboExpression<ExprType, FieldType> const & rhs) {
          return field_expression_general_execute<UseInteriorIterator, ExprType, FieldType>(lhs, rhs);
       };
   } /* SpatialOps */;

#endif /* SpatialOps_FieldExpressions_h */
