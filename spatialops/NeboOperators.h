/* This file was generated by fulmar version 0.8.0. */

/*
 * Copyright (c) 2013 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_OPERATORS_H
#  define NEBO_OPERATORS_H

   namespace SpatialOps {
      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct SumOp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          SumOp<SeqWalk,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             SumOp<Resize,
                   typename Operand1::ResizeType,
                   typename Operand2::ResizeType,
                   FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             SumOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          SumOp<Reduction,
                typename Operand1::ReductionType,
                typename Operand2::ReductionType,
                FieldType> typedef ReductionType;

          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct SumOp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             SumOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;

             SumOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() + operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct SumOp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             SumOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() + operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct SumOp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() + operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial, FieldType>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   FieldType>,
                             FieldType> operator +(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial,
                NeboScalar<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial, FieldType>,
                                   SubExpr2,
                                   FieldType>,
                             FieldType> operator +(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          SumOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboScalar<Initial, FieldType>,
                                   FieldType>,
                             FieldType> operator +(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          SumOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboScalar<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   FieldType>,
                             FieldType> operator +(FieldType const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   SubExpr2,
                                   FieldType>,
                             FieldType> operator +(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          SumOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   SubExpr1,
                                   NeboScalar<Initial, FieldType>,
                                   FieldType>,
                             FieldType> operator +(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          SumOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   FieldType>,
                             FieldType> operator +(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial, SubExpr1, SubExpr2, FieldType>,
                             FieldType> operator +(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          SumOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DiffOp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          DiffOp<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             DiffOp<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType,
                    FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             DiffOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          DiffOp<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;

          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DiffOp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             DiffOp<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;

             DiffOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() - operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DiffOp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             DiffOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() - operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct DiffOp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() - operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> operator -(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> operator -(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DiffOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 SubExpr2,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> operator -(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DiffOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> operator -(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial,
                 SubExpr1,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial, SubExpr1, SubExpr2, FieldType>,
                             FieldType> operator -(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DiffOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct ProdOp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          ProdOp<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             ProdOp<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType,
                    FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             ProdOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          ProdOp<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;

          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct ProdOp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             ProdOp<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;

             ProdOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() * operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct ProdOp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             ProdOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() * operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct ProdOp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() * operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> operator *(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> operator *(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          ProdOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> operator *(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> operator *(FieldType const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> operator *(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 SubExpr2,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> operator *(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          ProdOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> operator *(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial,
                 SubExpr1,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial, SubExpr1, SubExpr2, FieldType>,
                             FieldType> operator *(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          ProdOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct DivOp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          DivOp<SeqWalk,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             DivOp<Resize,
                   typename Operand1::ResizeType,
                   typename Operand2::ResizeType,
                   FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             DivOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          DivOp<Reduction,
                typename Operand1::ReductionType,
                typename Operand2::ReductionType,
                FieldType> typedef ReductionType;

          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DivOp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             DivOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;

             DivOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() / operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct DivOp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             DivOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() / operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct DivOp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() / operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial, FieldType>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   FieldType>,
                             FieldType> operator /(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial,
                NeboScalar<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial, FieldType>,
                                   SubExpr2,
                                   FieldType>,
                             FieldType> operator /(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DivOp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboScalar<Initial, FieldType>,
                                   FieldType>,
                             FieldType> operator /(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DivOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboScalar<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   FieldType>,
                             FieldType> operator /(FieldType const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstField<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   SubExpr2,
                                   FieldType>,
                             FieldType> operator /(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DivOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   SubExpr1,
                                   NeboScalar<Initial, FieldType>,
                                   FieldType>,
                             FieldType> operator /(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DivOp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   FieldType>,
                             FieldType> operator /(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial, SubExpr1, NeboConstField<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial, SubExpr1, SubExpr2, FieldType>,
                             FieldType> operator /(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DivOp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SinFcn;
      template<typename Operand, typename FieldType>
       struct SinFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          SinFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             SinFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             SinFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          SinFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          SinFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct SinFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             SinFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             SinFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct SinFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          SinFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::sin(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct SinFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             SinFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::sin(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct SinFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          SinFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::sin(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<SinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> sin(FieldType const & arg) {
          SinFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<SinFcn<Initial, SubExpr, FieldType>, FieldType> sin(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg) {
          SinFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct CosFcn;
      template<typename Operand, typename FieldType>
       struct CosFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          CosFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             CosFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             CosFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          CosFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          CosFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct CosFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             CosFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             CosFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct CosFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          CosFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::cos(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct CosFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             CosFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::cos(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct CosFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          CosFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::cos(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<CosFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> cos(FieldType const & arg) {
          CosFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<CosFcn<Initial, SubExpr, FieldType>, FieldType> cos(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg) {
          CosFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanFcn;
      template<typename Operand, typename FieldType>
       struct TanFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          TanFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             TanFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             TanFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          TanFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          TanFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct TanFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             TanFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             TanFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct TanFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          TanFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::tan(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct TanFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             TanFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::tan(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct TanFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          TanFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::tan(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<TanFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> tan(FieldType const & arg) {
          TanFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<TanFcn<Initial, SubExpr, FieldType>, FieldType> tan(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg) {
          TanFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct ExpFcn;
      template<typename Operand, typename FieldType>
       struct ExpFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          ExpFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             ExpFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             ExpFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          ExpFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          ExpFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct ExpFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             ExpFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             ExpFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct ExpFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          ExpFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::exp(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct ExpFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             ExpFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::exp(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct ExpFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          ExpFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::exp(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<ExpFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> exp(FieldType const & arg) {
          ExpFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<ExpFcn<Initial, SubExpr, FieldType>, FieldType> exp(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg) {
          ExpFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct TanhFcn;
      template<typename Operand, typename FieldType>
       struct TanhFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          TanhFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             TanhFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             TanhFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          TanhFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          TanhFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct TanhFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             TanhFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             TanhFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct TanhFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          TanhFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::tanh(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct TanhFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             TanhFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::tanh(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct TanhFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          TanhFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::tanh(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<TanhFcn<Initial,
                                     NeboConstField<Initial,
                                                    typename NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                    Result>,
                                     FieldType>,
                             FieldType> tanh(FieldType const & arg) {
          TanhFcn<Initial, NeboConstField<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<TanhFcn<Initial, SubExpr, FieldType>, FieldType>
       tanh(NeboExpression<SubExpr, FieldType> const & arg) {
          TanhFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct AbsFcn;
      template<typename Operand, typename FieldType>
       struct AbsFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          AbsFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             AbsFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             AbsFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          AbsFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          AbsFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct AbsFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             AbsFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             AbsFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct AbsFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          AbsFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::abs(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct AbsFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             AbsFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::abs(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct AbsFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          AbsFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::abs(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<AbsFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> abs(FieldType const & arg) {
          AbsFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<AbsFcn<Initial, SubExpr, FieldType>, FieldType> abs(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg) {
          AbsFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NegFcn;
      template<typename Operand, typename FieldType>
       struct NegFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          NegFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NegFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NegFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          NegFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          NegFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct NegFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             NegFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             NegFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct NegFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          NegFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const { return -(operand_.eval()); }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct NegFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             NegFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return -(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct NegFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          NegFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const { return -(operand_.eval()); }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<NegFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> operator -(FieldType const & arg) {
          NegFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<NegFcn<Initial, SubExpr, FieldType>, FieldType>
       operator -(NeboExpression<SubExpr, FieldType> const & arg) {
          NegFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct PowFcn;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          PowFcn<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             PowFcn<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType,
                    FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             PowFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          PowFcn<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;

          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct PowFcn<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             PowFcn<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;

             PowFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return std::pow(operand1_.eval(), operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct PowFcn<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             PowFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return std::pow(operand1_.eval(), operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct PowFcn<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return std::pow(operand1_.eval(), operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> pow(typename FieldType::value_type const
                                            & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> pow(typename FieldType::value_type const
                                            & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          PowFcn<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> pow(FieldType const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> pow(FieldType const & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> pow(FieldType const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 SubExpr2,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          PowFcn<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial,
                 SubExpr1,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial, SubExpr1, SubExpr2, FieldType>,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          PowFcn<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct SqrtFcn;
      template<typename Operand, typename FieldType>
       struct SqrtFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          SqrtFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             SqrtFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             SqrtFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          SqrtFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct SqrtFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             SqrtFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             SqrtFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct SqrtFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::sqrt(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct SqrtFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             SqrtFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::sqrt(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct SqrtFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::sqrt(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<SqrtFcn<Initial,
                                     NeboConstField<Initial,
                                                    typename NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                    Result>,
                                     FieldType>,
                             FieldType> sqrt(FieldType const & arg) {
          SqrtFcn<Initial, NeboConstField<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<SqrtFcn<Initial, SubExpr, FieldType>, FieldType>
       sqrt(NeboExpression<SubExpr, FieldType> const & arg) {
          SqrtFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct LogFcn;
      template<typename Operand, typename FieldType>
       struct LogFcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          LogFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             LogFcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             LogFcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          LogFcn<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          LogFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct LogFcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             LogFcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             LogFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct LogFcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          LogFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::log(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct LogFcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             LogFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::log(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct LogFcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          LogFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::log(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<LogFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> log(FieldType const & arg) {
          LogFcn<Initial, NeboConstField<Initial, FieldType>, FieldType> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<LogFcn<Initial, SubExpr, FieldType>, FieldType> log(NeboExpression<SubExpr,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg) {
          LogFcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct Log10Fcn;
      template<typename Operand, typename FieldType>
       struct Log10Fcn<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          Log10Fcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             Log10Fcn<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             Log10Fcn<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          Log10Fcn<Reduction, typename Operand::ReductionType, FieldType>
          typedef ReductionType;

          Log10Fcn(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct Log10Fcn<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             Log10Fcn<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             Log10Fcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct Log10Fcn<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          Log10Fcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const {
             return std::log10(operand_.eval());
          }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct Log10Fcn<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             Log10Fcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return std::log10(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct Log10Fcn<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          Log10Fcn(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const {
             return std::log10(operand_.eval());
          }

         private:
          Operand operand_;
      };

      /* Field */
      template<typename FieldType>
       inline NeboExpression<Log10Fcn<Initial,
                                      NeboConstField<Initial,
                                                     typename NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                     Result>,
                                      FieldType>,
                             FieldType> log10(FieldType const & arg) {
          Log10Fcn<Initial, NeboConstField<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<Log10Fcn<Initial, SubExpr, FieldType>, FieldType>
       log10(NeboExpression<SubExpr, FieldType> const & arg) {
          Log10Fcn<Initial, SubExpr, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct EqualCmp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          EqualCmp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             EqualCmp<Resize,
                      typename Operand1::ResizeType,
                      typename Operand2::ResizeType,
                      FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             EqualCmp<GPUWalk,
                      typename Operand1::GPUWalkType,
                      typename Operand2::GPUWalkType,
                      FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          EqualCmp<Reduction,
                   typename Operand1::ReductionType,
                   typename Operand2::ReductionType,
                   FieldType> typedef ReductionType;

          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct EqualCmp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             EqualCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType,
                      FieldType> typedef SeqWalkType;

             EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() == operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct EqualCmp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() == operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct EqualCmp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() == operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial, FieldType>,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             FieldType>,
                                    FieldType> operator ==(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial,
                   NeboScalar<Initial, FieldType>,
                   NeboConstField<Initial, FieldType>,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial, FieldType>,
                                             SubExpr2,
                                             FieldType>,
                                    FieldType> operator ==(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             NeboScalar<Initial, FieldType>,
                                             FieldType>,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   NeboScalar<Initial, FieldType>,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             FieldType>,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   NeboConstField<Initial, FieldType>,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             SubExpr2,
                                             FieldType>,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   SubExpr2,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboScalar<Initial, FieldType>,
                                             FieldType>,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          EqualCmp<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             FieldType>,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial,
                   SubExpr1,
                   NeboConstField<Initial, FieldType>,
                   FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             SubExpr2,
                                             FieldType>,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct InequalCmp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          InequalCmp<SeqWalk,
                     typename Operand1::SeqWalkType,
                     typename Operand2::SeqWalkType,
                     FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             InequalCmp<Resize,
                        typename Operand1::ResizeType,
                        typename Operand2::ResizeType,
                        FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             InequalCmp<GPUWalk,
                        typename Operand1::GPUWalkType,
                        typename Operand2::GPUWalkType,
                        FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          InequalCmp<Reduction,
                     typename Operand1::ReductionType,
                     typename Operand2::ReductionType,
                     FieldType> typedef ReductionType;

          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct InequalCmp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             InequalCmp<SeqWalk,
                        typename Operand1::SeqWalkType,
                        typename Operand2::SeqWalkType,
                        FieldType> typedef SeqWalkType;

             InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() != operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct InequalCmp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() != operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct InequalCmp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() != operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial, FieldType>,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               FieldType>,
                                    FieldType> operator !=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial,
                     NeboScalar<Initial, FieldType>,
                     NeboConstField<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial, FieldType>,
                                               SubExpr2,
                                               FieldType>,
                                    FieldType> operator !=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial,
                     NeboScalar<Initial, FieldType>,
                     SubExpr2,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               NeboScalar<Initial, FieldType>,
                                               FieldType>,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     NeboScalar<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               FieldType>,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     NeboConstField<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               SubExpr2,
                                               FieldType>,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     SubExpr2,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial, FieldType>,
                                               FieldType>,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          InequalCmp<Initial,
                     SubExpr1,
                     NeboScalar<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               FieldType>,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial,
                     SubExpr1,
                     NeboConstField<Initial, FieldType>,
                     FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               SubExpr2,
                                               FieldType>,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanCmp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          LessThanCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType,
                      FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             LessThanCmp<Resize,
                         typename Operand1::ResizeType,
                         typename Operand2::ResizeType,
                         FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             LessThanCmp<GPUWalk,
                         typename Operand1::GPUWalkType,
                         typename Operand2::GPUWalkType,
                         FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          LessThanCmp<Reduction,
                      typename Operand1::ReductionType,
                      typename Operand2::ReductionType,
                      FieldType> typedef ReductionType;

          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanCmp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             LessThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType,
                         FieldType> typedef SeqWalkType;

             LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() < operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanCmp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() < operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanCmp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() < operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial, FieldType>,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                FieldType>,
                                    FieldType> operator <(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial,
                      NeboScalar<Initial, FieldType>,
                      NeboConstField<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial, FieldType>,
                                                SubExpr2,
                                                FieldType>,
                                    FieldType> operator <(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial,
                      NeboScalar<Initial, FieldType>,
                      SubExpr2,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                NeboScalar<Initial, FieldType>,
                                                FieldType>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      NeboScalar<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                FieldType>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      NeboConstField<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                SubExpr2,
                                                FieldType>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      SubExpr2,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboScalar<Initial, FieldType>,
                                                FieldType>,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          LessThanCmp<Initial,
                      SubExpr1,
                      NeboScalar<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                FieldType>,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial,
                      SubExpr1,
                      NeboConstField<Initial, FieldType>,
                      FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                SubExpr2,
                                                FieldType>,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct LessThanEqualCmp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          LessThanEqualCmp<SeqWalk,
                           typename Operand1::SeqWalkType,
                           typename Operand2::SeqWalkType,
                           FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             LessThanEqualCmp<Resize,
                              typename Operand1::ResizeType,
                              typename Operand2::ResizeType,
                              FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             LessThanEqualCmp<GPUWalk,
                              typename Operand1::GPUWalkType,
                              typename Operand2::GPUWalkType,
                              FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          LessThanEqualCmp<Reduction,
                           typename Operand1::ReductionType,
                           typename Operand2::ReductionType,
                           FieldType> typedef ReductionType;

          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanEqualCmp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             LessThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType,
                              FieldType> typedef SeqWalkType;

             LessThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() <= operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct LessThanEqualCmp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             LessThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() <= operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct LessThanEqualCmp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() <= operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial,
                                                                FieldType>,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     FieldType>,
                                    FieldType> operator <=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           NeboScalar<Initial, FieldType>,
                           NeboConstField<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial,
                                                                FieldType>,
                                                     SubExpr2,
                                                     FieldType>,
                                    FieldType> operator <=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboScalar<Initial, FieldType>,
                           SubExpr2,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     NeboScalar<Initial,
                                                                FieldType>,
                                                     FieldType>,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           NeboScalar<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     FieldType>,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           NeboConstField<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     SubExpr2,
                                                     FieldType>,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           SubExpr2,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboScalar<Initial,
                                                                FieldType>,
                                                     FieldType>,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           SubExpr1,
                           NeboScalar<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     FieldType>,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           SubExpr1,
                           NeboConstField<Initial, FieldType>,
                           FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     SubExpr2,
                                                     FieldType>,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanCmp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          GreaterThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType,
                         FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             GreaterThanCmp<Resize,
                            typename Operand1::ResizeType,
                            typename Operand2::ResizeType,
                            FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             GreaterThanCmp<GPUWalk,
                            typename Operand1::GPUWalkType,
                            typename Operand2::GPUWalkType,
                            FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          GreaterThanCmp<Reduction,
                         typename Operand1::ReductionType,
                         typename Operand2::ReductionType,
                         FieldType> typedef ReductionType;

          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanCmp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             GreaterThanCmp<SeqWalk,
                            typename Operand1::SeqWalkType,
                            typename Operand2::SeqWalkType,
                            FieldType> typedef SeqWalkType;

             GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() > operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanCmp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() > operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanCmp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() > operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial, FieldType>,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   FieldType>,
                                    FieldType> operator >(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial,
                         NeboScalar<Initial, FieldType>,
                         NeboConstField<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial, FieldType>,
                                                   SubExpr2,
                                                   FieldType>,
                                    FieldType> operator >(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial,
                         NeboScalar<Initial, FieldType>,
                         SubExpr2,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   NeboScalar<Initial, FieldType>,
                                                   FieldType>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         NeboScalar<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   FieldType>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         NeboConstField<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   SubExpr2,
                                                   FieldType>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         SubExpr2,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboScalar<Initial, FieldType>,
                                                   FieldType>,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          GreaterThanCmp<Initial,
                         SubExpr1,
                         NeboScalar<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   FieldType>,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial,
                         SubExpr1,
                         NeboConstField<Initial, FieldType>,
                         FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   SubExpr2,
                                                   FieldType>,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct GreaterThanEqualCmp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          GreaterThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType,
                              FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             GreaterThanEqualCmp<Resize,
                                 typename Operand1::ResizeType,
                                 typename Operand2::ResizeType,
                                 FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             GreaterThanEqualCmp<GPUWalk,
                                 typename Operand1::GPUWalkType,
                                 typename Operand2::GPUWalkType,
                                 FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          GreaterThanEqualCmp<Reduction,
                              typename Operand1::ReductionType,
                              typename Operand2::ReductionType,
                              FieldType> typedef ReductionType;

          GreaterThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanEqualCmp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             GreaterThanEqualCmp<SeqWalk,
                                 typename Operand1::SeqWalkType,
                                 typename Operand2::SeqWalkType,
                                 FieldType> typedef SeqWalkType;

             GreaterThanEqualCmp(Operand1 const & operand1,
                                 Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          GreaterThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() >= operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct GreaterThanEqualCmp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             GreaterThanEqualCmp(Operand1 const & operand1,
                                 Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() >= operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct GreaterThanEqualCmp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          GreaterThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() >= operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial,
                                                                   FieldType>,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        FieldType>,
                                    FieldType> operator >=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboScalar<Initial, FieldType>,
                              NeboConstField<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial,
                                                                   FieldType>,
                                                        SubExpr2,
                                                        FieldType>,
                                    FieldType> operator >=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboScalar<Initial, FieldType>,
                              SubExpr2,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        NeboScalar<Initial,
                                                                   FieldType>,
                                                        FieldType>,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              NeboScalar<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        FieldType>,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              NeboConstField<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        SubExpr2,
                                                        FieldType>,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              SubExpr2,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboScalar<Initial,
                                                                   FieldType>,
                                                        FieldType>,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              SubExpr1,
                              NeboScalar<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        FieldType>,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              SubExpr1,
                              NeboConstField<Initial, FieldType>,
                              FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        SubExpr2,
                                                        FieldType>,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial, SubExpr1, SubExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct AndOp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          AndOp<SeqWalk,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType,
                FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             AndOp<Resize,
                   typename Operand1::ResizeType,
                   typename Operand2::ResizeType,
                   FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             AndOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType,
                   FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          AndOp<Reduction,
                typename Operand1::ReductionType,
                typename Operand2::ReductionType,
                FieldType> typedef ReductionType;

          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct AndOp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             AndOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType,
                   FieldType> typedef SeqWalkType;

             AndOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() && operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct AndOp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             AndOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() && operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct AndOp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() && operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboBoolean<Initial, FieldType>,
                                          SubBoolExpr2,
                                          FieldType>,
                                    FieldType> operator &&(bool const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          AndOp<Initial,
                NeboBoolean<Initial, FieldType>,
                SubBoolExpr2,
                FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboBoolean<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolExpr1,
                                          NeboBoolean<Initial, FieldType>,
                                          FieldType>,
                                    FieldType> operator &&(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           bool const & arg2) {
          AndOp<Initial,
                SubBoolExpr1,
                NeboBoolean<Initial, FieldType>,
                FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboBoolean<Initial, FieldType>(arg2)));
       }

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolExpr1,
                                          SubBoolExpr2,
                                          FieldType>,
                                    FieldType> operator &&(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          AndOp<Initial, SubBoolExpr1, SubBoolExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct OrOp;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          OrOp<SeqWalk,
               typename Operand1::SeqWalkType,
               typename Operand2::SeqWalkType,
               FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             OrOp<Resize,
                  typename Operand1::ResizeType,
                  typename Operand2::ResizeType,
                  FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             OrOp<GPUWalk,
                  typename Operand1::GPUWalkType,
                  typename Operand2::GPUWalkType,
                  FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          OrOp<Reduction,
               typename Operand1::ReductionType,
               typename Operand2::ReductionType,
               FieldType> typedef ReductionType;

          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct OrOp<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             OrOp<SeqWalk,
                  typename Operand1::SeqWalkType,
                  typename Operand2::SeqWalkType,
                  FieldType> typedef SeqWalkType;

             OrOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() || operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct OrOp<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             OrOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return (operand1_.eval() || operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct OrOp<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return (operand1_.eval() || operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboBoolean<Initial, FieldType>,
                                         SubBoolExpr2,
                                         FieldType>,
                                    FieldType> operator ||(bool const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          OrOp<Initial, NeboBoolean<Initial, FieldType>, SubBoolExpr2, FieldType>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboBoolean<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolExpr1,
                                         NeboBoolean<Initial, FieldType>,
                                         FieldType>,
                                    FieldType> operator ||(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           bool const & arg2) {
          OrOp<Initial, SubBoolExpr1, NeboBoolean<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboBoolean<Initial, FieldType>(arg2)));
       }

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolExpr1,
                                         SubBoolExpr2,
                                         FieldType>,
                                    FieldType> operator ||(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          OrOp<Initial, SubBoolExpr1, SubBoolExpr2, FieldType> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand, typename FieldType>
       struct NotOp;
      template<typename Operand, typename FieldType>
       struct NotOp<Initial, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          NotOp<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NotOp<Resize, typename Operand::ResizeType, FieldType> typedef
             ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NotOp<GPUWalk, typename Operand::GPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          NotOp<Reduction, typename Operand::ReductionType, FieldType> typedef
          ReductionType;

          NotOp(Operand const & operand)
          : operand_(operand)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return operand_.possible_ghosts();
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand_.reduce_init(ghosts, shift));
          }

         private:
          Operand const operand_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand, typename FieldType>
          struct NotOp<Resize, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             NotOp<SeqWalk, typename Operand::SeqWalkType, FieldType> typedef
             SeqWalkType;

             NotOp(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand_.init(shift, split, location));
             }

            private:
             Operand const operand_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand, typename FieldType>
       struct NotOp<SeqWalk, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          NotOp(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline EvalReturnType eval(void) const { return !(operand_.eval()); }

         private:
          Operand operand_;
      };
#     ifdef __CUDACC__
         template<typename Operand, typename FieldType>
          struct NotOp<GPUWalk, Operand, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             NotOp(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline void start(int x, int y) { operand_.start(x, y); }

             __device__ inline void next(void) { operand_.next(); }

             __device__ inline AtomicType eval(void) const {
                return !(operand_.eval());
             }

            private:
             Operand operand_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand, typename FieldType>
       struct NotOp<Reduction, Operand, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          bool typedef EvalReturnType;

          NotOp(Operand const & operand)
          : operand_(operand)
          {}

          inline void next(void) { operand_.next(); }

          inline bool at_end(void) const { return (operand_.at_end()); }

          inline bool has_length(void) const { return (operand_.has_length()); }

          inline EvalReturnType eval(void) const { return !(operand_.eval()); }

         private:
          Operand operand_;
      };

      /* SubBoolExpr */
      template<typename SubBoolExpr, typename FieldType>
       inline NeboBooleanExpression<NotOp<Initial, SubBoolExpr, FieldType>,
                                    FieldType> operator !(NeboBooleanExpression<SubBoolExpr,
                                                                                FieldType>
                                                          const & arg) {
          NotOp<Initial, SubBoolExpr, FieldType> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct MaxFcn;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct MaxFcn<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          MaxFcn<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             MaxFcn<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType,
                    FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             MaxFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          MaxFcn<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;

          MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct MaxFcn<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             MaxFcn<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;

             MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct MaxFcn<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return ((operand1_.eval() > operand2_.eval()) ? operand1_.eval() :
                     operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct MaxFcn<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return ((operand1_.eval() > operand2_.eval()) ? operand1_.eval()
                        : operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct MaxFcn<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return ((operand1_.eval() > operand2_.eval()) ? operand1_.eval() :
                     operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> max(typename FieldType::value_type const
                                            & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> max(typename FieldType::value_type const
                                            & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MaxFcn<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> max(FieldType const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MaxFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> max(FieldType const & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> max(FieldType const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MaxFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 SubExpr2,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> max(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MaxFcn<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> max(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial,
                 SubExpr1,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial, SubExpr1, SubExpr2, FieldType>,
                             FieldType> max(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MaxFcn<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode,
               typename Operand1,
               typename Operand2,
               typename FieldType>
       struct MinFcn;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct MinFcn<Initial, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          MinFcn<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType,
                 FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             MinFcn<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType,
                    FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             MinFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType,
                    FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          MinFcn<Reduction,
                 typename Operand1::ReductionType,
                 typename Operand2::ReductionType,
                 FieldType> typedef ReductionType;

          MinFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(operand1_.possible_ghosts(), operand2_.possible_ghosts());
          }

          inline SeqWalkType init(structured::GhostData const & ghosts,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(operand1_.init(ghosts, shift),
                                operand2_.init(ghosts, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::GhostData const & ghosts) const {
                return ResizeType(operand1_.resize(ghosts), operand2_.resize(ghosts));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(structured::GhostData const & ghosts,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(ghosts, shift, deviceIndex),
                                   operand2_.gpu_init(ghosts, shift, deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::GhostData const & ghosts,
                                           structured::IntVec const & shift) const {
             return ReductionType(operand1_.reduce_init(ghosts, shift),
                                  operand2_.reduce_init(ghosts, shift));
          }

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Operand1, typename Operand2, typename FieldType>
          struct MinFcn<Resize, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             MinFcn<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType,
                    FieldType> typedef SeqWalkType;

             MinFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(operand1_.init(shift, split, location),
                                   operand2_.init(shift, split, location));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct MinFcn<SeqWalk, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          MinFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline EvalReturnType eval(void) const {
             return ((operand1_.eval() < operand2_.eval()) ? operand1_.eval() :
                     operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
#     ifdef __CUDACC__
         template<typename Operand1, typename Operand2, typename FieldType>
          struct MinFcn<GPUWalk, Operand1, Operand2, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::memory_window typedef MemoryWindow;

             typename field_type::value_type typedef AtomicType;

             MinFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline void start(int x, int y) {
                operand1_.start(x, y);

                operand2_.start(x, y);
             }

             __device__ inline void next(void) {
                operand1_.next();

                operand2_.next();
             }

             __device__ inline AtomicType eval(void) const {
                return ((operand1_.eval() < operand2_.eval()) ? operand1_.eval()
                        : operand2_.eval());
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Operand1, typename Operand2, typename FieldType>
       struct MinFcn<Reduction, Operand1, Operand2, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::memory_window typedef MemoryWindow;

          typename FieldType::value_type typedef EvalReturnType;

          MinFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline void next(void) { operand1_.next(); operand2_.next(); }

          inline bool at_end(void) const {
             return (operand1_.at_end() || operand2_.at_end());
          }

          inline bool has_length(void) const {
             return (operand1_.has_length() || operand2_.has_length());
          }

          inline EvalReturnType eval(void) const {
             return ((operand1_.eval() < operand2_.eval()) ? operand1_.eval() :
                     operand2_.eval());
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> min(typename FieldType::value_type const
                                            & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial,
                 NeboScalar<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboScalar<Initial, FieldType>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> min(typename FieldType::value_type const
                                            & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MinFcn<Initial, NeboScalar<Initial, FieldType>, SubExpr2, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> min(FieldType const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MinFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> min(FieldType const & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2,
                                    FieldType>,
                             FieldType> min(FieldType const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MinFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 SubExpr2,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial, FieldType>,
                                    FieldType>,
                             FieldType> min(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MinFcn<Initial, SubExpr1, NeboScalar<Initial, FieldType>, FieldType>
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial, FieldType>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    FieldType>,
                             FieldType> min(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial,
                 SubExpr1,
                 NeboConstField<Initial, FieldType>,
                 FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial, SubExpr1, SubExpr2, FieldType>,
                             FieldType> min(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MinFcn<Initial, SubExpr1, SubExpr2, FieldType> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };
   } /* SpatialOps */

#endif
/* NEBO_OPERATORS_H */
